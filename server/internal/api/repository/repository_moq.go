// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package repository

import (
	"context"
	"database/sql"
	sq "github.com/Masterminds/squirrel"
	"github.com/rimdian/rimdian/internal/api/dto"
	"github.com/rimdian/rimdian/internal/api/entity"
	"sync"
	"time"
)

// Ensure, that RepositoryMock does implement Repository.
// If this is not the case, regenerate this file with moq.
var _ Repository = &RepositoryMock{}

// RepositoryMock is a mock implementation of Repository.
//
//	func TestSomethingThatUsesRepository(t *testing.T) {
//
//		// make and configure a mocked Repository
//		mockedRepository := &RepositoryMock{
//			AbortTaskExecFunc: func(ctx context.Context, taskID string, message string, tx *sql.Tx) error {
//				panic("mock out the AbortTaskExec method")
//			},
//			AccountLogoutFunc: func(ctx context.Context, accountID string, sessionID string) error {
//				panic("mock out the AccountLogout method")
//			},
//			ActivateAppTasksFunc: func(ctx context.Context, workspaceID string, appID string, tx *sql.Tx) error {
//				panic("mock out the ActivateAppTasks method")
//			},
//			ActivateSegmentFunc: func(ctx context.Context, workspaceID string, segmentID string, segmentVersion int) (bool, error) {
//				panic("mock out the ActivateSegment method")
//			},
//			AddAccountToOrganizationFunc: func(ctx context.Context, accountID string, organizationID string, isOwner bool, fromAccountID *string, workspaceScopes entity.WorkspacesScopes, tx *sql.Tx) error {
//				panic("mock out the AddAccountToOrganization method")
//			},
//			AddColumnFunc: func(ctx context.Context, workspace *entity.Workspace, tableName string, column *entity.TableColumn) error {
//				panic("mock out the AddColumn method")
//			},
//			AddJobToTaskExecFunc: func(ctxWithTimeout context.Context, taskExecID string, newJobID string, tx *sql.Tx) error {
//				panic("mock out the AddJobToTaskExec method")
//			},
//			AddTaskExecWorkerFunc: func(ctx context.Context, taskID string, newJobID string, workerID int, initialWorkerState entity.TaskWorkerState, tx *sql.Tx) error {
//				panic("mock out the AddTaskExecWorker method")
//			},
//			CancelOrganizationInvitationFunc: func(ctx context.Context, organizationID string, email string) error {
//				panic("mock out the CancelOrganizationInvitation method")
//			},
//			CleanAfterUserAliasFunc: func(workspaceID string, fromUserExternalID string) error {
//				panic("mock out the CleanAfterUserAlias method")
//			},
//			ClearUserSegmentQueueFunc: func(ctx context.Context, workspaceID string, segmentID string, segmentVersion int) error {
//				panic("mock out the ClearUserSegmentQueue method")
//			},
//			ConsumeInvitationFunc: func(ctx context.Context, accountID string, insertAccount *entity.Account, invitation *entity.OrganizationInvitation) error {
//				panic("mock out the ConsumeInvitation method")
//			},
//			CountSuccessfulDataLogsForDemoFunc: func(ctx context.Context, workspaceID string) (int64, error) {
//				panic("mock out the CountSuccessfulDataLogsForDemo method")
//			},
//			CreateChannelFunc: func(ctx context.Context, workspace *entity.Workspace, channel *entity.Channel) error {
//				panic("mock out the CreateChannel method")
//			},
//			CreateOrganizationFunc: func(ctx context.Context, organization *entity.Organization, tx *sql.Tx) error {
//				panic("mock out the CreateOrganization method")
//			},
//			CreateSubscriptionListFunc: func(ctx context.Context, workspaceID string, list *entity.SubscriptionList) error {
//				panic("mock out the CreateSubscriptionList method")
//			},
//			CreateTableFunc: func(ctx context.Context, workspace *entity.Workspace, table *entity.AppTableManifest) error {
//				panic("mock out the CreateTable method")
//			},
//			CreateUserAliasFunc: func(ctx context.Context, fromUserExternalID string, toUserExternalID string, toUserIsAuthenticated bool, tx *sql.Tx) error {
//				panic("mock out the CreateUserAlias method")
//			},
//			CreateWorkspaceTablesFunc: func(ctx context.Context, workspaceID string, tx *sql.Tx) error {
//				panic("mock out the CreateWorkspaceTables method")
//			},
//			DeactivateOrganizationAccountFunc: func(ctx context.Context, accountID string, deactivateAccountID string, organizationID string) error {
//				panic("mock out the DeactivateOrganizationAccount method")
//			},
//			DeleteAppFunc: func(ctx context.Context, appID string, tx *sql.Tx) error {
//				panic("mock out the DeleteApp method")
//			},
//			DeleteAppItemByExternalIDFunc: func(ctx context.Context, workspace *entity.Workspace, kind string, externalID string, tx *sql.Tx) error {
//				panic("mock out the DeleteAppItemByExternalID method")
//			},
//			DeleteAppItemByIDFunc: func(ctx context.Context, workspace *entity.Workspace, kind string, ID string, tx *sql.Tx) error {
//				panic("mock out the DeleteAppItemByID method")
//			},
//			DeleteAppTasksFunc: func(ctx context.Context, workspaceID string, appID string, tx *sql.Tx) error {
//				panic("mock out the DeleteAppTasks method")
//			},
//			DeleteCartItemFunc: func(ctx context.Context, cartItemID string, userID string, tx *sql.Tx) error {
//				panic("mock out the DeleteCartItem method")
//			},
//			DeleteChannelFunc: func(ctx context.Context, workspace *entity.Workspace, deletedChannelID string) error {
//				panic("mock out the DeleteChannel method")
//			},
//			DeleteColumnFunc: func(ctx context.Context, workspace *entity.Workspace, tableName string, column *entity.TableColumn) error {
//				panic("mock out the DeleteColumn method")
//			},
//			DeleteDomainFunc: func(ctx context.Context, workspace *entity.Workspace, deletedDomainID string, migrateToDomainID string) error {
//				panic("mock out the DeleteDomain method")
//			},
//			DeleteOrderItemFunc: func(ctx context.Context, orderItemID string, userID string, tx *sql.Tx) error {
//				panic("mock out the DeleteOrderItem method")
//			},
//			DeleteSegmentFunc: func(ctx context.Context, workspaceID string, segmentID string) error {
//				panic("mock out the DeleteSegment method")
//			},
//			DeleteTableFunc: func(ctx context.Context, workspaceID string, tableName string) error {
//				panic("mock out the DeleteTable method")
//			},
//			DeleteUserSegmentFunc: func(ctx context.Context, userID string, segmentID string, tx *sql.Tx) error {
//				panic("mock out the DeleteUserSegment method")
//			},
//			DeleteUserSegmentQueueRowFunc: func(ctx context.Context, workspaceID string, segmentID string, segmentVersion int, userID string, tx *sql.Tx) error {
//				panic("mock out the DeleteUserSegmentQueueRow method")
//			},
//			DeleteWorkspaceFunc: func(ctx context.Context, workspaceID string) error {
//				panic("mock out the DeleteWorkspace method")
//			},
//			DevResetDBFunc: func(ctx context.Context, rootAccount *entity.Account, defaultOrganization *entity.Organization) error {
//				panic("mock out the DevResetDB method")
//			},
//			EnqueueMatchingSegmentUsersFunc: func(ctx context.Context, workspaceID string, segment *entity.Segment) (int, int, error) {
//				panic("mock out the EnqueueMatchingSegmentUsers method")
//			},
//			EnsureUsersLockFunc: func(ctx context.Context, workspaceID string, lock *entity.UsersLock, withRetry bool) error {
//				panic("mock out the EnsureUsersLock method")
//			},
//			EnterUserSegmentFromQueueFunc: func(ctx context.Context, workspaceID string, segmentID string, segmentVersion int) error {
//				panic("mock out the EnterUserSegmentFromQueue method")
//			},
//			ExitUserSegmentFromQueueFunc: func(ctx context.Context, workspaceID string, segmentID string, segmentVersion int) error {
//				panic("mock out the ExitUserSegmentFromQueue method")
//			},
//			FetchAppItemsFunc: func(ctx context.Context, workspace *entity.Workspace, kind string, query sq.SelectBuilder, tx *sql.Tx) ([]*entity.AppItem, error) {
//				panic("mock out the FetchAppItems method")
//			},
//			FetchCustomEventsFunc: func(ctx context.Context, workspace *entity.Workspace, query sq.SelectBuilder, tx *sql.Tx) ([]*entity.CustomEvent, error) {
//				panic("mock out the FetchCustomEvents method")
//			},
//			FetchDevicesFunc: func(ctx context.Context, workspace *entity.Workspace, query sq.SelectBuilder, tx *sql.Tx) ([]*entity.Device, error) {
//				panic("mock out the FetchDevices method")
//			},
//			FetchSessionsFunc: func(ctx context.Context, workspace *entity.Workspace, query sq.SelectBuilder, tx *sql.Tx) ([]*entity.Session, error) {
//				panic("mock out the FetchSessions method")
//			},
//			FindAppItemByExternalIDFunc: func(ctx context.Context, workspace *entity.Workspace, kind string, externalID string, tx *sql.Tx) (*entity.AppItem, error) {
//				panic("mock out the FindAppItemByExternalID method")
//			},
//			FindAppItemByIDFunc: func(ctx context.Context, workspace *entity.Workspace, kind string, id string, tx *sql.Tx) (*entity.AppItem, error) {
//				panic("mock out the FindAppItemByID method")
//			},
//			FindCartByIDFunc: func(ctx context.Context, workspaceID string, cartID string, userID string, tx *sql.Tx) (*entity.Cart, error) {
//				panic("mock out the FindCartByID method")
//			},
//			FindCartItemsByCartIDFunc: func(ctx context.Context, workspaceID string, cartID string, userID string, tx *sql.Tx) ([]*entity.CartItem, error) {
//				panic("mock out the FindCartItemsByCartID method")
//			},
//			FindCustomEventByIDFunc: func(ctx context.Context, workspace *entity.Workspace, eventID string, userID string, tx *sql.Tx) (*entity.CustomEvent, error) {
//				panic("mock out the FindCustomEventByID method")
//			},
//			FindDeviceByIDFunc: func(ctx context.Context, workspace *entity.Workspace, deviceID string, userID string, tx *sql.Tx) (*entity.Device, error) {
//				panic("mock out the FindDeviceByID method")
//			},
//			FindEventualUsersToMergeWithFunc: func(ctx context.Context, workspace *entity.Workspace, withUser *entity.User, withReconciliationKeys entity.MapOfInterfaces, tx *sql.Tx) ([]*entity.User, error) {
//				panic("mock out the FindEventualUsersToMergeWith method")
//			},
//			FindMessageByIDFunc: func(ctx context.Context, workspace *entity.Workspace, id string, userID string, tx *sql.Tx) (*entity.Message, error) {
//				panic("mock out the FindMessageByID method")
//			},
//			FindOrderByIDFunc: func(ctx context.Context, workspace *entity.Workspace, orderID string, userID string, tx *sql.Tx) (*entity.Order, error) {
//				panic("mock out the FindOrderByID method")
//			},
//			FindOrderItemsByOrderIDFunc: func(ctx context.Context, workspaceID string, orderID string, userID string, tx *sql.Tx) ([]*entity.OrderItem, error) {
//				panic("mock out the FindOrderItemsByOrderID method")
//			},
//			FindPageviewByIDFunc: func(ctx context.Context, workspace *entity.Workspace, pageviewID string, userID string, tx *sql.Tx) (*entity.Pageview, error) {
//				panic("mock out the FindPageviewByID method")
//			},
//			FindPostviewByIDFunc: func(ctx context.Context, workspaceID *entity.Workspace, postviewID string, userID string, tx *sql.Tx) (*entity.Postview, error) {
//				panic("mock out the FindPostviewByID method")
//			},
//			FindSessionByIDFunc: func(ctx context.Context, workspace *entity.Workspace, sessionID string, userID string, tx *sql.Tx) (*entity.Session, error) {
//				panic("mock out the FindSessionByID method")
//			},
//			FindSubscriptionListUserFunc: func(ctx context.Context, listID string, userID string, tx *sql.Tx) (*entity.SubscriptionListUser, error) {
//				panic("mock out the FindSubscriptionListUser method")
//			},
//			FindUserAliasFunc: func(ctx context.Context, fromUserExternalID string, tx *sql.Tx) (*entity.UserAlias, error) {
//				panic("mock out the FindUserAlias method")
//			},
//			FindUserByIDFunc: func(ctx context.Context, workspace *entity.Workspace, userID string, tx *sql.Tx, userWith *dto.UserWith) (*entity.User, error) {
//				panic("mock out the FindUserByID method")
//			},
//			FindUserIDsWithOrdersToReattributeFunc: func(ctx context.Context, workspaceID string, limit int) ([]string, error) {
//				panic("mock out the FindUserIDsWithOrdersToReattribute method")
//			},
//			FindUsersAliasedFunc: func(ctx context.Context, workspaceID string, toUserExternalID string) ([]*entity.UserAlias, error) {
//				panic("mock out the FindUsersAliased method")
//			},
//			GetAccountFromEmailFunc: func(ctx context.Context, email string) (*entity.Account, error) {
//				panic("mock out the GetAccountFromEmail method")
//			},
//			GetAccountFromIDFunc: func(ctx context.Context, accountID string) (*entity.Account, error) {
//				panic("mock out the GetAccountFromID method")
//			},
//			GetAppFunc: func(ctx context.Context, workspaceID string, appID string) (*entity.App, error) {
//				panic("mock out the GetApp method")
//			},
//			GetBroadcastCampaignFunc: func(ctx context.Context, workspaceID string, campaignID string) (*entity.BroadcastCampaign, error) {
//				panic("mock out the GetBroadcastCampaign method")
//			},
//			GetDataLogFunc: func(ctx context.Context, workspaceID string, dataLogID string) (*entity.DataLog, error) {
//				panic("mock out the GetDataLog method")
//			},
//			GetDataLogChildrenFunc: func(ctx context.Context, workspaceID string, dataLogID string) ([]*entity.DataLog, error) {
//				panic("mock out the GetDataLogChildren method")
//			},
//			GetInvitationFunc: func(ctx context.Context, email string, organizationID string) (*entity.OrganizationInvitation, error) {
//				panic("mock out the GetInvitation method")
//			},
//			GetMessageTemplateFunc: func(ctx context.Context, workspaceID string, id string, version *int64, tx *sql.Tx) (*entity.MessageTemplate, error) {
//				panic("mock out the GetMessageTemplate method")
//			},
//			GetOrganizationFunc: func(ctx context.Context, organizationID string) (*entity.Organization, error) {
//				panic("mock out the GetOrganization method")
//			},
//			GetRunningTaskExecByTaskIDFunc: func(ctx context.Context, taskID string, multipleExecKey *string, tx *sql.Tx) (*entity.TaskExec, error) {
//				panic("mock out the GetRunningTaskExecByTaskID method")
//			},
//			GetSegmentFunc: func(ctx context.Context, workspaceID string, segmentID string) (*entity.Segment, error) {
//				panic("mock out the GetSegment method")
//			},
//			GetSettingsFunc: func(ctx context.Context) (*entity.Settings, error) {
//				panic("mock out the GetSettings method")
//			},
//			GetSubscriptionListFunc: func(ctx context.Context, workspaceID string, listID string, tx *sql.Tx) (*entity.SubscriptionList, error) {
//				panic("mock out the GetSubscriptionList method")
//			},
//			GetSubscriptionListUsersToMessageFunc: func(ctx context.Context, workspaceID string, listIDs []string, offset int64, limit int64) ([]*entity.SubscriptionListUser, error) {
//				panic("mock out the GetSubscriptionListUsersToMessage method")
//			},
//			GetSystemConnectionFunc: func(ctx context.Context) (*sql.Conn, error) {
//				panic("mock out the GetSystemConnection method")
//			},
//			GetTaskFunc: func(ctx context.Context, workspaceID string, taskID string, tx *sql.Tx) (*entity.Task, error) {
//				panic("mock out the GetTask method")
//			},
//			GetTaskExecFunc: func(ctx context.Context, workspaceID string, taskID string) (*entity.TaskExec, error) {
//				panic("mock out the GetTaskExec method")
//			},
//			GetTaskExecJobFunc: func(ctx context.Context, workspaceID string, jobID string) (*entity.TaskExecJob, error) {
//				panic("mock out the GetTaskExecJob method")
//			},
//			GetTaskExecJobsFunc: func(ctx context.Context, workspaceID string, taskExecID string, offset int, limit int) ([]*entity.TaskExecJob, int, error) {
//				panic("mock out the GetTaskExecJobs method")
//			},
//			GetUsersNotInSubscriptionListFunc: func(ctx context.Context, workspaceID string, listID string, offset int64, limit int64, segmentID *string) ([]*dto.UserToImportToSubscriptionList, error) {
//				panic("mock out the GetUsersNotInSubscriptionList method")
//			},
//			GetWorkspaceFunc: func(ctx context.Context, workspaceID string) (*entity.Workspace, error) {
//				panic("mock out the GetWorkspace method")
//			},
//			GetWorkspaceConnectionFunc: func(ctx context.Context, workspaceID string) (*sql.Conn, error) {
//				panic("mock out the GetWorkspaceConnection method")
//			},
//			HasDataLogsToReprocessFunc: func(ctx context.Context, workspaceID string, untilDate time.Time) (bool, error) {
//				panic("mock out the HasDataLogsToReprocess method")
//			},
//			InsertAccountFunc: func(ctx context.Context, account *entity.Account, organizationID string, fromAccountID string, tx *sql.Tx) error {
//				panic("mock out the InsertAccount method")
//			},
//			InsertAccountSessionFunc: func(ctx context.Context, accountSession *entity.AccountSession) error {
//				panic("mock out the InsertAccountSession method")
//			},
//			InsertAppFunc: func(ctx context.Context, app *entity.App, tx *sql.Tx) error {
//				panic("mock out the InsertApp method")
//			},
//			InsertAppItemFunc: func(ctx context.Context, kind string, upsertedAppItem *entity.AppItem, tx *sql.Tx) error {
//				panic("mock out the InsertAppItem method")
//			},
//			InsertBroadcastCampaignFunc: func(ctx context.Context, workspaceID string, campaign *entity.BroadcastCampaign) error {
//				panic("mock out the InsertBroadcastCampaign method")
//			},
//			InsertCartFunc: func(ctx context.Context, cart *entity.Cart, tx *sql.Tx) error {
//				panic("mock out the InsertCart method")
//			},
//			InsertCartItemFunc: func(ctx context.Context, cartItem *entity.CartItem, tx *sql.Tx) error {
//				panic("mock out the InsertCartItem method")
//			},
//			InsertCustomEventFunc: func(ctx context.Context, event *entity.CustomEvent, tx *sql.Tx) error {
//				panic("mock out the InsertCustomEvent method")
//			},
//			InsertDataLogFunc: func(ctx context.Context, workspaceID string, dataLog *entity.DataLog, tx *sql.Tx) error {
//				panic("mock out the InsertDataLog method")
//			},
//			InsertDeviceFunc: func(ctx context.Context, device *entity.Device, tx *sql.Tx) error {
//				panic("mock out the InsertDevice method")
//			},
//			InsertMessageFunc: func(ctx context.Context, message *entity.Message, tx *sql.Tx) error {
//				panic("mock out the InsertMessage method")
//			},
//			InsertMessageTemplateFunc: func(ctx context.Context, workspaceID string, template *entity.MessageTemplate, tx *sql.Tx) error {
//				panic("mock out the InsertMessageTemplate method")
//			},
//			InsertOrderFunc: func(ctx context.Context, order *entity.Order, tx *sql.Tx) error {
//				panic("mock out the InsertOrder method")
//			},
//			InsertOrderItemFunc: func(ctx context.Context, orderItem *entity.OrderItem, tx *sql.Tx) error {
//				panic("mock out the InsertOrderItem method")
//			},
//			InsertPageviewFunc: func(ctx context.Context, pageview *entity.Pageview, tx *sql.Tx) error {
//				panic("mock out the InsertPageview method")
//			},
//			InsertPostviewFunc: func(ctx context.Context, postview *entity.Postview, tx *sql.Tx) error {
//				panic("mock out the InsertPostview method")
//			},
//			InsertSegmentFunc: func(ctx context.Context, segment *entity.Segment, tx *sql.Tx) error {
//				panic("mock out the InsertSegment method")
//			},
//			InsertSegmentDataLogsFunc: func(ctx context.Context, workspaceID string, segmentID string, segmentVersion int, taskID string, isEnter bool, createdAt time.Time, checkpoint int) error {
//				panic("mock out the InsertSegmentDataLogs method")
//			},
//			InsertServiceAccountFunc: func(ctx context.Context, account *entity.Account, organizationID string, fromAccountID string, workspaceScopes entity.WorkspacesScopes) error {
//				panic("mock out the InsertServiceAccount method")
//			},
//			InsertSessionFunc: func(ctx context.Context, session *entity.Session, tx *sql.Tx) error {
//				panic("mock out the InsertSession method")
//			},
//			InsertSubscriptionListUserFunc: func(ctx context.Context, subscription *entity.SubscriptionListUser, tx *sql.Tx) error {
//				panic("mock out the InsertSubscriptionListUser method")
//			},
//			InsertTaskFunc: func(ctx context.Context, task *entity.Task, tx *sql.Tx) error {
//				panic("mock out the InsertTask method")
//			},
//			InsertTaskExecFunc: func(ctx context.Context, workspaceID string, task *entity.TaskExec, job *entity.TaskExecJob, tx *sql.Tx) error {
//				panic("mock out the InsertTaskExec method")
//			},
//			InsertUserFunc: func(ctx context.Context, user *entity.User, tx *sql.Tx) error {
//				panic("mock out the InsertUser method")
//			},
//			InsertUserSegmentFunc: func(ctx context.Context, userSegment *entity.UserSegment, tx *sql.Tx) error {
//				panic("mock out the InsertUserSegment method")
//			},
//			InsertWorkspaceFunc: func(ctx context.Context, workspace *entity.Workspace, tx *sql.Tx) error {
//				panic("mock out the InsertWorkspace method")
//			},
//			InstallFunc: func(ctx context.Context, rootAccount *entity.Account, defaultOrganization *entity.Organization) error {
//				panic("mock out the Install method")
//			},
//			IsAccountOfOrganizationFunc: func(ctx context.Context, accountId string, organizationId string, shouldBeOwner bool) (bool, error) {
//				panic("mock out the IsAccountOfOrganization method")
//			},
//			IsDuplicateEntryFunc: func(err error) bool {
//				panic("mock out the IsDuplicateEntry method")
//			},
//			IsExistingColumnTheSameFunc: func(ctx context.Context, workspaceID string, tableName string, column *entity.TableColumn) error {
//				panic("mock out the IsExistingColumnTheSame method")
//			},
//			IsExistingTableTheSameFunc: func(ctx context.Context, workspaceID string, table *entity.AppTableManifest) error {
//				panic("mock out the IsExistingTableTheSame method")
//			},
//			ListAccountsForOrganizationFunc: func(ctx context.Context, organizationID string) ([]*entity.AccountWithOrganizationRole, error) {
//				panic("mock out the ListAccountsForOrganization method")
//			},
//			ListAppsFunc: func(ctx context.Context, workspaceID string) ([]*entity.App, error) {
//				panic("mock out the ListApps method")
//			},
//			ListBroadcastCampaignsFunc: func(ctx context.Context, workspaceID string, params *dto.BroadcastCampaignListParams) ([]*entity.BroadcastCampaign, error) {
//				panic("mock out the ListBroadcastCampaigns method")
//			},
//			ListCustomEventsForUserFunc: func(ctx context.Context, workspace *entity.Workspace, userID string, orderBy string, tx *sql.Tx) ([]*entity.CustomEvent, error) {
//				panic("mock out the ListCustomEventsForUser method")
//			},
//			ListDataLogsFunc: func(ctx context.Context, workspaceID string, params *dto.DataLogListParams) ([]*entity.DataLog, string, int, error) {
//				panic("mock out the ListDataLogs method")
//			},
//			ListDataLogsToReprocessFunc: func(ctx context.Context, workspaceID string, lastID string, lastIDEventAt time.Time, limit int) ([]*entity.DataLog, error) {
//				panic("mock out the ListDataLogsToReprocess method")
//			},
//			ListDataLogsToRespawnFunc: func(ctx context.Context, workspaceID string, origin int, originID string, checkpoint int, limit int, withNextToken *string) ([]*dto.DataLogToRespawn, error) {
//				panic("mock out the ListDataLogsToRespawn method")
//			},
//			ListDevicesForUserFunc: func(ctx context.Context, workspace *entity.Workspace, userID string, orderBy string, tx *sql.Tx) ([]*entity.Device, error) {
//				panic("mock out the ListDevicesForUser method")
//			},
//			ListInvitationsForOrganizationFunc: func(ctx context.Context, organizationID string) ([]*entity.OrganizationInvitation, error) {
//				panic("mock out the ListInvitationsForOrganization method")
//			},
//			ListMessageTemplatesFunc: func(ctx context.Context, workspaceID string, params *dto.MessageTemplateListParams) ([]*entity.MessageTemplate, error) {
//				panic("mock out the ListMessageTemplates method")
//			},
//			ListOrdersForUserFunc: func(ctx context.Context, workspace *entity.Workspace, userID string, orderBy string, tx *sql.Tx) ([]*entity.Order, error) {
//				panic("mock out the ListOrdersForUser method")
//			},
//			ListOrganizationsForAccountFunc: func(ctx context.Context, accountID string) ([]*entity.Organization, error) {
//				panic("mock out the ListOrganizationsForAccount method")
//			},
//			ListPostviewsForUserFunc: func(ctx context.Context, workspace *entity.Workspace, userID string, orderBy string, tx *sql.Tx) ([]*entity.Postview, error) {
//				panic("mock out the ListPostviewsForUser method")
//			},
//			ListSegmentsFunc: func(ctx context.Context, workspaceID string, withUsersCount bool) ([]*entity.Segment, error) {
//				panic("mock out the ListSegments method")
//			},
//			ListSessionsForUserFunc: func(ctx context.Context, workspace *entity.Workspace, userID string, orderBy string, tx *sql.Tx) ([]*entity.Session, error) {
//				panic("mock out the ListSessionsForUser method")
//			},
//			ListSubscriptionListUsersFunc: func(ctx context.Context, workspaceID string, userIDs []string) ([]*entity.SubscriptionListUser, error) {
//				panic("mock out the ListSubscriptionListUsers method")
//			},
//			ListSubscriptionListsFunc: func(ctx context.Context, workspaceID string, withUsersCount bool) ([]*entity.SubscriptionList, error) {
//				panic("mock out the ListSubscriptionLists method")
//			},
//			ListTaskExecsFunc: func(ctx context.Context, workspaceID string, params *dto.TaskExecListParams) ([]*entity.TaskExec, string, string, int, error) {
//				panic("mock out the ListTaskExecs method")
//			},
//			ListTasksFunc: func(ctx context.Context, workspaceID string) ([]*entity.Task, error) {
//				panic("mock out the ListTasks method")
//			},
//			ListTasksToWakeUpFunc: func(ctx context.Context) ([]*entity.Task, error) {
//				panic("mock out the ListTasksToWakeUp method")
//			},
//			ListUserSegmentsFunc: func(ctx context.Context, workspaceID string, userIDs []string, tx *sql.Tx) ([]*entity.UserSegment, error) {
//				panic("mock out the ListUserSegments method")
//			},
//			ListUsersFunc: func(ctx context.Context, workspace *entity.Workspace, params *dto.UserListParams) ([]*entity.User, string, string, error) {
//				panic("mock out the ListUsers method")
//			},
//			ListWorkspacesFunc: func(ctx context.Context, organizationID *string) ([]*entity.Workspace, error) {
//				panic("mock out the ListWorkspaces method")
//			},
//			MatchSegmentUsersFunc: func(ctx context.Context, workspaceID string, segment *entity.Segment, userIDs []string) ([]*string, error) {
//				panic("mock out the MatchSegmentUsers method")
//			},
//			MergeUserCartItemsFunc: func(ctx context.Context, workspace *entity.Workspace, fromUserID string, toUserID string, tx *sql.Tx) error {
//				panic("mock out the MergeUserCartItems method")
//			},
//			MergeUserCartsFunc: func(ctx context.Context, workspace *entity.Workspace, fromUserID string, toUserID string, tx *sql.Tx) error {
//				panic("mock out the MergeUserCarts method")
//			},
//			MergeUserCustomEventsFunc: func(ctx context.Context, workspace *entity.Workspace, fromUserID string, toUserID string, tx *sql.Tx) error {
//				panic("mock out the MergeUserCustomEvents method")
//			},
//			MergeUserDataLogsFunc: func(ctx context.Context, workspace *entity.Workspace, fromUserID string, fromUserExternalID string, toUserID string, tx *sql.Tx) error {
//				panic("mock out the MergeUserDataLogs method")
//			},
//			MergeUserDevicesFunc: func(ctx context.Context, workspace *entity.Workspace, fromUserID string, toUserID string, tx *sql.Tx) error {
//				panic("mock out the MergeUserDevices method")
//			},
//			MergeUserOrderItemsFunc: func(ctx context.Context, workspace *entity.Workspace, fromUserID string, toUserID string, tx *sql.Tx) error {
//				panic("mock out the MergeUserOrderItems method")
//			},
//			MergeUserOrdersFunc: func(ctx context.Context, workspace *entity.Workspace, fromUserID string, toUserID string, tx *sql.Tx) error {
//				panic("mock out the MergeUserOrders method")
//			},
//			MergeUserPageviewsFunc: func(ctx context.Context, workspace *entity.Workspace, fromUserID string, toUserID string, tx *sql.Tx) error {
//				panic("mock out the MergeUserPageviews method")
//			},
//			MergeUserPostviewsFunc: func(ctx context.Context, workspace *entity.Workspace, fromUserID string, toUserID string, tx *sql.Tx) error {
//				panic("mock out the MergeUserPostviews method")
//			},
//			MergeUserSessionsFunc: func(ctx context.Context, workspace *entity.Workspace, fromUserID string, toUserID string, tx *sql.Tx) error {
//				panic("mock out the MergeUserSessions method")
//			},
//			PreviewSegmentFunc: func(ctx context.Context, workspaceID string, parentSegmentID *string, filter *entity.SegmentTreeNode, timezone string) (int64, string, []interface{}, error) {
//				panic("mock out the PreviewSegment method")
//			},
//			ReleaseUsersLockFunc: func(workspaceID string, lock *entity.UsersLock) error {
//				panic("mock out the ReleaseUsersLock method")
//			},
//			ResetAccountPasswordFunc: func(ctx context.Context, accountID string, newPassword string) error {
//				panic("mock out the ResetAccountPassword method")
//			},
//			ResetPostviewsAttributedForConversionFunc: func(ctx context.Context, userID string, conversionID string, tx *sql.Tx) error {
//				panic("mock out the ResetPostviewsAttributedForConversion method")
//			},
//			ResetSessionsAttributedForConversionFunc: func(ctx context.Context, userID string, conversionID string, tx *sql.Tx) error {
//				panic("mock out the ResetSessionsAttributedForConversion method")
//			},
//			RunInTransactionForSystemFunc: func(ctx context.Context, f func(context.Context, *sql.Tx) (int, error)) (int, error) {
//				panic("mock out the RunInTransactionForSystem method")
//			},
//			RunInTransactionForWorkspaceFunc: func(ctx context.Context, workspaceID string, f func(context.Context, *sql.Tx) (int, error)) (int, error) {
//				panic("mock out the RunInTransactionForWorkspace method")
//			},
//			SetTaskExecErrorFunc: func(ctx context.Context, workspaceID string, taskExecID string, workerID int, status int, message string) error {
//				panic("mock out the SetTaskExecError method")
//			},
//			ShowTablesFunc: func(ctx context.Context, workspaceID string) ([]*entity.TableInformationSchema, error) {
//				panic("mock out the ShowTables method")
//			},
//			StopAppTasksFunc: func(ctx context.Context, workspaceID string, appID string, tx *sql.Tx) error {
//				panic("mock out the StopAppTasks method")
//			},
//			StopTaskExecsForAppFunc: func(ctx context.Context, appID string, tx *sql.Tx) error {
//				panic("mock out the StopTaskExecsForApp method")
//			},
//			TransferOrganizationOwnsershipFunc: func(ctx context.Context, accountID string, toAccountID string, organizationID string) error {
//				panic("mock out the TransferOrganizationOwnsership method")
//			},
//			UpdateAccountProfileFunc: func(ctx context.Context, account *entity.Account) error {
//				panic("mock out the UpdateAccountProfile method")
//			},
//			UpdateAccountSessionLastAccessFunc: func(ctx context.Context, accountID string, accountSessionID string, now time.Time) error {
//				panic("mock out the UpdateAccountSessionLastAccess method")
//			},
//			UpdateAppFunc: func(ctx context.Context, app *entity.App, tx *sql.Tx) error {
//				panic("mock out the UpdateApp method")
//			},
//			UpdateAppItemFunc: func(ctx context.Context, kind string, upsertedAppItem *entity.AppItem, tx *sql.Tx) error {
//				panic("mock out the UpdateAppItem method")
//			},
//			UpdateBroadcastCampaignFunc: func(ctx context.Context, workspaceID string, campaign *entity.BroadcastCampaign, tx *sql.Tx) error {
//				panic("mock out the UpdateBroadcastCampaign method")
//			},
//			UpdateCartFunc: func(ctx context.Context, cart *entity.Cart, tx *sql.Tx) error {
//				panic("mock out the UpdateCart method")
//			},
//			UpdateCartItemFunc: func(ctx context.Context, cartItem *entity.CartItem, tx *sql.Tx) error {
//				panic("mock out the UpdateCartItem method")
//			},
//			UpdateChannelFunc: func(ctx context.Context, workspace *entity.Workspace, updatedChannel *entity.Channel) error {
//				panic("mock out the UpdateChannel method")
//			},
//			UpdateCustomEventFunc: func(ctx context.Context, event *entity.CustomEvent, tx *sql.Tx) error {
//				panic("mock out the UpdateCustomEvent method")
//			},
//			UpdateDataLogFunc: func(ctx context.Context, workspaceID string, dataLog *entity.DataLog) error {
//				panic("mock out the UpdateDataLog method")
//			},
//			UpdateDeviceFunc: func(ctx context.Context, device *entity.Device, tx *sql.Tx) error {
//				panic("mock out the UpdateDevice method")
//			},
//			UpdateMessageFunc: func(ctx context.Context, message *entity.Message, tx *sql.Tx) error {
//				panic("mock out the UpdateMessage method")
//			},
//			UpdateOrderFunc: func(ctx context.Context, order *entity.Order, tx *sql.Tx) error {
//				panic("mock out the UpdateOrder method")
//			},
//			UpdateOrderAttributionFunc: func(ctx context.Context, order *entity.Order, tx *sql.Tx) error {
//				panic("mock out the UpdateOrderAttribution method")
//			},
//			UpdateOrderItemFunc: func(ctx context.Context, orderItem *entity.OrderItem, tx *sql.Tx) error {
//				panic("mock out the UpdateOrderItem method")
//			},
//			UpdateOrganizationProfileFunc: func(ctx context.Context, organization *entity.Organization) error {
//				panic("mock out the UpdateOrganizationProfile method")
//			},
//			UpdatePageviewFunc: func(ctx context.Context, pageview *entity.Pageview, tx *sql.Tx) error {
//				panic("mock out the UpdatePageview method")
//			},
//			UpdatePostviewFunc: func(ctx context.Context, postview *entity.Postview, tx *sql.Tx) error {
//				panic("mock out the UpdatePostview method")
//			},
//			UpdateSegmentFunc: func(ctx context.Context, segment *entity.Segment, tx *sql.Tx) error {
//				panic("mock out the UpdateSegment method")
//			},
//			UpdateSessionFunc: func(ctx context.Context, session *entity.Session, tx *sql.Tx) error {
//				panic("mock out the UpdateSession method")
//			},
//			UpdateSubscriptionListUserFunc: func(ctx context.Context, subscription *entity.SubscriptionListUser, tx *sql.Tx) error {
//				panic("mock out the UpdateSubscriptionListUser method")
//			},
//			UpdateTaskFunc: func(ctx context.Context, task *entity.Task, tx *sql.Tx) error {
//				panic("mock out the UpdateTask method")
//			},
//			UpdateTaskExecFromResultFunc: func(ctx context.Context, taskExecRequestPayload *dto.TaskExecRequestPayload, taskExecResult *entity.TaskExecResult, tx *sql.Tx) error {
//				panic("mock out the UpdateTaskExecFromResult method")
//			},
//			UpdateUserFunc: func(ctx context.Context, user *entity.User, tx *sql.Tx) error {
//				panic("mock out the UpdateUser method")
//			},
//			UpdateWorkspaceFunc: func(ctx context.Context, workspace *entity.Workspace, tx *sql.Tx) error {
//				panic("mock out the UpdateWorkspace method")
//			},
//			UpsertOrganizationInvitationFunc: func(ctx context.Context, accountInvitation *entity.OrganizationInvitation) error {
//				panic("mock out the UpsertOrganizationInvitation method")
//			},
//			UseWorkspaceDBWithTxFunc: func(ctx context.Context, workspaceID string, tx *sql.Tx) error {
//				panic("mock out the UseWorkspaceDBWithTx method")
//			},
//		}
//
//		// use mockedRepository in code that requires Repository
//		// and then make assertions.
//
//	}
type RepositoryMock struct {
	// AbortTaskExecFunc mocks the AbortTaskExec method.
	AbortTaskExecFunc func(ctx context.Context, taskID string, message string, tx *sql.Tx) error

	// AccountLogoutFunc mocks the AccountLogout method.
	AccountLogoutFunc func(ctx context.Context, accountID string, sessionID string) error

	// ActivateAppTasksFunc mocks the ActivateAppTasks method.
	ActivateAppTasksFunc func(ctx context.Context, workspaceID string, appID string, tx *sql.Tx) error

	// ActivateSegmentFunc mocks the ActivateSegment method.
	ActivateSegmentFunc func(ctx context.Context, workspaceID string, segmentID string, segmentVersion int) (bool, error)

	// AddAccountToOrganizationFunc mocks the AddAccountToOrganization method.
	AddAccountToOrganizationFunc func(ctx context.Context, accountID string, organizationID string, isOwner bool, fromAccountID *string, workspaceScopes entity.WorkspacesScopes, tx *sql.Tx) error

	// AddColumnFunc mocks the AddColumn method.
	AddColumnFunc func(ctx context.Context, workspace *entity.Workspace, tableName string, column *entity.TableColumn) error

	// AddJobToTaskExecFunc mocks the AddJobToTaskExec method.
	AddJobToTaskExecFunc func(ctxWithTimeout context.Context, taskExecID string, newJobID string, tx *sql.Tx) error

	// AddTaskExecWorkerFunc mocks the AddTaskExecWorker method.
	AddTaskExecWorkerFunc func(ctx context.Context, taskID string, newJobID string, workerID int, initialWorkerState entity.TaskWorkerState, tx *sql.Tx) error

	// CancelOrganizationInvitationFunc mocks the CancelOrganizationInvitation method.
	CancelOrganizationInvitationFunc func(ctx context.Context, organizationID string, email string) error

	// CleanAfterUserAliasFunc mocks the CleanAfterUserAlias method.
	CleanAfterUserAliasFunc func(workspaceID string, fromUserExternalID string) error

	// ClearUserSegmentQueueFunc mocks the ClearUserSegmentQueue method.
	ClearUserSegmentQueueFunc func(ctx context.Context, workspaceID string, segmentID string, segmentVersion int) error

	// ConsumeInvitationFunc mocks the ConsumeInvitation method.
	ConsumeInvitationFunc func(ctx context.Context, accountID string, insertAccount *entity.Account, invitation *entity.OrganizationInvitation) error

	// CountSuccessfulDataLogsForDemoFunc mocks the CountSuccessfulDataLogsForDemo method.
	CountSuccessfulDataLogsForDemoFunc func(ctx context.Context, workspaceID string) (int64, error)

	// CreateChannelFunc mocks the CreateChannel method.
	CreateChannelFunc func(ctx context.Context, workspace *entity.Workspace, channel *entity.Channel) error

	// CreateOrganizationFunc mocks the CreateOrganization method.
	CreateOrganizationFunc func(ctx context.Context, organization *entity.Organization, tx *sql.Tx) error

	// CreateSubscriptionListFunc mocks the CreateSubscriptionList method.
	CreateSubscriptionListFunc func(ctx context.Context, workspaceID string, list *entity.SubscriptionList) error

	// CreateTableFunc mocks the CreateTable method.
	CreateTableFunc func(ctx context.Context, workspace *entity.Workspace, table *entity.AppTableManifest) error

	// CreateUserAliasFunc mocks the CreateUserAlias method.
	CreateUserAliasFunc func(ctx context.Context, fromUserExternalID string, toUserExternalID string, toUserIsAuthenticated bool, tx *sql.Tx) error

	// CreateWorkspaceTablesFunc mocks the CreateWorkspaceTables method.
	CreateWorkspaceTablesFunc func(ctx context.Context, workspaceID string, tx *sql.Tx) error

	// DeactivateOrganizationAccountFunc mocks the DeactivateOrganizationAccount method.
	DeactivateOrganizationAccountFunc func(ctx context.Context, accountID string, deactivateAccountID string, organizationID string) error

	// DeleteAppFunc mocks the DeleteApp method.
	DeleteAppFunc func(ctx context.Context, appID string, tx *sql.Tx) error

	// DeleteAppItemByExternalIDFunc mocks the DeleteAppItemByExternalID method.
	DeleteAppItemByExternalIDFunc func(ctx context.Context, workspace *entity.Workspace, kind string, externalID string, tx *sql.Tx) error

	// DeleteAppItemByIDFunc mocks the DeleteAppItemByID method.
	DeleteAppItemByIDFunc func(ctx context.Context, workspace *entity.Workspace, kind string, ID string, tx *sql.Tx) error

	// DeleteAppTasksFunc mocks the DeleteAppTasks method.
	DeleteAppTasksFunc func(ctx context.Context, workspaceID string, appID string, tx *sql.Tx) error

	// DeleteCartItemFunc mocks the DeleteCartItem method.
	DeleteCartItemFunc func(ctx context.Context, cartItemID string, userID string, tx *sql.Tx) error

	// DeleteChannelFunc mocks the DeleteChannel method.
	DeleteChannelFunc func(ctx context.Context, workspace *entity.Workspace, deletedChannelID string) error

	// DeleteColumnFunc mocks the DeleteColumn method.
	DeleteColumnFunc func(ctx context.Context, workspace *entity.Workspace, tableName string, column *entity.TableColumn) error

	// DeleteDomainFunc mocks the DeleteDomain method.
	DeleteDomainFunc func(ctx context.Context, workspace *entity.Workspace, deletedDomainID string, migrateToDomainID string) error

	// DeleteOrderItemFunc mocks the DeleteOrderItem method.
	DeleteOrderItemFunc func(ctx context.Context, orderItemID string, userID string, tx *sql.Tx) error

	// DeleteSegmentFunc mocks the DeleteSegment method.
	DeleteSegmentFunc func(ctx context.Context, workspaceID string, segmentID string) error

	// DeleteTableFunc mocks the DeleteTable method.
	DeleteTableFunc func(ctx context.Context, workspaceID string, tableName string) error

	// DeleteUserSegmentFunc mocks the DeleteUserSegment method.
	DeleteUserSegmentFunc func(ctx context.Context, userID string, segmentID string, tx *sql.Tx) error

	// DeleteUserSegmentQueueRowFunc mocks the DeleteUserSegmentQueueRow method.
	DeleteUserSegmentQueueRowFunc func(ctx context.Context, workspaceID string, segmentID string, segmentVersion int, userID string, tx *sql.Tx) error

	// DeleteWorkspaceFunc mocks the DeleteWorkspace method.
	DeleteWorkspaceFunc func(ctx context.Context, workspaceID string) error

	// DevResetDBFunc mocks the DevResetDB method.
	DevResetDBFunc func(ctx context.Context, rootAccount *entity.Account, defaultOrganization *entity.Organization) error

	// EnqueueMatchingSegmentUsersFunc mocks the EnqueueMatchingSegmentUsers method.
	EnqueueMatchingSegmentUsersFunc func(ctx context.Context, workspaceID string, segment *entity.Segment) (int, int, error)

	// EnsureUsersLockFunc mocks the EnsureUsersLock method.
	EnsureUsersLockFunc func(ctx context.Context, workspaceID string, lock *entity.UsersLock, withRetry bool) error

	// EnterUserSegmentFromQueueFunc mocks the EnterUserSegmentFromQueue method.
	EnterUserSegmentFromQueueFunc func(ctx context.Context, workspaceID string, segmentID string, segmentVersion int) error

	// ExitUserSegmentFromQueueFunc mocks the ExitUserSegmentFromQueue method.
	ExitUserSegmentFromQueueFunc func(ctx context.Context, workspaceID string, segmentID string, segmentVersion int) error

	// FetchAppItemsFunc mocks the FetchAppItems method.
	FetchAppItemsFunc func(ctx context.Context, workspace *entity.Workspace, kind string, query sq.SelectBuilder, tx *sql.Tx) ([]*entity.AppItem, error)

	// FetchCustomEventsFunc mocks the FetchCustomEvents method.
	FetchCustomEventsFunc func(ctx context.Context, workspace *entity.Workspace, query sq.SelectBuilder, tx *sql.Tx) ([]*entity.CustomEvent, error)

	// FetchDevicesFunc mocks the FetchDevices method.
	FetchDevicesFunc func(ctx context.Context, workspace *entity.Workspace, query sq.SelectBuilder, tx *sql.Tx) ([]*entity.Device, error)

	// FetchSessionsFunc mocks the FetchSessions method.
	FetchSessionsFunc func(ctx context.Context, workspace *entity.Workspace, query sq.SelectBuilder, tx *sql.Tx) ([]*entity.Session, error)

	// FindAppItemByExternalIDFunc mocks the FindAppItemByExternalID method.
	FindAppItemByExternalIDFunc func(ctx context.Context, workspace *entity.Workspace, kind string, externalID string, tx *sql.Tx) (*entity.AppItem, error)

	// FindAppItemByIDFunc mocks the FindAppItemByID method.
	FindAppItemByIDFunc func(ctx context.Context, workspace *entity.Workspace, kind string, id string, tx *sql.Tx) (*entity.AppItem, error)

	// FindCartByIDFunc mocks the FindCartByID method.
	FindCartByIDFunc func(ctx context.Context, workspaceID string, cartID string, userID string, tx *sql.Tx) (*entity.Cart, error)

	// FindCartItemsByCartIDFunc mocks the FindCartItemsByCartID method.
	FindCartItemsByCartIDFunc func(ctx context.Context, workspaceID string, cartID string, userID string, tx *sql.Tx) ([]*entity.CartItem, error)

	// FindCustomEventByIDFunc mocks the FindCustomEventByID method.
	FindCustomEventByIDFunc func(ctx context.Context, workspace *entity.Workspace, eventID string, userID string, tx *sql.Tx) (*entity.CustomEvent, error)

	// FindDeviceByIDFunc mocks the FindDeviceByID method.
	FindDeviceByIDFunc func(ctx context.Context, workspace *entity.Workspace, deviceID string, userID string, tx *sql.Tx) (*entity.Device, error)

	// FindEventualUsersToMergeWithFunc mocks the FindEventualUsersToMergeWith method.
	FindEventualUsersToMergeWithFunc func(ctx context.Context, workspace *entity.Workspace, withUser *entity.User, withReconciliationKeys entity.MapOfInterfaces, tx *sql.Tx) ([]*entity.User, error)

	// FindMessageByIDFunc mocks the FindMessageByID method.
	FindMessageByIDFunc func(ctx context.Context, workspace *entity.Workspace, id string, userID string, tx *sql.Tx) (*entity.Message, error)

	// FindOrderByIDFunc mocks the FindOrderByID method.
	FindOrderByIDFunc func(ctx context.Context, workspace *entity.Workspace, orderID string, userID string, tx *sql.Tx) (*entity.Order, error)

	// FindOrderItemsByOrderIDFunc mocks the FindOrderItemsByOrderID method.
	FindOrderItemsByOrderIDFunc func(ctx context.Context, workspaceID string, orderID string, userID string, tx *sql.Tx) ([]*entity.OrderItem, error)

	// FindPageviewByIDFunc mocks the FindPageviewByID method.
	FindPageviewByIDFunc func(ctx context.Context, workspace *entity.Workspace, pageviewID string, userID string, tx *sql.Tx) (*entity.Pageview, error)

	// FindPostviewByIDFunc mocks the FindPostviewByID method.
	FindPostviewByIDFunc func(ctx context.Context, workspaceID *entity.Workspace, postviewID string, userID string, tx *sql.Tx) (*entity.Postview, error)

	// FindSessionByIDFunc mocks the FindSessionByID method.
	FindSessionByIDFunc func(ctx context.Context, workspace *entity.Workspace, sessionID string, userID string, tx *sql.Tx) (*entity.Session, error)

	// FindSubscriptionListUserFunc mocks the FindSubscriptionListUser method.
	FindSubscriptionListUserFunc func(ctx context.Context, listID string, userID string, tx *sql.Tx) (*entity.SubscriptionListUser, error)

	// FindUserAliasFunc mocks the FindUserAlias method.
	FindUserAliasFunc func(ctx context.Context, fromUserExternalID string, tx *sql.Tx) (*entity.UserAlias, error)

	// FindUserByIDFunc mocks the FindUserByID method.
	FindUserByIDFunc func(ctx context.Context, workspace *entity.Workspace, userID string, tx *sql.Tx, userWith *dto.UserWith) (*entity.User, error)

	// FindUserIDsWithOrdersToReattributeFunc mocks the FindUserIDsWithOrdersToReattribute method.
	FindUserIDsWithOrdersToReattributeFunc func(ctx context.Context, workspaceID string, limit int) ([]string, error)

	// FindUsersAliasedFunc mocks the FindUsersAliased method.
	FindUsersAliasedFunc func(ctx context.Context, workspaceID string, toUserExternalID string) ([]*entity.UserAlias, error)

	// GetAccountFromEmailFunc mocks the GetAccountFromEmail method.
	GetAccountFromEmailFunc func(ctx context.Context, email string) (*entity.Account, error)

	// GetAccountFromIDFunc mocks the GetAccountFromID method.
	GetAccountFromIDFunc func(ctx context.Context, accountID string) (*entity.Account, error)

	// GetAppFunc mocks the GetApp method.
	GetAppFunc func(ctx context.Context, workspaceID string, appID string) (*entity.App, error)

	// GetBroadcastCampaignFunc mocks the GetBroadcastCampaign method.
	GetBroadcastCampaignFunc func(ctx context.Context, workspaceID string, campaignID string) (*entity.BroadcastCampaign, error)

	// GetDataLogFunc mocks the GetDataLog method.
	GetDataLogFunc func(ctx context.Context, workspaceID string, dataLogID string) (*entity.DataLog, error)

	// GetDataLogChildrenFunc mocks the GetDataLogChildren method.
	GetDataLogChildrenFunc func(ctx context.Context, workspaceID string, dataLogID string) ([]*entity.DataLog, error)

	// GetInvitationFunc mocks the GetInvitation method.
	GetInvitationFunc func(ctx context.Context, email string, organizationID string) (*entity.OrganizationInvitation, error)

	// GetMessageTemplateFunc mocks the GetMessageTemplate method.
	GetMessageTemplateFunc func(ctx context.Context, workspaceID string, id string, version *int64, tx *sql.Tx) (*entity.MessageTemplate, error)

	// GetOrganizationFunc mocks the GetOrganization method.
	GetOrganizationFunc func(ctx context.Context, organizationID string) (*entity.Organization, error)

	// GetRunningTaskExecByTaskIDFunc mocks the GetRunningTaskExecByTaskID method.
	GetRunningTaskExecByTaskIDFunc func(ctx context.Context, taskID string, multipleExecKey *string, tx *sql.Tx) (*entity.TaskExec, error)

	// GetSegmentFunc mocks the GetSegment method.
	GetSegmentFunc func(ctx context.Context, workspaceID string, segmentID string) (*entity.Segment, error)

	// GetSettingsFunc mocks the GetSettings method.
	GetSettingsFunc func(ctx context.Context) (*entity.Settings, error)

	// GetSubscriptionListFunc mocks the GetSubscriptionList method.
	GetSubscriptionListFunc func(ctx context.Context, workspaceID string, listID string, tx *sql.Tx) (*entity.SubscriptionList, error)

	// GetSubscriptionListUsersToMessageFunc mocks the GetSubscriptionListUsersToMessage method.
	GetSubscriptionListUsersToMessageFunc func(ctx context.Context, workspaceID string, listIDs []string, offset int64, limit int64) ([]*entity.SubscriptionListUser, error)

	// GetSystemConnectionFunc mocks the GetSystemConnection method.
	GetSystemConnectionFunc func(ctx context.Context) (*sql.Conn, error)

	// GetTaskFunc mocks the GetTask method.
	GetTaskFunc func(ctx context.Context, workspaceID string, taskID string, tx *sql.Tx) (*entity.Task, error)

	// GetTaskExecFunc mocks the GetTaskExec method.
	GetTaskExecFunc func(ctx context.Context, workspaceID string, taskID string) (*entity.TaskExec, error)

	// GetTaskExecJobFunc mocks the GetTaskExecJob method.
	GetTaskExecJobFunc func(ctx context.Context, workspaceID string, jobID string) (*entity.TaskExecJob, error)

	// GetTaskExecJobsFunc mocks the GetTaskExecJobs method.
	GetTaskExecJobsFunc func(ctx context.Context, workspaceID string, taskExecID string, offset int, limit int) ([]*entity.TaskExecJob, int, error)

	// GetUsersNotInSubscriptionListFunc mocks the GetUsersNotInSubscriptionList method.
	GetUsersNotInSubscriptionListFunc func(ctx context.Context, workspaceID string, listID string, offset int64, limit int64, segmentID *string) ([]*dto.UserToImportToSubscriptionList, error)

	// GetWorkspaceFunc mocks the GetWorkspace method.
	GetWorkspaceFunc func(ctx context.Context, workspaceID string) (*entity.Workspace, error)

	// GetWorkspaceConnectionFunc mocks the GetWorkspaceConnection method.
	GetWorkspaceConnectionFunc func(ctx context.Context, workspaceID string) (*sql.Conn, error)

	// HasDataLogsToReprocessFunc mocks the HasDataLogsToReprocess method.
	HasDataLogsToReprocessFunc func(ctx context.Context, workspaceID string, untilDate time.Time) (bool, error)

	// InsertAccountFunc mocks the InsertAccount method.
	InsertAccountFunc func(ctx context.Context, account *entity.Account, organizationID string, fromAccountID string, tx *sql.Tx) error

	// InsertAccountSessionFunc mocks the InsertAccountSession method.
	InsertAccountSessionFunc func(ctx context.Context, accountSession *entity.AccountSession) error

	// InsertAppFunc mocks the InsertApp method.
	InsertAppFunc func(ctx context.Context, app *entity.App, tx *sql.Tx) error

	// InsertAppItemFunc mocks the InsertAppItem method.
	InsertAppItemFunc func(ctx context.Context, kind string, upsertedAppItem *entity.AppItem, tx *sql.Tx) error

	// InsertBroadcastCampaignFunc mocks the InsertBroadcastCampaign method.
	InsertBroadcastCampaignFunc func(ctx context.Context, workspaceID string, campaign *entity.BroadcastCampaign) error

	// InsertCartFunc mocks the InsertCart method.
	InsertCartFunc func(ctx context.Context, cart *entity.Cart, tx *sql.Tx) error

	// InsertCartItemFunc mocks the InsertCartItem method.
	InsertCartItemFunc func(ctx context.Context, cartItem *entity.CartItem, tx *sql.Tx) error

	// InsertCustomEventFunc mocks the InsertCustomEvent method.
	InsertCustomEventFunc func(ctx context.Context, event *entity.CustomEvent, tx *sql.Tx) error

	// InsertDataLogFunc mocks the InsertDataLog method.
	InsertDataLogFunc func(ctx context.Context, workspaceID string, dataLog *entity.DataLog, tx *sql.Tx) error

	// InsertDeviceFunc mocks the InsertDevice method.
	InsertDeviceFunc func(ctx context.Context, device *entity.Device, tx *sql.Tx) error

	// InsertMessageFunc mocks the InsertMessage method.
	InsertMessageFunc func(ctx context.Context, message *entity.Message, tx *sql.Tx) error

	// InsertMessageTemplateFunc mocks the InsertMessageTemplate method.
	InsertMessageTemplateFunc func(ctx context.Context, workspaceID string, template *entity.MessageTemplate, tx *sql.Tx) error

	// InsertOrderFunc mocks the InsertOrder method.
	InsertOrderFunc func(ctx context.Context, order *entity.Order, tx *sql.Tx) error

	// InsertOrderItemFunc mocks the InsertOrderItem method.
	InsertOrderItemFunc func(ctx context.Context, orderItem *entity.OrderItem, tx *sql.Tx) error

	// InsertPageviewFunc mocks the InsertPageview method.
	InsertPageviewFunc func(ctx context.Context, pageview *entity.Pageview, tx *sql.Tx) error

	// InsertPostviewFunc mocks the InsertPostview method.
	InsertPostviewFunc func(ctx context.Context, postview *entity.Postview, tx *sql.Tx) error

	// InsertSegmentFunc mocks the InsertSegment method.
	InsertSegmentFunc func(ctx context.Context, segment *entity.Segment, tx *sql.Tx) error

	// InsertSegmentDataLogsFunc mocks the InsertSegmentDataLogs method.
	InsertSegmentDataLogsFunc func(ctx context.Context, workspaceID string, segmentID string, segmentVersion int, taskID string, isEnter bool, createdAt time.Time, checkpoint int) error

	// InsertServiceAccountFunc mocks the InsertServiceAccount method.
	InsertServiceAccountFunc func(ctx context.Context, account *entity.Account, organizationID string, fromAccountID string, workspaceScopes entity.WorkspacesScopes) error

	// InsertSessionFunc mocks the InsertSession method.
	InsertSessionFunc func(ctx context.Context, session *entity.Session, tx *sql.Tx) error

	// InsertSubscriptionListUserFunc mocks the InsertSubscriptionListUser method.
	InsertSubscriptionListUserFunc func(ctx context.Context, subscription *entity.SubscriptionListUser, tx *sql.Tx) error

	// InsertTaskFunc mocks the InsertTask method.
	InsertTaskFunc func(ctx context.Context, task *entity.Task, tx *sql.Tx) error

	// InsertTaskExecFunc mocks the InsertTaskExec method.
	InsertTaskExecFunc func(ctx context.Context, workspaceID string, task *entity.TaskExec, job *entity.TaskExecJob, tx *sql.Tx) error

	// InsertUserFunc mocks the InsertUser method.
	InsertUserFunc func(ctx context.Context, user *entity.User, tx *sql.Tx) error

	// InsertUserSegmentFunc mocks the InsertUserSegment method.
	InsertUserSegmentFunc func(ctx context.Context, userSegment *entity.UserSegment, tx *sql.Tx) error

	// InsertWorkspaceFunc mocks the InsertWorkspace method.
	InsertWorkspaceFunc func(ctx context.Context, workspace *entity.Workspace, tx *sql.Tx) error

	// InstallFunc mocks the Install method.
	InstallFunc func(ctx context.Context, rootAccount *entity.Account, defaultOrganization *entity.Organization) error

	// IsAccountOfOrganizationFunc mocks the IsAccountOfOrganization method.
	IsAccountOfOrganizationFunc func(ctx context.Context, accountId string, organizationId string, shouldBeOwner bool) (bool, error)

	// IsDuplicateEntryFunc mocks the IsDuplicateEntry method.
	IsDuplicateEntryFunc func(err error) bool

	// IsExistingColumnTheSameFunc mocks the IsExistingColumnTheSame method.
	IsExistingColumnTheSameFunc func(ctx context.Context, workspaceID string, tableName string, column *entity.TableColumn) error

	// IsExistingTableTheSameFunc mocks the IsExistingTableTheSame method.
	IsExistingTableTheSameFunc func(ctx context.Context, workspaceID string, table *entity.AppTableManifest) error

	// ListAccountsForOrganizationFunc mocks the ListAccountsForOrganization method.
	ListAccountsForOrganizationFunc func(ctx context.Context, organizationID string) ([]*entity.AccountWithOrganizationRole, error)

	// ListAppsFunc mocks the ListApps method.
	ListAppsFunc func(ctx context.Context, workspaceID string) ([]*entity.App, error)

	// ListBroadcastCampaignsFunc mocks the ListBroadcastCampaigns method.
	ListBroadcastCampaignsFunc func(ctx context.Context, workspaceID string, params *dto.BroadcastCampaignListParams) ([]*entity.BroadcastCampaign, error)

	// ListCustomEventsForUserFunc mocks the ListCustomEventsForUser method.
	ListCustomEventsForUserFunc func(ctx context.Context, workspace *entity.Workspace, userID string, orderBy string, tx *sql.Tx) ([]*entity.CustomEvent, error)

	// ListDataLogsFunc mocks the ListDataLogs method.
	ListDataLogsFunc func(ctx context.Context, workspaceID string, params *dto.DataLogListParams) ([]*entity.DataLog, string, int, error)

	// ListDataLogsToReprocessFunc mocks the ListDataLogsToReprocess method.
	ListDataLogsToReprocessFunc func(ctx context.Context, workspaceID string, lastID string, lastIDEventAt time.Time, limit int) ([]*entity.DataLog, error)

	// ListDataLogsToRespawnFunc mocks the ListDataLogsToRespawn method.
	ListDataLogsToRespawnFunc func(ctx context.Context, workspaceID string, origin int, originID string, checkpoint int, limit int, withNextToken *string) ([]*dto.DataLogToRespawn, error)

	// ListDevicesForUserFunc mocks the ListDevicesForUser method.
	ListDevicesForUserFunc func(ctx context.Context, workspace *entity.Workspace, userID string, orderBy string, tx *sql.Tx) ([]*entity.Device, error)

	// ListInvitationsForOrganizationFunc mocks the ListInvitationsForOrganization method.
	ListInvitationsForOrganizationFunc func(ctx context.Context, organizationID string) ([]*entity.OrganizationInvitation, error)

	// ListMessageTemplatesFunc mocks the ListMessageTemplates method.
	ListMessageTemplatesFunc func(ctx context.Context, workspaceID string, params *dto.MessageTemplateListParams) ([]*entity.MessageTemplate, error)

	// ListOrdersForUserFunc mocks the ListOrdersForUser method.
	ListOrdersForUserFunc func(ctx context.Context, workspace *entity.Workspace, userID string, orderBy string, tx *sql.Tx) ([]*entity.Order, error)

	// ListOrganizationsForAccountFunc mocks the ListOrganizationsForAccount method.
	ListOrganizationsForAccountFunc func(ctx context.Context, accountID string) ([]*entity.Organization, error)

	// ListPostviewsForUserFunc mocks the ListPostviewsForUser method.
	ListPostviewsForUserFunc func(ctx context.Context, workspace *entity.Workspace, userID string, orderBy string, tx *sql.Tx) ([]*entity.Postview, error)

	// ListSegmentsFunc mocks the ListSegments method.
	ListSegmentsFunc func(ctx context.Context, workspaceID string, withUsersCount bool) ([]*entity.Segment, error)

	// ListSessionsForUserFunc mocks the ListSessionsForUser method.
	ListSessionsForUserFunc func(ctx context.Context, workspace *entity.Workspace, userID string, orderBy string, tx *sql.Tx) ([]*entity.Session, error)

	// ListSubscriptionListUsersFunc mocks the ListSubscriptionListUsers method.
	ListSubscriptionListUsersFunc func(ctx context.Context, workspaceID string, userIDs []string) ([]*entity.SubscriptionListUser, error)

	// ListSubscriptionListsFunc mocks the ListSubscriptionLists method.
	ListSubscriptionListsFunc func(ctx context.Context, workspaceID string, withUsersCount bool) ([]*entity.SubscriptionList, error)

	// ListTaskExecsFunc mocks the ListTaskExecs method.
	ListTaskExecsFunc func(ctx context.Context, workspaceID string, params *dto.TaskExecListParams) ([]*entity.TaskExec, string, string, int, error)

	// ListTasksFunc mocks the ListTasks method.
	ListTasksFunc func(ctx context.Context, workspaceID string) ([]*entity.Task, error)

	// ListTasksToWakeUpFunc mocks the ListTasksToWakeUp method.
	ListTasksToWakeUpFunc func(ctx context.Context) ([]*entity.Task, error)

	// ListUserSegmentsFunc mocks the ListUserSegments method.
	ListUserSegmentsFunc func(ctx context.Context, workspaceID string, userIDs []string, tx *sql.Tx) ([]*entity.UserSegment, error)

	// ListUsersFunc mocks the ListUsers method.
	ListUsersFunc func(ctx context.Context, workspace *entity.Workspace, params *dto.UserListParams) ([]*entity.User, string, string, error)

	// ListWorkspacesFunc mocks the ListWorkspaces method.
	ListWorkspacesFunc func(ctx context.Context, organizationID *string) ([]*entity.Workspace, error)

	// MatchSegmentUsersFunc mocks the MatchSegmentUsers method.
	MatchSegmentUsersFunc func(ctx context.Context, workspaceID string, segment *entity.Segment, userIDs []string) ([]*string, error)

	// MergeUserCartItemsFunc mocks the MergeUserCartItems method.
	MergeUserCartItemsFunc func(ctx context.Context, workspace *entity.Workspace, fromUserID string, toUserID string, tx *sql.Tx) error

	// MergeUserCartsFunc mocks the MergeUserCarts method.
	MergeUserCartsFunc func(ctx context.Context, workspace *entity.Workspace, fromUserID string, toUserID string, tx *sql.Tx) error

	// MergeUserCustomEventsFunc mocks the MergeUserCustomEvents method.
	MergeUserCustomEventsFunc func(ctx context.Context, workspace *entity.Workspace, fromUserID string, toUserID string, tx *sql.Tx) error

	// MergeUserDataLogsFunc mocks the MergeUserDataLogs method.
	MergeUserDataLogsFunc func(ctx context.Context, workspace *entity.Workspace, fromUserID string, fromUserExternalID string, toUserID string, tx *sql.Tx) error

	// MergeUserDevicesFunc mocks the MergeUserDevices method.
	MergeUserDevicesFunc func(ctx context.Context, workspace *entity.Workspace, fromUserID string, toUserID string, tx *sql.Tx) error

	// MergeUserOrderItemsFunc mocks the MergeUserOrderItems method.
	MergeUserOrderItemsFunc func(ctx context.Context, workspace *entity.Workspace, fromUserID string, toUserID string, tx *sql.Tx) error

	// MergeUserOrdersFunc mocks the MergeUserOrders method.
	MergeUserOrdersFunc func(ctx context.Context, workspace *entity.Workspace, fromUserID string, toUserID string, tx *sql.Tx) error

	// MergeUserPageviewsFunc mocks the MergeUserPageviews method.
	MergeUserPageviewsFunc func(ctx context.Context, workspace *entity.Workspace, fromUserID string, toUserID string, tx *sql.Tx) error

	// MergeUserPostviewsFunc mocks the MergeUserPostviews method.
	MergeUserPostviewsFunc func(ctx context.Context, workspace *entity.Workspace, fromUserID string, toUserID string, tx *sql.Tx) error

	// MergeUserSessionsFunc mocks the MergeUserSessions method.
	MergeUserSessionsFunc func(ctx context.Context, workspace *entity.Workspace, fromUserID string, toUserID string, tx *sql.Tx) error

	// PreviewSegmentFunc mocks the PreviewSegment method.
	PreviewSegmentFunc func(ctx context.Context, workspaceID string, parentSegmentID *string, filter *entity.SegmentTreeNode, timezone string) (int64, string, []interface{}, error)

	// ReleaseUsersLockFunc mocks the ReleaseUsersLock method.
	ReleaseUsersLockFunc func(workspaceID string, lock *entity.UsersLock) error

	// ResetAccountPasswordFunc mocks the ResetAccountPassword method.
	ResetAccountPasswordFunc func(ctx context.Context, accountID string, newPassword string) error

	// ResetPostviewsAttributedForConversionFunc mocks the ResetPostviewsAttributedForConversion method.
	ResetPostviewsAttributedForConversionFunc func(ctx context.Context, userID string, conversionID string, tx *sql.Tx) error

	// ResetSessionsAttributedForConversionFunc mocks the ResetSessionsAttributedForConversion method.
	ResetSessionsAttributedForConversionFunc func(ctx context.Context, userID string, conversionID string, tx *sql.Tx) error

	// RunInTransactionForSystemFunc mocks the RunInTransactionForSystem method.
	RunInTransactionForSystemFunc func(ctx context.Context, f func(context.Context, *sql.Tx) (int, error)) (int, error)

	// RunInTransactionForWorkspaceFunc mocks the RunInTransactionForWorkspace method.
	RunInTransactionForWorkspaceFunc func(ctx context.Context, workspaceID string, f func(context.Context, *sql.Tx) (int, error)) (int, error)

	// SetTaskExecErrorFunc mocks the SetTaskExecError method.
	SetTaskExecErrorFunc func(ctx context.Context, workspaceID string, taskExecID string, workerID int, status int, message string) error

	// ShowTablesFunc mocks the ShowTables method.
	ShowTablesFunc func(ctx context.Context, workspaceID string) ([]*entity.TableInformationSchema, error)

	// StopAppTasksFunc mocks the StopAppTasks method.
	StopAppTasksFunc func(ctx context.Context, workspaceID string, appID string, tx *sql.Tx) error

	// StopTaskExecsForAppFunc mocks the StopTaskExecsForApp method.
	StopTaskExecsForAppFunc func(ctx context.Context, appID string, tx *sql.Tx) error

	// TransferOrganizationOwnsershipFunc mocks the TransferOrganizationOwnsership method.
	TransferOrganizationOwnsershipFunc func(ctx context.Context, accountID string, toAccountID string, organizationID string) error

	// UpdateAccountProfileFunc mocks the UpdateAccountProfile method.
	UpdateAccountProfileFunc func(ctx context.Context, account *entity.Account) error

	// UpdateAccountSessionLastAccessFunc mocks the UpdateAccountSessionLastAccess method.
	UpdateAccountSessionLastAccessFunc func(ctx context.Context, accountID string, accountSessionID string, now time.Time) error

	// UpdateAppFunc mocks the UpdateApp method.
	UpdateAppFunc func(ctx context.Context, app *entity.App, tx *sql.Tx) error

	// UpdateAppItemFunc mocks the UpdateAppItem method.
	UpdateAppItemFunc func(ctx context.Context, kind string, upsertedAppItem *entity.AppItem, tx *sql.Tx) error

	// UpdateBroadcastCampaignFunc mocks the UpdateBroadcastCampaign method.
	UpdateBroadcastCampaignFunc func(ctx context.Context, workspaceID string, campaign *entity.BroadcastCampaign, tx *sql.Tx) error

	// UpdateCartFunc mocks the UpdateCart method.
	UpdateCartFunc func(ctx context.Context, cart *entity.Cart, tx *sql.Tx) error

	// UpdateCartItemFunc mocks the UpdateCartItem method.
	UpdateCartItemFunc func(ctx context.Context, cartItem *entity.CartItem, tx *sql.Tx) error

	// UpdateChannelFunc mocks the UpdateChannel method.
	UpdateChannelFunc func(ctx context.Context, workspace *entity.Workspace, updatedChannel *entity.Channel) error

	// UpdateCustomEventFunc mocks the UpdateCustomEvent method.
	UpdateCustomEventFunc func(ctx context.Context, event *entity.CustomEvent, tx *sql.Tx) error

	// UpdateDataLogFunc mocks the UpdateDataLog method.
	UpdateDataLogFunc func(ctx context.Context, workspaceID string, dataLog *entity.DataLog) error

	// UpdateDeviceFunc mocks the UpdateDevice method.
	UpdateDeviceFunc func(ctx context.Context, device *entity.Device, tx *sql.Tx) error

	// UpdateMessageFunc mocks the UpdateMessage method.
	UpdateMessageFunc func(ctx context.Context, message *entity.Message, tx *sql.Tx) error

	// UpdateOrderFunc mocks the UpdateOrder method.
	UpdateOrderFunc func(ctx context.Context, order *entity.Order, tx *sql.Tx) error

	// UpdateOrderAttributionFunc mocks the UpdateOrderAttribution method.
	UpdateOrderAttributionFunc func(ctx context.Context, order *entity.Order, tx *sql.Tx) error

	// UpdateOrderItemFunc mocks the UpdateOrderItem method.
	UpdateOrderItemFunc func(ctx context.Context, orderItem *entity.OrderItem, tx *sql.Tx) error

	// UpdateOrganizationProfileFunc mocks the UpdateOrganizationProfile method.
	UpdateOrganizationProfileFunc func(ctx context.Context, organization *entity.Organization) error

	// UpdatePageviewFunc mocks the UpdatePageview method.
	UpdatePageviewFunc func(ctx context.Context, pageview *entity.Pageview, tx *sql.Tx) error

	// UpdatePostviewFunc mocks the UpdatePostview method.
	UpdatePostviewFunc func(ctx context.Context, postview *entity.Postview, tx *sql.Tx) error

	// UpdateSegmentFunc mocks the UpdateSegment method.
	UpdateSegmentFunc func(ctx context.Context, segment *entity.Segment, tx *sql.Tx) error

	// UpdateSessionFunc mocks the UpdateSession method.
	UpdateSessionFunc func(ctx context.Context, session *entity.Session, tx *sql.Tx) error

	// UpdateSubscriptionListUserFunc mocks the UpdateSubscriptionListUser method.
	UpdateSubscriptionListUserFunc func(ctx context.Context, subscription *entity.SubscriptionListUser, tx *sql.Tx) error

	// UpdateTaskFunc mocks the UpdateTask method.
	UpdateTaskFunc func(ctx context.Context, task *entity.Task, tx *sql.Tx) error

	// UpdateTaskExecFromResultFunc mocks the UpdateTaskExecFromResult method.
	UpdateTaskExecFromResultFunc func(ctx context.Context, taskExecRequestPayload *dto.TaskExecRequestPayload, taskExecResult *entity.TaskExecResult, tx *sql.Tx) error

	// UpdateUserFunc mocks the UpdateUser method.
	UpdateUserFunc func(ctx context.Context, user *entity.User, tx *sql.Tx) error

	// UpdateWorkspaceFunc mocks the UpdateWorkspace method.
	UpdateWorkspaceFunc func(ctx context.Context, workspace *entity.Workspace, tx *sql.Tx) error

	// UpsertOrganizationInvitationFunc mocks the UpsertOrganizationInvitation method.
	UpsertOrganizationInvitationFunc func(ctx context.Context, accountInvitation *entity.OrganizationInvitation) error

	// UseWorkspaceDBWithTxFunc mocks the UseWorkspaceDBWithTx method.
	UseWorkspaceDBWithTxFunc func(ctx context.Context, workspaceID string, tx *sql.Tx) error

	// calls tracks calls to the methods.
	calls struct {
		// AbortTaskExec holds details about calls to the AbortTaskExec method.
		AbortTaskExec []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TaskID is the taskID argument value.
			TaskID string
			// Message is the message argument value.
			Message string
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// AccountLogout holds details about calls to the AccountLogout method.
		AccountLogout []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// AccountID is the accountID argument value.
			AccountID string
			// SessionID is the sessionID argument value.
			SessionID string
		}
		// ActivateAppTasks holds details about calls to the ActivateAppTasks method.
		ActivateAppTasks []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WorkspaceID is the workspaceID argument value.
			WorkspaceID string
			// AppID is the appID argument value.
			AppID string
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// ActivateSegment holds details about calls to the ActivateSegment method.
		ActivateSegment []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WorkspaceID is the workspaceID argument value.
			WorkspaceID string
			// SegmentID is the segmentID argument value.
			SegmentID string
			// SegmentVersion is the segmentVersion argument value.
			SegmentVersion int
		}
		// AddAccountToOrganization holds details about calls to the AddAccountToOrganization method.
		AddAccountToOrganization []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// AccountID is the accountID argument value.
			AccountID string
			// OrganizationID is the organizationID argument value.
			OrganizationID string
			// IsOwner is the isOwner argument value.
			IsOwner bool
			// FromAccountID is the fromAccountID argument value.
			FromAccountID *string
			// WorkspaceScopes is the workspaceScopes argument value.
			WorkspaceScopes entity.WorkspacesScopes
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// AddColumn holds details about calls to the AddColumn method.
		AddColumn []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Workspace is the workspace argument value.
			Workspace *entity.Workspace
			// TableName is the tableName argument value.
			TableName string
			// Column is the column argument value.
			Column *entity.TableColumn
		}
		// AddJobToTaskExec holds details about calls to the AddJobToTaskExec method.
		AddJobToTaskExec []struct {
			// CtxWithTimeout is the ctxWithTimeout argument value.
			CtxWithTimeout context.Context
			// TaskExecID is the taskExecID argument value.
			TaskExecID string
			// NewJobID is the newJobID argument value.
			NewJobID string
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// AddTaskExecWorker holds details about calls to the AddTaskExecWorker method.
		AddTaskExecWorker []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TaskID is the taskID argument value.
			TaskID string
			// NewJobID is the newJobID argument value.
			NewJobID string
			// WorkerID is the workerID argument value.
			WorkerID int
			// InitialWorkerState is the initialWorkerState argument value.
			InitialWorkerState entity.TaskWorkerState
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// CancelOrganizationInvitation holds details about calls to the CancelOrganizationInvitation method.
		CancelOrganizationInvitation []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// OrganizationID is the organizationID argument value.
			OrganizationID string
			// Email is the email argument value.
			Email string
		}
		// CleanAfterUserAlias holds details about calls to the CleanAfterUserAlias method.
		CleanAfterUserAlias []struct {
			// WorkspaceID is the workspaceID argument value.
			WorkspaceID string
			// FromUserExternalID is the fromUserExternalID argument value.
			FromUserExternalID string
		}
		// ClearUserSegmentQueue holds details about calls to the ClearUserSegmentQueue method.
		ClearUserSegmentQueue []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WorkspaceID is the workspaceID argument value.
			WorkspaceID string
			// SegmentID is the segmentID argument value.
			SegmentID string
			// SegmentVersion is the segmentVersion argument value.
			SegmentVersion int
		}
		// ConsumeInvitation holds details about calls to the ConsumeInvitation method.
		ConsumeInvitation []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// AccountID is the accountID argument value.
			AccountID string
			// InsertAccount is the insertAccount argument value.
			InsertAccount *entity.Account
			// Invitation is the invitation argument value.
			Invitation *entity.OrganizationInvitation
		}
		// CountSuccessfulDataLogsForDemo holds details about calls to the CountSuccessfulDataLogsForDemo method.
		CountSuccessfulDataLogsForDemo []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WorkspaceID is the workspaceID argument value.
			WorkspaceID string
		}
		// CreateChannel holds details about calls to the CreateChannel method.
		CreateChannel []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Workspace is the workspace argument value.
			Workspace *entity.Workspace
			// Channel is the channel argument value.
			Channel *entity.Channel
		}
		// CreateOrganization holds details about calls to the CreateOrganization method.
		CreateOrganization []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Organization is the organization argument value.
			Organization *entity.Organization
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// CreateSubscriptionList holds details about calls to the CreateSubscriptionList method.
		CreateSubscriptionList []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WorkspaceID is the workspaceID argument value.
			WorkspaceID string
			// List is the list argument value.
			List *entity.SubscriptionList
		}
		// CreateTable holds details about calls to the CreateTable method.
		CreateTable []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Workspace is the workspace argument value.
			Workspace *entity.Workspace
			// Table is the table argument value.
			Table *entity.AppTableManifest
		}
		// CreateUserAlias holds details about calls to the CreateUserAlias method.
		CreateUserAlias []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// FromUserExternalID is the fromUserExternalID argument value.
			FromUserExternalID string
			// ToUserExternalID is the toUserExternalID argument value.
			ToUserExternalID string
			// ToUserIsAuthenticated is the toUserIsAuthenticated argument value.
			ToUserIsAuthenticated bool
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// CreateWorkspaceTables holds details about calls to the CreateWorkspaceTables method.
		CreateWorkspaceTables []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WorkspaceID is the workspaceID argument value.
			WorkspaceID string
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// DeactivateOrganizationAccount holds details about calls to the DeactivateOrganizationAccount method.
		DeactivateOrganizationAccount []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// AccountID is the accountID argument value.
			AccountID string
			// DeactivateAccountID is the deactivateAccountID argument value.
			DeactivateAccountID string
			// OrganizationID is the organizationID argument value.
			OrganizationID string
		}
		// DeleteApp holds details about calls to the DeleteApp method.
		DeleteApp []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// AppID is the appID argument value.
			AppID string
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// DeleteAppItemByExternalID holds details about calls to the DeleteAppItemByExternalID method.
		DeleteAppItemByExternalID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Workspace is the workspace argument value.
			Workspace *entity.Workspace
			// Kind is the kind argument value.
			Kind string
			// ExternalID is the externalID argument value.
			ExternalID string
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// DeleteAppItemByID holds details about calls to the DeleteAppItemByID method.
		DeleteAppItemByID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Workspace is the workspace argument value.
			Workspace *entity.Workspace
			// Kind is the kind argument value.
			Kind string
			// ID is the ID argument value.
			ID string
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// DeleteAppTasks holds details about calls to the DeleteAppTasks method.
		DeleteAppTasks []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WorkspaceID is the workspaceID argument value.
			WorkspaceID string
			// AppID is the appID argument value.
			AppID string
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// DeleteCartItem holds details about calls to the DeleteCartItem method.
		DeleteCartItem []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// CartItemID is the cartItemID argument value.
			CartItemID string
			// UserID is the userID argument value.
			UserID string
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// DeleteChannel holds details about calls to the DeleteChannel method.
		DeleteChannel []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Workspace is the workspace argument value.
			Workspace *entity.Workspace
			// DeletedChannelID is the deletedChannelID argument value.
			DeletedChannelID string
		}
		// DeleteColumn holds details about calls to the DeleteColumn method.
		DeleteColumn []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Workspace is the workspace argument value.
			Workspace *entity.Workspace
			// TableName is the tableName argument value.
			TableName string
			// Column is the column argument value.
			Column *entity.TableColumn
		}
		// DeleteDomain holds details about calls to the DeleteDomain method.
		DeleteDomain []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Workspace is the workspace argument value.
			Workspace *entity.Workspace
			// DeletedDomainID is the deletedDomainID argument value.
			DeletedDomainID string
			// MigrateToDomainID is the migrateToDomainID argument value.
			MigrateToDomainID string
		}
		// DeleteOrderItem holds details about calls to the DeleteOrderItem method.
		DeleteOrderItem []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// OrderItemID is the orderItemID argument value.
			OrderItemID string
			// UserID is the userID argument value.
			UserID string
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// DeleteSegment holds details about calls to the DeleteSegment method.
		DeleteSegment []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WorkspaceID is the workspaceID argument value.
			WorkspaceID string
			// SegmentID is the segmentID argument value.
			SegmentID string
		}
		// DeleteTable holds details about calls to the DeleteTable method.
		DeleteTable []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WorkspaceID is the workspaceID argument value.
			WorkspaceID string
			// TableName is the tableName argument value.
			TableName string
		}
		// DeleteUserSegment holds details about calls to the DeleteUserSegment method.
		DeleteUserSegment []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserID is the userID argument value.
			UserID string
			// SegmentID is the segmentID argument value.
			SegmentID string
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// DeleteUserSegmentQueueRow holds details about calls to the DeleteUserSegmentQueueRow method.
		DeleteUserSegmentQueueRow []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WorkspaceID is the workspaceID argument value.
			WorkspaceID string
			// SegmentID is the segmentID argument value.
			SegmentID string
			// SegmentVersion is the segmentVersion argument value.
			SegmentVersion int
			// UserID is the userID argument value.
			UserID string
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// DeleteWorkspace holds details about calls to the DeleteWorkspace method.
		DeleteWorkspace []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WorkspaceID is the workspaceID argument value.
			WorkspaceID string
		}
		// DevResetDB holds details about calls to the DevResetDB method.
		DevResetDB []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// RootAccount is the rootAccount argument value.
			RootAccount *entity.Account
			// DefaultOrganization is the defaultOrganization argument value.
			DefaultOrganization *entity.Organization
		}
		// EnqueueMatchingSegmentUsers holds details about calls to the EnqueueMatchingSegmentUsers method.
		EnqueueMatchingSegmentUsers []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WorkspaceID is the workspaceID argument value.
			WorkspaceID string
			// Segment is the segment argument value.
			Segment *entity.Segment
		}
		// EnsureUsersLock holds details about calls to the EnsureUsersLock method.
		EnsureUsersLock []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WorkspaceID is the workspaceID argument value.
			WorkspaceID string
			// Lock is the lock argument value.
			Lock *entity.UsersLock
			// WithRetry is the withRetry argument value.
			WithRetry bool
		}
		// EnterUserSegmentFromQueue holds details about calls to the EnterUserSegmentFromQueue method.
		EnterUserSegmentFromQueue []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WorkspaceID is the workspaceID argument value.
			WorkspaceID string
			// SegmentID is the segmentID argument value.
			SegmentID string
			// SegmentVersion is the segmentVersion argument value.
			SegmentVersion int
		}
		// ExitUserSegmentFromQueue holds details about calls to the ExitUserSegmentFromQueue method.
		ExitUserSegmentFromQueue []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WorkspaceID is the workspaceID argument value.
			WorkspaceID string
			// SegmentID is the segmentID argument value.
			SegmentID string
			// SegmentVersion is the segmentVersion argument value.
			SegmentVersion int
		}
		// FetchAppItems holds details about calls to the FetchAppItems method.
		FetchAppItems []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Workspace is the workspace argument value.
			Workspace *entity.Workspace
			// Kind is the kind argument value.
			Kind string
			// Query is the query argument value.
			Query sq.SelectBuilder
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// FetchCustomEvents holds details about calls to the FetchCustomEvents method.
		FetchCustomEvents []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Workspace is the workspace argument value.
			Workspace *entity.Workspace
			// Query is the query argument value.
			Query sq.SelectBuilder
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// FetchDevices holds details about calls to the FetchDevices method.
		FetchDevices []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Workspace is the workspace argument value.
			Workspace *entity.Workspace
			// Query is the query argument value.
			Query sq.SelectBuilder
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// FetchSessions holds details about calls to the FetchSessions method.
		FetchSessions []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Workspace is the workspace argument value.
			Workspace *entity.Workspace
			// Query is the query argument value.
			Query sq.SelectBuilder
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// FindAppItemByExternalID holds details about calls to the FindAppItemByExternalID method.
		FindAppItemByExternalID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Workspace is the workspace argument value.
			Workspace *entity.Workspace
			// Kind is the kind argument value.
			Kind string
			// ExternalID is the externalID argument value.
			ExternalID string
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// FindAppItemByID holds details about calls to the FindAppItemByID method.
		FindAppItemByID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Workspace is the workspace argument value.
			Workspace *entity.Workspace
			// Kind is the kind argument value.
			Kind string
			// ID is the id argument value.
			ID string
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// FindCartByID holds details about calls to the FindCartByID method.
		FindCartByID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WorkspaceID is the workspaceID argument value.
			WorkspaceID string
			// CartID is the cartID argument value.
			CartID string
			// UserID is the userID argument value.
			UserID string
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// FindCartItemsByCartID holds details about calls to the FindCartItemsByCartID method.
		FindCartItemsByCartID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WorkspaceID is the workspaceID argument value.
			WorkspaceID string
			// CartID is the cartID argument value.
			CartID string
			// UserID is the userID argument value.
			UserID string
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// FindCustomEventByID holds details about calls to the FindCustomEventByID method.
		FindCustomEventByID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Workspace is the workspace argument value.
			Workspace *entity.Workspace
			// EventID is the eventID argument value.
			EventID string
			// UserID is the userID argument value.
			UserID string
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// FindDeviceByID holds details about calls to the FindDeviceByID method.
		FindDeviceByID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Workspace is the workspace argument value.
			Workspace *entity.Workspace
			// DeviceID is the deviceID argument value.
			DeviceID string
			// UserID is the userID argument value.
			UserID string
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// FindEventualUsersToMergeWith holds details about calls to the FindEventualUsersToMergeWith method.
		FindEventualUsersToMergeWith []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Workspace is the workspace argument value.
			Workspace *entity.Workspace
			// WithUser is the withUser argument value.
			WithUser *entity.User
			// WithReconciliationKeys is the withReconciliationKeys argument value.
			WithReconciliationKeys entity.MapOfInterfaces
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// FindMessageByID holds details about calls to the FindMessageByID method.
		FindMessageByID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Workspace is the workspace argument value.
			Workspace *entity.Workspace
			// ID is the id argument value.
			ID string
			// UserID is the userID argument value.
			UserID string
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// FindOrderByID holds details about calls to the FindOrderByID method.
		FindOrderByID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Workspace is the workspace argument value.
			Workspace *entity.Workspace
			// OrderID is the orderID argument value.
			OrderID string
			// UserID is the userID argument value.
			UserID string
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// FindOrderItemsByOrderID holds details about calls to the FindOrderItemsByOrderID method.
		FindOrderItemsByOrderID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WorkspaceID is the workspaceID argument value.
			WorkspaceID string
			// OrderID is the orderID argument value.
			OrderID string
			// UserID is the userID argument value.
			UserID string
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// FindPageviewByID holds details about calls to the FindPageviewByID method.
		FindPageviewByID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Workspace is the workspace argument value.
			Workspace *entity.Workspace
			// PageviewID is the pageviewID argument value.
			PageviewID string
			// UserID is the userID argument value.
			UserID string
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// FindPostviewByID holds details about calls to the FindPostviewByID method.
		FindPostviewByID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WorkspaceID is the workspaceID argument value.
			WorkspaceID *entity.Workspace
			// PostviewID is the postviewID argument value.
			PostviewID string
			// UserID is the userID argument value.
			UserID string
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// FindSessionByID holds details about calls to the FindSessionByID method.
		FindSessionByID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Workspace is the workspace argument value.
			Workspace *entity.Workspace
			// SessionID is the sessionID argument value.
			SessionID string
			// UserID is the userID argument value.
			UserID string
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// FindSubscriptionListUser holds details about calls to the FindSubscriptionListUser method.
		FindSubscriptionListUser []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ListID is the listID argument value.
			ListID string
			// UserID is the userID argument value.
			UserID string
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// FindUserAlias holds details about calls to the FindUserAlias method.
		FindUserAlias []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// FromUserExternalID is the fromUserExternalID argument value.
			FromUserExternalID string
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// FindUserByID holds details about calls to the FindUserByID method.
		FindUserByID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Workspace is the workspace argument value.
			Workspace *entity.Workspace
			// UserID is the userID argument value.
			UserID string
			// Tx is the tx argument value.
			Tx *sql.Tx
			// UserWith is the userWith argument value.
			UserWith *dto.UserWith
		}
		// FindUserIDsWithOrdersToReattribute holds details about calls to the FindUserIDsWithOrdersToReattribute method.
		FindUserIDsWithOrdersToReattribute []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WorkspaceID is the workspaceID argument value.
			WorkspaceID string
			// Limit is the limit argument value.
			Limit int
		}
		// FindUsersAliased holds details about calls to the FindUsersAliased method.
		FindUsersAliased []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WorkspaceID is the workspaceID argument value.
			WorkspaceID string
			// ToUserExternalID is the toUserExternalID argument value.
			ToUserExternalID string
		}
		// GetAccountFromEmail holds details about calls to the GetAccountFromEmail method.
		GetAccountFromEmail []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Email is the email argument value.
			Email string
		}
		// GetAccountFromID holds details about calls to the GetAccountFromID method.
		GetAccountFromID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// AccountID is the accountID argument value.
			AccountID string
		}
		// GetApp holds details about calls to the GetApp method.
		GetApp []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WorkspaceID is the workspaceID argument value.
			WorkspaceID string
			// AppID is the appID argument value.
			AppID string
		}
		// GetBroadcastCampaign holds details about calls to the GetBroadcastCampaign method.
		GetBroadcastCampaign []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WorkspaceID is the workspaceID argument value.
			WorkspaceID string
			// CampaignID is the campaignID argument value.
			CampaignID string
		}
		// GetDataLog holds details about calls to the GetDataLog method.
		GetDataLog []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WorkspaceID is the workspaceID argument value.
			WorkspaceID string
			// DataLogID is the dataLogID argument value.
			DataLogID string
		}
		// GetDataLogChildren holds details about calls to the GetDataLogChildren method.
		GetDataLogChildren []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WorkspaceID is the workspaceID argument value.
			WorkspaceID string
			// DataLogID is the dataLogID argument value.
			DataLogID string
		}
		// GetInvitation holds details about calls to the GetInvitation method.
		GetInvitation []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Email is the email argument value.
			Email string
			// OrganizationID is the organizationID argument value.
			OrganizationID string
		}
		// GetMessageTemplate holds details about calls to the GetMessageTemplate method.
		GetMessageTemplate []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WorkspaceID is the workspaceID argument value.
			WorkspaceID string
			// ID is the id argument value.
			ID string
			// Version is the version argument value.
			Version *int64
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// GetOrganization holds details about calls to the GetOrganization method.
		GetOrganization []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// OrganizationID is the organizationID argument value.
			OrganizationID string
		}
		// GetRunningTaskExecByTaskID holds details about calls to the GetRunningTaskExecByTaskID method.
		GetRunningTaskExecByTaskID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TaskID is the taskID argument value.
			TaskID string
			// MultipleExecKey is the multipleExecKey argument value.
			MultipleExecKey *string
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// GetSegment holds details about calls to the GetSegment method.
		GetSegment []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WorkspaceID is the workspaceID argument value.
			WorkspaceID string
			// SegmentID is the segmentID argument value.
			SegmentID string
		}
		// GetSettings holds details about calls to the GetSettings method.
		GetSettings []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// GetSubscriptionList holds details about calls to the GetSubscriptionList method.
		GetSubscriptionList []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WorkspaceID is the workspaceID argument value.
			WorkspaceID string
			// ListID is the listID argument value.
			ListID string
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// GetSubscriptionListUsersToMessage holds details about calls to the GetSubscriptionListUsersToMessage method.
		GetSubscriptionListUsersToMessage []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WorkspaceID is the workspaceID argument value.
			WorkspaceID string
			// ListIDs is the listIDs argument value.
			ListIDs []string
			// Offset is the offset argument value.
			Offset int64
			// Limit is the limit argument value.
			Limit int64
		}
		// GetSystemConnection holds details about calls to the GetSystemConnection method.
		GetSystemConnection []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// GetTask holds details about calls to the GetTask method.
		GetTask []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WorkspaceID is the workspaceID argument value.
			WorkspaceID string
			// TaskID is the taskID argument value.
			TaskID string
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// GetTaskExec holds details about calls to the GetTaskExec method.
		GetTaskExec []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WorkspaceID is the workspaceID argument value.
			WorkspaceID string
			// TaskID is the taskID argument value.
			TaskID string
		}
		// GetTaskExecJob holds details about calls to the GetTaskExecJob method.
		GetTaskExecJob []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WorkspaceID is the workspaceID argument value.
			WorkspaceID string
			// JobID is the jobID argument value.
			JobID string
		}
		// GetTaskExecJobs holds details about calls to the GetTaskExecJobs method.
		GetTaskExecJobs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WorkspaceID is the workspaceID argument value.
			WorkspaceID string
			// TaskExecID is the taskExecID argument value.
			TaskExecID string
			// Offset is the offset argument value.
			Offset int
			// Limit is the limit argument value.
			Limit int
		}
		// GetUsersNotInSubscriptionList holds details about calls to the GetUsersNotInSubscriptionList method.
		GetUsersNotInSubscriptionList []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WorkspaceID is the workspaceID argument value.
			WorkspaceID string
			// ListID is the listID argument value.
			ListID string
			// Offset is the offset argument value.
			Offset int64
			// Limit is the limit argument value.
			Limit int64
			// SegmentID is the segmentID argument value.
			SegmentID *string
		}
		// GetWorkspace holds details about calls to the GetWorkspace method.
		GetWorkspace []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WorkspaceID is the workspaceID argument value.
			WorkspaceID string
		}
		// GetWorkspaceConnection holds details about calls to the GetWorkspaceConnection method.
		GetWorkspaceConnection []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WorkspaceID is the workspaceID argument value.
			WorkspaceID string
		}
		// HasDataLogsToReprocess holds details about calls to the HasDataLogsToReprocess method.
		HasDataLogsToReprocess []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WorkspaceID is the workspaceID argument value.
			WorkspaceID string
			// UntilDate is the untilDate argument value.
			UntilDate time.Time
		}
		// InsertAccount holds details about calls to the InsertAccount method.
		InsertAccount []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Account is the account argument value.
			Account *entity.Account
			// OrganizationID is the organizationID argument value.
			OrganizationID string
			// FromAccountID is the fromAccountID argument value.
			FromAccountID string
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// InsertAccountSession holds details about calls to the InsertAccountSession method.
		InsertAccountSession []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// AccountSession is the accountSession argument value.
			AccountSession *entity.AccountSession
		}
		// InsertApp holds details about calls to the InsertApp method.
		InsertApp []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// App is the app argument value.
			App *entity.App
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// InsertAppItem holds details about calls to the InsertAppItem method.
		InsertAppItem []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Kind is the kind argument value.
			Kind string
			// UpsertedAppItem is the upsertedAppItem argument value.
			UpsertedAppItem *entity.AppItem
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// InsertBroadcastCampaign holds details about calls to the InsertBroadcastCampaign method.
		InsertBroadcastCampaign []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WorkspaceID is the workspaceID argument value.
			WorkspaceID string
			// Campaign is the campaign argument value.
			Campaign *entity.BroadcastCampaign
		}
		// InsertCart holds details about calls to the InsertCart method.
		InsertCart []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Cart is the cart argument value.
			Cart *entity.Cart
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// InsertCartItem holds details about calls to the InsertCartItem method.
		InsertCartItem []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// CartItem is the cartItem argument value.
			CartItem *entity.CartItem
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// InsertCustomEvent holds details about calls to the InsertCustomEvent method.
		InsertCustomEvent []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Event is the event argument value.
			Event *entity.CustomEvent
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// InsertDataLog holds details about calls to the InsertDataLog method.
		InsertDataLog []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WorkspaceID is the workspaceID argument value.
			WorkspaceID string
			// DataLog is the dataLog argument value.
			DataLog *entity.DataLog
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// InsertDevice holds details about calls to the InsertDevice method.
		InsertDevice []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Device is the device argument value.
			Device *entity.Device
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// InsertMessage holds details about calls to the InsertMessage method.
		InsertMessage []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Message is the message argument value.
			Message *entity.Message
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// InsertMessageTemplate holds details about calls to the InsertMessageTemplate method.
		InsertMessageTemplate []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WorkspaceID is the workspaceID argument value.
			WorkspaceID string
			// Template is the template argument value.
			Template *entity.MessageTemplate
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// InsertOrder holds details about calls to the InsertOrder method.
		InsertOrder []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Order is the order argument value.
			Order *entity.Order
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// InsertOrderItem holds details about calls to the InsertOrderItem method.
		InsertOrderItem []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// OrderItem is the orderItem argument value.
			OrderItem *entity.OrderItem
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// InsertPageview holds details about calls to the InsertPageview method.
		InsertPageview []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Pageview is the pageview argument value.
			Pageview *entity.Pageview
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// InsertPostview holds details about calls to the InsertPostview method.
		InsertPostview []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Postview is the postview argument value.
			Postview *entity.Postview
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// InsertSegment holds details about calls to the InsertSegment method.
		InsertSegment []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Segment is the segment argument value.
			Segment *entity.Segment
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// InsertSegmentDataLogs holds details about calls to the InsertSegmentDataLogs method.
		InsertSegmentDataLogs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WorkspaceID is the workspaceID argument value.
			WorkspaceID string
			// SegmentID is the segmentID argument value.
			SegmentID string
			// SegmentVersion is the segmentVersion argument value.
			SegmentVersion int
			// TaskID is the taskID argument value.
			TaskID string
			// IsEnter is the isEnter argument value.
			IsEnter bool
			// CreatedAt is the createdAt argument value.
			CreatedAt time.Time
			// Checkpoint is the checkpoint argument value.
			Checkpoint int
		}
		// InsertServiceAccount holds details about calls to the InsertServiceAccount method.
		InsertServiceAccount []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Account is the account argument value.
			Account *entity.Account
			// OrganizationID is the organizationID argument value.
			OrganizationID string
			// FromAccountID is the fromAccountID argument value.
			FromAccountID string
			// WorkspaceScopes is the workspaceScopes argument value.
			WorkspaceScopes entity.WorkspacesScopes
		}
		// InsertSession holds details about calls to the InsertSession method.
		InsertSession []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Session is the session argument value.
			Session *entity.Session
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// InsertSubscriptionListUser holds details about calls to the InsertSubscriptionListUser method.
		InsertSubscriptionListUser []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Subscription is the subscription argument value.
			Subscription *entity.SubscriptionListUser
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// InsertTask holds details about calls to the InsertTask method.
		InsertTask []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Task is the task argument value.
			Task *entity.Task
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// InsertTaskExec holds details about calls to the InsertTaskExec method.
		InsertTaskExec []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WorkspaceID is the workspaceID argument value.
			WorkspaceID string
			// Task is the task argument value.
			Task *entity.TaskExec
			// Job is the job argument value.
			Job *entity.TaskExecJob
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// InsertUser holds details about calls to the InsertUser method.
		InsertUser []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// User is the user argument value.
			User *entity.User
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// InsertUserSegment holds details about calls to the InsertUserSegment method.
		InsertUserSegment []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserSegment is the userSegment argument value.
			UserSegment *entity.UserSegment
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// InsertWorkspace holds details about calls to the InsertWorkspace method.
		InsertWorkspace []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Workspace is the workspace argument value.
			Workspace *entity.Workspace
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// Install holds details about calls to the Install method.
		Install []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// RootAccount is the rootAccount argument value.
			RootAccount *entity.Account
			// DefaultOrganization is the defaultOrganization argument value.
			DefaultOrganization *entity.Organization
		}
		// IsAccountOfOrganization holds details about calls to the IsAccountOfOrganization method.
		IsAccountOfOrganization []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// AccountId is the accountId argument value.
			AccountId string
			// OrganizationId is the organizationId argument value.
			OrganizationId string
			// ShouldBeOwner is the shouldBeOwner argument value.
			ShouldBeOwner bool
		}
		// IsDuplicateEntry holds details about calls to the IsDuplicateEntry method.
		IsDuplicateEntry []struct {
			// Err is the err argument value.
			Err error
		}
		// IsExistingColumnTheSame holds details about calls to the IsExistingColumnTheSame method.
		IsExistingColumnTheSame []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WorkspaceID is the workspaceID argument value.
			WorkspaceID string
			// TableName is the tableName argument value.
			TableName string
			// Column is the column argument value.
			Column *entity.TableColumn
		}
		// IsExistingTableTheSame holds details about calls to the IsExistingTableTheSame method.
		IsExistingTableTheSame []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WorkspaceID is the workspaceID argument value.
			WorkspaceID string
			// Table is the table argument value.
			Table *entity.AppTableManifest
		}
		// ListAccountsForOrganization holds details about calls to the ListAccountsForOrganization method.
		ListAccountsForOrganization []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// OrganizationID is the organizationID argument value.
			OrganizationID string
		}
		// ListApps holds details about calls to the ListApps method.
		ListApps []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WorkspaceID is the workspaceID argument value.
			WorkspaceID string
		}
		// ListBroadcastCampaigns holds details about calls to the ListBroadcastCampaigns method.
		ListBroadcastCampaigns []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WorkspaceID is the workspaceID argument value.
			WorkspaceID string
			// Params is the params argument value.
			Params *dto.BroadcastCampaignListParams
		}
		// ListCustomEventsForUser holds details about calls to the ListCustomEventsForUser method.
		ListCustomEventsForUser []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Workspace is the workspace argument value.
			Workspace *entity.Workspace
			// UserID is the userID argument value.
			UserID string
			// OrderBy is the orderBy argument value.
			OrderBy string
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// ListDataLogs holds details about calls to the ListDataLogs method.
		ListDataLogs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WorkspaceID is the workspaceID argument value.
			WorkspaceID string
			// Params is the params argument value.
			Params *dto.DataLogListParams
		}
		// ListDataLogsToReprocess holds details about calls to the ListDataLogsToReprocess method.
		ListDataLogsToReprocess []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WorkspaceID is the workspaceID argument value.
			WorkspaceID string
			// LastID is the lastID argument value.
			LastID string
			// LastIDEventAt is the lastIDEventAt argument value.
			LastIDEventAt time.Time
			// Limit is the limit argument value.
			Limit int
		}
		// ListDataLogsToRespawn holds details about calls to the ListDataLogsToRespawn method.
		ListDataLogsToRespawn []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WorkspaceID is the workspaceID argument value.
			WorkspaceID string
			// Origin is the origin argument value.
			Origin int
			// OriginID is the originID argument value.
			OriginID string
			// Checkpoint is the checkpoint argument value.
			Checkpoint int
			// Limit is the limit argument value.
			Limit int
			// WithNextToken is the withNextToken argument value.
			WithNextToken *string
		}
		// ListDevicesForUser holds details about calls to the ListDevicesForUser method.
		ListDevicesForUser []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Workspace is the workspace argument value.
			Workspace *entity.Workspace
			// UserID is the userID argument value.
			UserID string
			// OrderBy is the orderBy argument value.
			OrderBy string
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// ListInvitationsForOrganization holds details about calls to the ListInvitationsForOrganization method.
		ListInvitationsForOrganization []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// OrganizationID is the organizationID argument value.
			OrganizationID string
		}
		// ListMessageTemplates holds details about calls to the ListMessageTemplates method.
		ListMessageTemplates []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WorkspaceID is the workspaceID argument value.
			WorkspaceID string
			// Params is the params argument value.
			Params *dto.MessageTemplateListParams
		}
		// ListOrdersForUser holds details about calls to the ListOrdersForUser method.
		ListOrdersForUser []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Workspace is the workspace argument value.
			Workspace *entity.Workspace
			// UserID is the userID argument value.
			UserID string
			// OrderBy is the orderBy argument value.
			OrderBy string
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// ListOrganizationsForAccount holds details about calls to the ListOrganizationsForAccount method.
		ListOrganizationsForAccount []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// AccountID is the accountID argument value.
			AccountID string
		}
		// ListPostviewsForUser holds details about calls to the ListPostviewsForUser method.
		ListPostviewsForUser []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Workspace is the workspace argument value.
			Workspace *entity.Workspace
			// UserID is the userID argument value.
			UserID string
			// OrderBy is the orderBy argument value.
			OrderBy string
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// ListSegments holds details about calls to the ListSegments method.
		ListSegments []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WorkspaceID is the workspaceID argument value.
			WorkspaceID string
			// WithUsersCount is the withUsersCount argument value.
			WithUsersCount bool
		}
		// ListSessionsForUser holds details about calls to the ListSessionsForUser method.
		ListSessionsForUser []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Workspace is the workspace argument value.
			Workspace *entity.Workspace
			// UserID is the userID argument value.
			UserID string
			// OrderBy is the orderBy argument value.
			OrderBy string
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// ListSubscriptionListUsers holds details about calls to the ListSubscriptionListUsers method.
		ListSubscriptionListUsers []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WorkspaceID is the workspaceID argument value.
			WorkspaceID string
			// UserIDs is the userIDs argument value.
			UserIDs []string
		}
		// ListSubscriptionLists holds details about calls to the ListSubscriptionLists method.
		ListSubscriptionLists []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WorkspaceID is the workspaceID argument value.
			WorkspaceID string
			// WithUsersCount is the withUsersCount argument value.
			WithUsersCount bool
		}
		// ListTaskExecs holds details about calls to the ListTaskExecs method.
		ListTaskExecs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WorkspaceID is the workspaceID argument value.
			WorkspaceID string
			// Params is the params argument value.
			Params *dto.TaskExecListParams
		}
		// ListTasks holds details about calls to the ListTasks method.
		ListTasks []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WorkspaceID is the workspaceID argument value.
			WorkspaceID string
		}
		// ListTasksToWakeUp holds details about calls to the ListTasksToWakeUp method.
		ListTasksToWakeUp []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ListUserSegments holds details about calls to the ListUserSegments method.
		ListUserSegments []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WorkspaceID is the workspaceID argument value.
			WorkspaceID string
			// UserIDs is the userIDs argument value.
			UserIDs []string
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// ListUsers holds details about calls to the ListUsers method.
		ListUsers []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Workspace is the workspace argument value.
			Workspace *entity.Workspace
			// Params is the params argument value.
			Params *dto.UserListParams
		}
		// ListWorkspaces holds details about calls to the ListWorkspaces method.
		ListWorkspaces []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// OrganizationID is the organizationID argument value.
			OrganizationID *string
		}
		// MatchSegmentUsers holds details about calls to the MatchSegmentUsers method.
		MatchSegmentUsers []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WorkspaceID is the workspaceID argument value.
			WorkspaceID string
			// Segment is the segment argument value.
			Segment *entity.Segment
			// UserIDs is the userIDs argument value.
			UserIDs []string
		}
		// MergeUserCartItems holds details about calls to the MergeUserCartItems method.
		MergeUserCartItems []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Workspace is the workspace argument value.
			Workspace *entity.Workspace
			// FromUserID is the fromUserID argument value.
			FromUserID string
			// ToUserID is the toUserID argument value.
			ToUserID string
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// MergeUserCarts holds details about calls to the MergeUserCarts method.
		MergeUserCarts []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Workspace is the workspace argument value.
			Workspace *entity.Workspace
			// FromUserID is the fromUserID argument value.
			FromUserID string
			// ToUserID is the toUserID argument value.
			ToUserID string
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// MergeUserCustomEvents holds details about calls to the MergeUserCustomEvents method.
		MergeUserCustomEvents []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Workspace is the workspace argument value.
			Workspace *entity.Workspace
			// FromUserID is the fromUserID argument value.
			FromUserID string
			// ToUserID is the toUserID argument value.
			ToUserID string
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// MergeUserDataLogs holds details about calls to the MergeUserDataLogs method.
		MergeUserDataLogs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Workspace is the workspace argument value.
			Workspace *entity.Workspace
			// FromUserID is the fromUserID argument value.
			FromUserID string
			// FromUserExternalID is the fromUserExternalID argument value.
			FromUserExternalID string
			// ToUserID is the toUserID argument value.
			ToUserID string
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// MergeUserDevices holds details about calls to the MergeUserDevices method.
		MergeUserDevices []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Workspace is the workspace argument value.
			Workspace *entity.Workspace
			// FromUserID is the fromUserID argument value.
			FromUserID string
			// ToUserID is the toUserID argument value.
			ToUserID string
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// MergeUserOrderItems holds details about calls to the MergeUserOrderItems method.
		MergeUserOrderItems []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Workspace is the workspace argument value.
			Workspace *entity.Workspace
			// FromUserID is the fromUserID argument value.
			FromUserID string
			// ToUserID is the toUserID argument value.
			ToUserID string
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// MergeUserOrders holds details about calls to the MergeUserOrders method.
		MergeUserOrders []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Workspace is the workspace argument value.
			Workspace *entity.Workspace
			// FromUserID is the fromUserID argument value.
			FromUserID string
			// ToUserID is the toUserID argument value.
			ToUserID string
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// MergeUserPageviews holds details about calls to the MergeUserPageviews method.
		MergeUserPageviews []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Workspace is the workspace argument value.
			Workspace *entity.Workspace
			// FromUserID is the fromUserID argument value.
			FromUserID string
			// ToUserID is the toUserID argument value.
			ToUserID string
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// MergeUserPostviews holds details about calls to the MergeUserPostviews method.
		MergeUserPostviews []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Workspace is the workspace argument value.
			Workspace *entity.Workspace
			// FromUserID is the fromUserID argument value.
			FromUserID string
			// ToUserID is the toUserID argument value.
			ToUserID string
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// MergeUserSessions holds details about calls to the MergeUserSessions method.
		MergeUserSessions []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Workspace is the workspace argument value.
			Workspace *entity.Workspace
			// FromUserID is the fromUserID argument value.
			FromUserID string
			// ToUserID is the toUserID argument value.
			ToUserID string
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// PreviewSegment holds details about calls to the PreviewSegment method.
		PreviewSegment []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WorkspaceID is the workspaceID argument value.
			WorkspaceID string
			// ParentSegmentID is the parentSegmentID argument value.
			ParentSegmentID *string
			// Filter is the filter argument value.
			Filter *entity.SegmentTreeNode
			// Timezone is the timezone argument value.
			Timezone string
		}
		// ReleaseUsersLock holds details about calls to the ReleaseUsersLock method.
		ReleaseUsersLock []struct {
			// WorkspaceID is the workspaceID argument value.
			WorkspaceID string
			// Lock is the lock argument value.
			Lock *entity.UsersLock
		}
		// ResetAccountPassword holds details about calls to the ResetAccountPassword method.
		ResetAccountPassword []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// AccountID is the accountID argument value.
			AccountID string
			// NewPassword is the newPassword argument value.
			NewPassword string
		}
		// ResetPostviewsAttributedForConversion holds details about calls to the ResetPostviewsAttributedForConversion method.
		ResetPostviewsAttributedForConversion []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserID is the userID argument value.
			UserID string
			// ConversionID is the conversionID argument value.
			ConversionID string
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// ResetSessionsAttributedForConversion holds details about calls to the ResetSessionsAttributedForConversion method.
		ResetSessionsAttributedForConversion []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserID is the userID argument value.
			UserID string
			// ConversionID is the conversionID argument value.
			ConversionID string
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// RunInTransactionForSystem holds details about calls to the RunInTransactionForSystem method.
		RunInTransactionForSystem []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// F is the f argument value.
			F func(context.Context, *sql.Tx) (int, error)
		}
		// RunInTransactionForWorkspace holds details about calls to the RunInTransactionForWorkspace method.
		RunInTransactionForWorkspace []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WorkspaceID is the workspaceID argument value.
			WorkspaceID string
			// F is the f argument value.
			F func(context.Context, *sql.Tx) (int, error)
		}
		// SetTaskExecError holds details about calls to the SetTaskExecError method.
		SetTaskExecError []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WorkspaceID is the workspaceID argument value.
			WorkspaceID string
			// TaskExecID is the taskExecID argument value.
			TaskExecID string
			// WorkerID is the workerID argument value.
			WorkerID int
			// Status is the status argument value.
			Status int
			// Message is the message argument value.
			Message string
		}
		// ShowTables holds details about calls to the ShowTables method.
		ShowTables []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WorkspaceID is the workspaceID argument value.
			WorkspaceID string
		}
		// StopAppTasks holds details about calls to the StopAppTasks method.
		StopAppTasks []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WorkspaceID is the workspaceID argument value.
			WorkspaceID string
			// AppID is the appID argument value.
			AppID string
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// StopTaskExecsForApp holds details about calls to the StopTaskExecsForApp method.
		StopTaskExecsForApp []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// AppID is the appID argument value.
			AppID string
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// TransferOrganizationOwnsership holds details about calls to the TransferOrganizationOwnsership method.
		TransferOrganizationOwnsership []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// AccountID is the accountID argument value.
			AccountID string
			// ToAccountID is the toAccountID argument value.
			ToAccountID string
			// OrganizationID is the organizationID argument value.
			OrganizationID string
		}
		// UpdateAccountProfile holds details about calls to the UpdateAccountProfile method.
		UpdateAccountProfile []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Account is the account argument value.
			Account *entity.Account
		}
		// UpdateAccountSessionLastAccess holds details about calls to the UpdateAccountSessionLastAccess method.
		UpdateAccountSessionLastAccess []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// AccountID is the accountID argument value.
			AccountID string
			// AccountSessionID is the accountSessionID argument value.
			AccountSessionID string
			// Now is the now argument value.
			Now time.Time
		}
		// UpdateApp holds details about calls to the UpdateApp method.
		UpdateApp []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// App is the app argument value.
			App *entity.App
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// UpdateAppItem holds details about calls to the UpdateAppItem method.
		UpdateAppItem []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Kind is the kind argument value.
			Kind string
			// UpsertedAppItem is the upsertedAppItem argument value.
			UpsertedAppItem *entity.AppItem
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// UpdateBroadcastCampaign holds details about calls to the UpdateBroadcastCampaign method.
		UpdateBroadcastCampaign []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WorkspaceID is the workspaceID argument value.
			WorkspaceID string
			// Campaign is the campaign argument value.
			Campaign *entity.BroadcastCampaign
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// UpdateCart holds details about calls to the UpdateCart method.
		UpdateCart []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Cart is the cart argument value.
			Cart *entity.Cart
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// UpdateCartItem holds details about calls to the UpdateCartItem method.
		UpdateCartItem []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// CartItem is the cartItem argument value.
			CartItem *entity.CartItem
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// UpdateChannel holds details about calls to the UpdateChannel method.
		UpdateChannel []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Workspace is the workspace argument value.
			Workspace *entity.Workspace
			// UpdatedChannel is the updatedChannel argument value.
			UpdatedChannel *entity.Channel
		}
		// UpdateCustomEvent holds details about calls to the UpdateCustomEvent method.
		UpdateCustomEvent []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Event is the event argument value.
			Event *entity.CustomEvent
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// UpdateDataLog holds details about calls to the UpdateDataLog method.
		UpdateDataLog []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WorkspaceID is the workspaceID argument value.
			WorkspaceID string
			// DataLog is the dataLog argument value.
			DataLog *entity.DataLog
		}
		// UpdateDevice holds details about calls to the UpdateDevice method.
		UpdateDevice []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Device is the device argument value.
			Device *entity.Device
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// UpdateMessage holds details about calls to the UpdateMessage method.
		UpdateMessage []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Message is the message argument value.
			Message *entity.Message
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// UpdateOrder holds details about calls to the UpdateOrder method.
		UpdateOrder []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Order is the order argument value.
			Order *entity.Order
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// UpdateOrderAttribution holds details about calls to the UpdateOrderAttribution method.
		UpdateOrderAttribution []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Order is the order argument value.
			Order *entity.Order
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// UpdateOrderItem holds details about calls to the UpdateOrderItem method.
		UpdateOrderItem []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// OrderItem is the orderItem argument value.
			OrderItem *entity.OrderItem
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// UpdateOrganizationProfile holds details about calls to the UpdateOrganizationProfile method.
		UpdateOrganizationProfile []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Organization is the organization argument value.
			Organization *entity.Organization
		}
		// UpdatePageview holds details about calls to the UpdatePageview method.
		UpdatePageview []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Pageview is the pageview argument value.
			Pageview *entity.Pageview
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// UpdatePostview holds details about calls to the UpdatePostview method.
		UpdatePostview []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Postview is the postview argument value.
			Postview *entity.Postview
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// UpdateSegment holds details about calls to the UpdateSegment method.
		UpdateSegment []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Segment is the segment argument value.
			Segment *entity.Segment
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// UpdateSession holds details about calls to the UpdateSession method.
		UpdateSession []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Session is the session argument value.
			Session *entity.Session
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// UpdateSubscriptionListUser holds details about calls to the UpdateSubscriptionListUser method.
		UpdateSubscriptionListUser []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Subscription is the subscription argument value.
			Subscription *entity.SubscriptionListUser
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// UpdateTask holds details about calls to the UpdateTask method.
		UpdateTask []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Task is the task argument value.
			Task *entity.Task
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// UpdateTaskExecFromResult holds details about calls to the UpdateTaskExecFromResult method.
		UpdateTaskExecFromResult []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TaskExecRequestPayload is the taskExecRequestPayload argument value.
			TaskExecRequestPayload *dto.TaskExecRequestPayload
			// TaskExecResult is the taskExecResult argument value.
			TaskExecResult *entity.TaskExecResult
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// UpdateUser holds details about calls to the UpdateUser method.
		UpdateUser []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// User is the user argument value.
			User *entity.User
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// UpdateWorkspace holds details about calls to the UpdateWorkspace method.
		UpdateWorkspace []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Workspace is the workspace argument value.
			Workspace *entity.Workspace
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// UpsertOrganizationInvitation holds details about calls to the UpsertOrganizationInvitation method.
		UpsertOrganizationInvitation []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// AccountInvitation is the accountInvitation argument value.
			AccountInvitation *entity.OrganizationInvitation
		}
		// UseWorkspaceDBWithTx holds details about calls to the UseWorkspaceDBWithTx method.
		UseWorkspaceDBWithTx []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WorkspaceID is the workspaceID argument value.
			WorkspaceID string
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
	}
	lockAbortTaskExec                         sync.RWMutex
	lockAccountLogout                         sync.RWMutex
	lockActivateAppTasks                      sync.RWMutex
	lockActivateSegment                       sync.RWMutex
	lockAddAccountToOrganization              sync.RWMutex
	lockAddColumn                             sync.RWMutex
	lockAddJobToTaskExec                      sync.RWMutex
	lockAddTaskExecWorker                     sync.RWMutex
	lockCancelOrganizationInvitation          sync.RWMutex
	lockCleanAfterUserAlias                   sync.RWMutex
	lockClearUserSegmentQueue                 sync.RWMutex
	lockConsumeInvitation                     sync.RWMutex
	lockCountSuccessfulDataLogsForDemo        sync.RWMutex
	lockCreateChannel                         sync.RWMutex
	lockCreateOrganization                    sync.RWMutex
	lockCreateSubscriptionList                sync.RWMutex
	lockCreateTable                           sync.RWMutex
	lockCreateUserAlias                       sync.RWMutex
	lockCreateWorkspaceTables                 sync.RWMutex
	lockDeactivateOrganizationAccount         sync.RWMutex
	lockDeleteApp                             sync.RWMutex
	lockDeleteAppItemByExternalID             sync.RWMutex
	lockDeleteAppItemByID                     sync.RWMutex
	lockDeleteAppTasks                        sync.RWMutex
	lockDeleteCartItem                        sync.RWMutex
	lockDeleteChannel                         sync.RWMutex
	lockDeleteColumn                          sync.RWMutex
	lockDeleteDomain                          sync.RWMutex
	lockDeleteOrderItem                       sync.RWMutex
	lockDeleteSegment                         sync.RWMutex
	lockDeleteTable                           sync.RWMutex
	lockDeleteUserSegment                     sync.RWMutex
	lockDeleteUserSegmentQueueRow             sync.RWMutex
	lockDeleteWorkspace                       sync.RWMutex
	lockDevResetDB                            sync.RWMutex
	lockEnqueueMatchingSegmentUsers           sync.RWMutex
	lockEnsureUsersLock                       sync.RWMutex
	lockEnterUserSegmentFromQueue             sync.RWMutex
	lockExitUserSegmentFromQueue              sync.RWMutex
	lockFetchAppItems                         sync.RWMutex
	lockFetchCustomEvents                     sync.RWMutex
	lockFetchDevices                          sync.RWMutex
	lockFetchSessions                         sync.RWMutex
	lockFindAppItemByExternalID               sync.RWMutex
	lockFindAppItemByID                       sync.RWMutex
	lockFindCartByID                          sync.RWMutex
	lockFindCartItemsByCartID                 sync.RWMutex
	lockFindCustomEventByID                   sync.RWMutex
	lockFindDeviceByID                        sync.RWMutex
	lockFindEventualUsersToMergeWith          sync.RWMutex
	lockFindMessageByID                       sync.RWMutex
	lockFindOrderByID                         sync.RWMutex
	lockFindOrderItemsByOrderID               sync.RWMutex
	lockFindPageviewByID                      sync.RWMutex
	lockFindPostviewByID                      sync.RWMutex
	lockFindSessionByID                       sync.RWMutex
	lockFindSubscriptionListUser              sync.RWMutex
	lockFindUserAlias                         sync.RWMutex
	lockFindUserByID                          sync.RWMutex
	lockFindUserIDsWithOrdersToReattribute    sync.RWMutex
	lockFindUsersAliased                      sync.RWMutex
	lockGetAccountFromEmail                   sync.RWMutex
	lockGetAccountFromID                      sync.RWMutex
	lockGetApp                                sync.RWMutex
	lockGetBroadcastCampaign                  sync.RWMutex
	lockGetDataLog                            sync.RWMutex
	lockGetDataLogChildren                    sync.RWMutex
	lockGetInvitation                         sync.RWMutex
	lockGetMessageTemplate                    sync.RWMutex
	lockGetOrganization                       sync.RWMutex
	lockGetRunningTaskExecByTaskID            sync.RWMutex
	lockGetSegment                            sync.RWMutex
	lockGetSettings                           sync.RWMutex
	lockGetSubscriptionList                   sync.RWMutex
	lockGetSubscriptionListUsersToMessage     sync.RWMutex
	lockGetSystemConnection                   sync.RWMutex
	lockGetTask                               sync.RWMutex
	lockGetTaskExec                           sync.RWMutex
	lockGetTaskExecJob                        sync.RWMutex
	lockGetTaskExecJobs                       sync.RWMutex
	lockGetUsersNotInSubscriptionList         sync.RWMutex
	lockGetWorkspace                          sync.RWMutex
	lockGetWorkspaceConnection                sync.RWMutex
	lockHasDataLogsToReprocess                sync.RWMutex
	lockInsertAccount                         sync.RWMutex
	lockInsertAccountSession                  sync.RWMutex
	lockInsertApp                             sync.RWMutex
	lockInsertAppItem                         sync.RWMutex
	lockInsertBroadcastCampaign               sync.RWMutex
	lockInsertCart                            sync.RWMutex
	lockInsertCartItem                        sync.RWMutex
	lockInsertCustomEvent                     sync.RWMutex
	lockInsertDataLog                         sync.RWMutex
	lockInsertDevice                          sync.RWMutex
	lockInsertMessage                         sync.RWMutex
	lockInsertMessageTemplate                 sync.RWMutex
	lockInsertOrder                           sync.RWMutex
	lockInsertOrderItem                       sync.RWMutex
	lockInsertPageview                        sync.RWMutex
	lockInsertPostview                        sync.RWMutex
	lockInsertSegment                         sync.RWMutex
	lockInsertSegmentDataLogs                 sync.RWMutex
	lockInsertServiceAccount                  sync.RWMutex
	lockInsertSession                         sync.RWMutex
	lockInsertSubscriptionListUser            sync.RWMutex
	lockInsertTask                            sync.RWMutex
	lockInsertTaskExec                        sync.RWMutex
	lockInsertUser                            sync.RWMutex
	lockInsertUserSegment                     sync.RWMutex
	lockInsertWorkspace                       sync.RWMutex
	lockInstall                               sync.RWMutex
	lockIsAccountOfOrganization               sync.RWMutex
	lockIsDuplicateEntry                      sync.RWMutex
	lockIsExistingColumnTheSame               sync.RWMutex
	lockIsExistingTableTheSame                sync.RWMutex
	lockListAccountsForOrganization           sync.RWMutex
	lockListApps                              sync.RWMutex
	lockListBroadcastCampaigns                sync.RWMutex
	lockListCustomEventsForUser               sync.RWMutex
	lockListDataLogs                          sync.RWMutex
	lockListDataLogsToReprocess               sync.RWMutex
	lockListDataLogsToRespawn                 sync.RWMutex
	lockListDevicesForUser                    sync.RWMutex
	lockListInvitationsForOrganization        sync.RWMutex
	lockListMessageTemplates                  sync.RWMutex
	lockListOrdersForUser                     sync.RWMutex
	lockListOrganizationsForAccount           sync.RWMutex
	lockListPostviewsForUser                  sync.RWMutex
	lockListSegments                          sync.RWMutex
	lockListSessionsForUser                   sync.RWMutex
	lockListSubscriptionListUsers             sync.RWMutex
	lockListSubscriptionLists                 sync.RWMutex
	lockListTaskExecs                         sync.RWMutex
	lockListTasks                             sync.RWMutex
	lockListTasksToWakeUp                     sync.RWMutex
	lockListUserSegments                      sync.RWMutex
	lockListUsers                             sync.RWMutex
	lockListWorkspaces                        sync.RWMutex
	lockMatchSegmentUsers                     sync.RWMutex
	lockMergeUserCartItems                    sync.RWMutex
	lockMergeUserCarts                        sync.RWMutex
	lockMergeUserCustomEvents                 sync.RWMutex
	lockMergeUserDataLogs                     sync.RWMutex
	lockMergeUserDevices                      sync.RWMutex
	lockMergeUserOrderItems                   sync.RWMutex
	lockMergeUserOrders                       sync.RWMutex
	lockMergeUserPageviews                    sync.RWMutex
	lockMergeUserPostviews                    sync.RWMutex
	lockMergeUserSessions                     sync.RWMutex
	lockPreviewSegment                        sync.RWMutex
	lockReleaseUsersLock                      sync.RWMutex
	lockResetAccountPassword                  sync.RWMutex
	lockResetPostviewsAttributedForConversion sync.RWMutex
	lockResetSessionsAttributedForConversion  sync.RWMutex
	lockRunInTransactionForSystem             sync.RWMutex
	lockRunInTransactionForWorkspace          sync.RWMutex
	lockSetTaskExecError                      sync.RWMutex
	lockShowTables                            sync.RWMutex
	lockStopAppTasks                          sync.RWMutex
	lockStopTaskExecsForApp                   sync.RWMutex
	lockTransferOrganizationOwnsership        sync.RWMutex
	lockUpdateAccountProfile                  sync.RWMutex
	lockUpdateAccountSessionLastAccess        sync.RWMutex
	lockUpdateApp                             sync.RWMutex
	lockUpdateAppItem                         sync.RWMutex
	lockUpdateBroadcastCampaign               sync.RWMutex
	lockUpdateCart                            sync.RWMutex
	lockUpdateCartItem                        sync.RWMutex
	lockUpdateChannel                         sync.RWMutex
	lockUpdateCustomEvent                     sync.RWMutex
	lockUpdateDataLog                         sync.RWMutex
	lockUpdateDevice                          sync.RWMutex
	lockUpdateMessage                         sync.RWMutex
	lockUpdateOrder                           sync.RWMutex
	lockUpdateOrderAttribution                sync.RWMutex
	lockUpdateOrderItem                       sync.RWMutex
	lockUpdateOrganizationProfile             sync.RWMutex
	lockUpdatePageview                        sync.RWMutex
	lockUpdatePostview                        sync.RWMutex
	lockUpdateSegment                         sync.RWMutex
	lockUpdateSession                         sync.RWMutex
	lockUpdateSubscriptionListUser            sync.RWMutex
	lockUpdateTask                            sync.RWMutex
	lockUpdateTaskExecFromResult              sync.RWMutex
	lockUpdateUser                            sync.RWMutex
	lockUpdateWorkspace                       sync.RWMutex
	lockUpsertOrganizationInvitation          sync.RWMutex
	lockUseWorkspaceDBWithTx                  sync.RWMutex
}

// AbortTaskExec calls AbortTaskExecFunc.
func (mock *RepositoryMock) AbortTaskExec(ctx context.Context, taskID string, message string, tx *sql.Tx) error {
	if mock.AbortTaskExecFunc == nil {
		panic("RepositoryMock.AbortTaskExecFunc: method is nil but Repository.AbortTaskExec was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		TaskID  string
		Message string
		Tx      *sql.Tx
	}{
		Ctx:     ctx,
		TaskID:  taskID,
		Message: message,
		Tx:      tx,
	}
	mock.lockAbortTaskExec.Lock()
	mock.calls.AbortTaskExec = append(mock.calls.AbortTaskExec, callInfo)
	mock.lockAbortTaskExec.Unlock()
	return mock.AbortTaskExecFunc(ctx, taskID, message, tx)
}

// AbortTaskExecCalls gets all the calls that were made to AbortTaskExec.
// Check the length with:
//
//	len(mockedRepository.AbortTaskExecCalls())
func (mock *RepositoryMock) AbortTaskExecCalls() []struct {
	Ctx     context.Context
	TaskID  string
	Message string
	Tx      *sql.Tx
} {
	var calls []struct {
		Ctx     context.Context
		TaskID  string
		Message string
		Tx      *sql.Tx
	}
	mock.lockAbortTaskExec.RLock()
	calls = mock.calls.AbortTaskExec
	mock.lockAbortTaskExec.RUnlock()
	return calls
}

// AccountLogout calls AccountLogoutFunc.
func (mock *RepositoryMock) AccountLogout(ctx context.Context, accountID string, sessionID string) error {
	if mock.AccountLogoutFunc == nil {
		panic("RepositoryMock.AccountLogoutFunc: method is nil but Repository.AccountLogout was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		AccountID string
		SessionID string
	}{
		Ctx:       ctx,
		AccountID: accountID,
		SessionID: sessionID,
	}
	mock.lockAccountLogout.Lock()
	mock.calls.AccountLogout = append(mock.calls.AccountLogout, callInfo)
	mock.lockAccountLogout.Unlock()
	return mock.AccountLogoutFunc(ctx, accountID, sessionID)
}

// AccountLogoutCalls gets all the calls that were made to AccountLogout.
// Check the length with:
//
//	len(mockedRepository.AccountLogoutCalls())
func (mock *RepositoryMock) AccountLogoutCalls() []struct {
	Ctx       context.Context
	AccountID string
	SessionID string
} {
	var calls []struct {
		Ctx       context.Context
		AccountID string
		SessionID string
	}
	mock.lockAccountLogout.RLock()
	calls = mock.calls.AccountLogout
	mock.lockAccountLogout.RUnlock()
	return calls
}

// ActivateAppTasks calls ActivateAppTasksFunc.
func (mock *RepositoryMock) ActivateAppTasks(ctx context.Context, workspaceID string, appID string, tx *sql.Tx) error {
	if mock.ActivateAppTasksFunc == nil {
		panic("RepositoryMock.ActivateAppTasksFunc: method is nil but Repository.ActivateAppTasks was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		WorkspaceID string
		AppID       string
		Tx          *sql.Tx
	}{
		Ctx:         ctx,
		WorkspaceID: workspaceID,
		AppID:       appID,
		Tx:          tx,
	}
	mock.lockActivateAppTasks.Lock()
	mock.calls.ActivateAppTasks = append(mock.calls.ActivateAppTasks, callInfo)
	mock.lockActivateAppTasks.Unlock()
	return mock.ActivateAppTasksFunc(ctx, workspaceID, appID, tx)
}

// ActivateAppTasksCalls gets all the calls that were made to ActivateAppTasks.
// Check the length with:
//
//	len(mockedRepository.ActivateAppTasksCalls())
func (mock *RepositoryMock) ActivateAppTasksCalls() []struct {
	Ctx         context.Context
	WorkspaceID string
	AppID       string
	Tx          *sql.Tx
} {
	var calls []struct {
		Ctx         context.Context
		WorkspaceID string
		AppID       string
		Tx          *sql.Tx
	}
	mock.lockActivateAppTasks.RLock()
	calls = mock.calls.ActivateAppTasks
	mock.lockActivateAppTasks.RUnlock()
	return calls
}

// ActivateSegment calls ActivateSegmentFunc.
func (mock *RepositoryMock) ActivateSegment(ctx context.Context, workspaceID string, segmentID string, segmentVersion int) (bool, error) {
	if mock.ActivateSegmentFunc == nil {
		panic("RepositoryMock.ActivateSegmentFunc: method is nil but Repository.ActivateSegment was just called")
	}
	callInfo := struct {
		Ctx            context.Context
		WorkspaceID    string
		SegmentID      string
		SegmentVersion int
	}{
		Ctx:            ctx,
		WorkspaceID:    workspaceID,
		SegmentID:      segmentID,
		SegmentVersion: segmentVersion,
	}
	mock.lockActivateSegment.Lock()
	mock.calls.ActivateSegment = append(mock.calls.ActivateSegment, callInfo)
	mock.lockActivateSegment.Unlock()
	return mock.ActivateSegmentFunc(ctx, workspaceID, segmentID, segmentVersion)
}

// ActivateSegmentCalls gets all the calls that were made to ActivateSegment.
// Check the length with:
//
//	len(mockedRepository.ActivateSegmentCalls())
func (mock *RepositoryMock) ActivateSegmentCalls() []struct {
	Ctx            context.Context
	WorkspaceID    string
	SegmentID      string
	SegmentVersion int
} {
	var calls []struct {
		Ctx            context.Context
		WorkspaceID    string
		SegmentID      string
		SegmentVersion int
	}
	mock.lockActivateSegment.RLock()
	calls = mock.calls.ActivateSegment
	mock.lockActivateSegment.RUnlock()
	return calls
}

// AddAccountToOrganization calls AddAccountToOrganizationFunc.
func (mock *RepositoryMock) AddAccountToOrganization(ctx context.Context, accountID string, organizationID string, isOwner bool, fromAccountID *string, workspaceScopes entity.WorkspacesScopes, tx *sql.Tx) error {
	if mock.AddAccountToOrganizationFunc == nil {
		panic("RepositoryMock.AddAccountToOrganizationFunc: method is nil but Repository.AddAccountToOrganization was just called")
	}
	callInfo := struct {
		Ctx             context.Context
		AccountID       string
		OrganizationID  string
		IsOwner         bool
		FromAccountID   *string
		WorkspaceScopes entity.WorkspacesScopes
		Tx              *sql.Tx
	}{
		Ctx:             ctx,
		AccountID:       accountID,
		OrganizationID:  organizationID,
		IsOwner:         isOwner,
		FromAccountID:   fromAccountID,
		WorkspaceScopes: workspaceScopes,
		Tx:              tx,
	}
	mock.lockAddAccountToOrganization.Lock()
	mock.calls.AddAccountToOrganization = append(mock.calls.AddAccountToOrganization, callInfo)
	mock.lockAddAccountToOrganization.Unlock()
	return mock.AddAccountToOrganizationFunc(ctx, accountID, organizationID, isOwner, fromAccountID, workspaceScopes, tx)
}

// AddAccountToOrganizationCalls gets all the calls that were made to AddAccountToOrganization.
// Check the length with:
//
//	len(mockedRepository.AddAccountToOrganizationCalls())
func (mock *RepositoryMock) AddAccountToOrganizationCalls() []struct {
	Ctx             context.Context
	AccountID       string
	OrganizationID  string
	IsOwner         bool
	FromAccountID   *string
	WorkspaceScopes entity.WorkspacesScopes
	Tx              *sql.Tx
} {
	var calls []struct {
		Ctx             context.Context
		AccountID       string
		OrganizationID  string
		IsOwner         bool
		FromAccountID   *string
		WorkspaceScopes entity.WorkspacesScopes
		Tx              *sql.Tx
	}
	mock.lockAddAccountToOrganization.RLock()
	calls = mock.calls.AddAccountToOrganization
	mock.lockAddAccountToOrganization.RUnlock()
	return calls
}

// AddColumn calls AddColumnFunc.
func (mock *RepositoryMock) AddColumn(ctx context.Context, workspace *entity.Workspace, tableName string, column *entity.TableColumn) error {
	if mock.AddColumnFunc == nil {
		panic("RepositoryMock.AddColumnFunc: method is nil but Repository.AddColumn was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Workspace *entity.Workspace
		TableName string
		Column    *entity.TableColumn
	}{
		Ctx:       ctx,
		Workspace: workspace,
		TableName: tableName,
		Column:    column,
	}
	mock.lockAddColumn.Lock()
	mock.calls.AddColumn = append(mock.calls.AddColumn, callInfo)
	mock.lockAddColumn.Unlock()
	return mock.AddColumnFunc(ctx, workspace, tableName, column)
}

// AddColumnCalls gets all the calls that were made to AddColumn.
// Check the length with:
//
//	len(mockedRepository.AddColumnCalls())
func (mock *RepositoryMock) AddColumnCalls() []struct {
	Ctx       context.Context
	Workspace *entity.Workspace
	TableName string
	Column    *entity.TableColumn
} {
	var calls []struct {
		Ctx       context.Context
		Workspace *entity.Workspace
		TableName string
		Column    *entity.TableColumn
	}
	mock.lockAddColumn.RLock()
	calls = mock.calls.AddColumn
	mock.lockAddColumn.RUnlock()
	return calls
}

// AddJobToTaskExec calls AddJobToTaskExecFunc.
func (mock *RepositoryMock) AddJobToTaskExec(ctxWithTimeout context.Context, taskExecID string, newJobID string, tx *sql.Tx) error {
	if mock.AddJobToTaskExecFunc == nil {
		panic("RepositoryMock.AddJobToTaskExecFunc: method is nil but Repository.AddJobToTaskExec was just called")
	}
	callInfo := struct {
		CtxWithTimeout context.Context
		TaskExecID     string
		NewJobID       string
		Tx             *sql.Tx
	}{
		CtxWithTimeout: ctxWithTimeout,
		TaskExecID:     taskExecID,
		NewJobID:       newJobID,
		Tx:             tx,
	}
	mock.lockAddJobToTaskExec.Lock()
	mock.calls.AddJobToTaskExec = append(mock.calls.AddJobToTaskExec, callInfo)
	mock.lockAddJobToTaskExec.Unlock()
	return mock.AddJobToTaskExecFunc(ctxWithTimeout, taskExecID, newJobID, tx)
}

// AddJobToTaskExecCalls gets all the calls that were made to AddJobToTaskExec.
// Check the length with:
//
//	len(mockedRepository.AddJobToTaskExecCalls())
func (mock *RepositoryMock) AddJobToTaskExecCalls() []struct {
	CtxWithTimeout context.Context
	TaskExecID     string
	NewJobID       string
	Tx             *sql.Tx
} {
	var calls []struct {
		CtxWithTimeout context.Context
		TaskExecID     string
		NewJobID       string
		Tx             *sql.Tx
	}
	mock.lockAddJobToTaskExec.RLock()
	calls = mock.calls.AddJobToTaskExec
	mock.lockAddJobToTaskExec.RUnlock()
	return calls
}

// AddTaskExecWorker calls AddTaskExecWorkerFunc.
func (mock *RepositoryMock) AddTaskExecWorker(ctx context.Context, taskID string, newJobID string, workerID int, initialWorkerState entity.TaskWorkerState, tx *sql.Tx) error {
	if mock.AddTaskExecWorkerFunc == nil {
		panic("RepositoryMock.AddTaskExecWorkerFunc: method is nil but Repository.AddTaskExecWorker was just called")
	}
	callInfo := struct {
		Ctx                context.Context
		TaskID             string
		NewJobID           string
		WorkerID           int
		InitialWorkerState entity.TaskWorkerState
		Tx                 *sql.Tx
	}{
		Ctx:                ctx,
		TaskID:             taskID,
		NewJobID:           newJobID,
		WorkerID:           workerID,
		InitialWorkerState: initialWorkerState,
		Tx:                 tx,
	}
	mock.lockAddTaskExecWorker.Lock()
	mock.calls.AddTaskExecWorker = append(mock.calls.AddTaskExecWorker, callInfo)
	mock.lockAddTaskExecWorker.Unlock()
	return mock.AddTaskExecWorkerFunc(ctx, taskID, newJobID, workerID, initialWorkerState, tx)
}

// AddTaskExecWorkerCalls gets all the calls that were made to AddTaskExecWorker.
// Check the length with:
//
//	len(mockedRepository.AddTaskExecWorkerCalls())
func (mock *RepositoryMock) AddTaskExecWorkerCalls() []struct {
	Ctx                context.Context
	TaskID             string
	NewJobID           string
	WorkerID           int
	InitialWorkerState entity.TaskWorkerState
	Tx                 *sql.Tx
} {
	var calls []struct {
		Ctx                context.Context
		TaskID             string
		NewJobID           string
		WorkerID           int
		InitialWorkerState entity.TaskWorkerState
		Tx                 *sql.Tx
	}
	mock.lockAddTaskExecWorker.RLock()
	calls = mock.calls.AddTaskExecWorker
	mock.lockAddTaskExecWorker.RUnlock()
	return calls
}

// CancelOrganizationInvitation calls CancelOrganizationInvitationFunc.
func (mock *RepositoryMock) CancelOrganizationInvitation(ctx context.Context, organizationID string, email string) error {
	if mock.CancelOrganizationInvitationFunc == nil {
		panic("RepositoryMock.CancelOrganizationInvitationFunc: method is nil but Repository.CancelOrganizationInvitation was just called")
	}
	callInfo := struct {
		Ctx            context.Context
		OrganizationID string
		Email          string
	}{
		Ctx:            ctx,
		OrganizationID: organizationID,
		Email:          email,
	}
	mock.lockCancelOrganizationInvitation.Lock()
	mock.calls.CancelOrganizationInvitation = append(mock.calls.CancelOrganizationInvitation, callInfo)
	mock.lockCancelOrganizationInvitation.Unlock()
	return mock.CancelOrganizationInvitationFunc(ctx, organizationID, email)
}

// CancelOrganizationInvitationCalls gets all the calls that were made to CancelOrganizationInvitation.
// Check the length with:
//
//	len(mockedRepository.CancelOrganizationInvitationCalls())
func (mock *RepositoryMock) CancelOrganizationInvitationCalls() []struct {
	Ctx            context.Context
	OrganizationID string
	Email          string
} {
	var calls []struct {
		Ctx            context.Context
		OrganizationID string
		Email          string
	}
	mock.lockCancelOrganizationInvitation.RLock()
	calls = mock.calls.CancelOrganizationInvitation
	mock.lockCancelOrganizationInvitation.RUnlock()
	return calls
}

// CleanAfterUserAlias calls CleanAfterUserAliasFunc.
func (mock *RepositoryMock) CleanAfterUserAlias(workspaceID string, fromUserExternalID string) error {
	if mock.CleanAfterUserAliasFunc == nil {
		panic("RepositoryMock.CleanAfterUserAliasFunc: method is nil but Repository.CleanAfterUserAlias was just called")
	}
	callInfo := struct {
		WorkspaceID        string
		FromUserExternalID string
	}{
		WorkspaceID:        workspaceID,
		FromUserExternalID: fromUserExternalID,
	}
	mock.lockCleanAfterUserAlias.Lock()
	mock.calls.CleanAfterUserAlias = append(mock.calls.CleanAfterUserAlias, callInfo)
	mock.lockCleanAfterUserAlias.Unlock()
	return mock.CleanAfterUserAliasFunc(workspaceID, fromUserExternalID)
}

// CleanAfterUserAliasCalls gets all the calls that were made to CleanAfterUserAlias.
// Check the length with:
//
//	len(mockedRepository.CleanAfterUserAliasCalls())
func (mock *RepositoryMock) CleanAfterUserAliasCalls() []struct {
	WorkspaceID        string
	FromUserExternalID string
} {
	var calls []struct {
		WorkspaceID        string
		FromUserExternalID string
	}
	mock.lockCleanAfterUserAlias.RLock()
	calls = mock.calls.CleanAfterUserAlias
	mock.lockCleanAfterUserAlias.RUnlock()
	return calls
}

// ClearUserSegmentQueue calls ClearUserSegmentQueueFunc.
func (mock *RepositoryMock) ClearUserSegmentQueue(ctx context.Context, workspaceID string, segmentID string, segmentVersion int) error {
	if mock.ClearUserSegmentQueueFunc == nil {
		panic("RepositoryMock.ClearUserSegmentQueueFunc: method is nil but Repository.ClearUserSegmentQueue was just called")
	}
	callInfo := struct {
		Ctx            context.Context
		WorkspaceID    string
		SegmentID      string
		SegmentVersion int
	}{
		Ctx:            ctx,
		WorkspaceID:    workspaceID,
		SegmentID:      segmentID,
		SegmentVersion: segmentVersion,
	}
	mock.lockClearUserSegmentQueue.Lock()
	mock.calls.ClearUserSegmentQueue = append(mock.calls.ClearUserSegmentQueue, callInfo)
	mock.lockClearUserSegmentQueue.Unlock()
	return mock.ClearUserSegmentQueueFunc(ctx, workspaceID, segmentID, segmentVersion)
}

// ClearUserSegmentQueueCalls gets all the calls that were made to ClearUserSegmentQueue.
// Check the length with:
//
//	len(mockedRepository.ClearUserSegmentQueueCalls())
func (mock *RepositoryMock) ClearUserSegmentQueueCalls() []struct {
	Ctx            context.Context
	WorkspaceID    string
	SegmentID      string
	SegmentVersion int
} {
	var calls []struct {
		Ctx            context.Context
		WorkspaceID    string
		SegmentID      string
		SegmentVersion int
	}
	mock.lockClearUserSegmentQueue.RLock()
	calls = mock.calls.ClearUserSegmentQueue
	mock.lockClearUserSegmentQueue.RUnlock()
	return calls
}

// ConsumeInvitation calls ConsumeInvitationFunc.
func (mock *RepositoryMock) ConsumeInvitation(ctx context.Context, accountID string, insertAccount *entity.Account, invitation *entity.OrganizationInvitation) error {
	if mock.ConsumeInvitationFunc == nil {
		panic("RepositoryMock.ConsumeInvitationFunc: method is nil but Repository.ConsumeInvitation was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		AccountID     string
		InsertAccount *entity.Account
		Invitation    *entity.OrganizationInvitation
	}{
		Ctx:           ctx,
		AccountID:     accountID,
		InsertAccount: insertAccount,
		Invitation:    invitation,
	}
	mock.lockConsumeInvitation.Lock()
	mock.calls.ConsumeInvitation = append(mock.calls.ConsumeInvitation, callInfo)
	mock.lockConsumeInvitation.Unlock()
	return mock.ConsumeInvitationFunc(ctx, accountID, insertAccount, invitation)
}

// ConsumeInvitationCalls gets all the calls that were made to ConsumeInvitation.
// Check the length with:
//
//	len(mockedRepository.ConsumeInvitationCalls())
func (mock *RepositoryMock) ConsumeInvitationCalls() []struct {
	Ctx           context.Context
	AccountID     string
	InsertAccount *entity.Account
	Invitation    *entity.OrganizationInvitation
} {
	var calls []struct {
		Ctx           context.Context
		AccountID     string
		InsertAccount *entity.Account
		Invitation    *entity.OrganizationInvitation
	}
	mock.lockConsumeInvitation.RLock()
	calls = mock.calls.ConsumeInvitation
	mock.lockConsumeInvitation.RUnlock()
	return calls
}

// CountSuccessfulDataLogsForDemo calls CountSuccessfulDataLogsForDemoFunc.
func (mock *RepositoryMock) CountSuccessfulDataLogsForDemo(ctx context.Context, workspaceID string) (int64, error) {
	if mock.CountSuccessfulDataLogsForDemoFunc == nil {
		panic("RepositoryMock.CountSuccessfulDataLogsForDemoFunc: method is nil but Repository.CountSuccessfulDataLogsForDemo was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		WorkspaceID string
	}{
		Ctx:         ctx,
		WorkspaceID: workspaceID,
	}
	mock.lockCountSuccessfulDataLogsForDemo.Lock()
	mock.calls.CountSuccessfulDataLogsForDemo = append(mock.calls.CountSuccessfulDataLogsForDemo, callInfo)
	mock.lockCountSuccessfulDataLogsForDemo.Unlock()
	return mock.CountSuccessfulDataLogsForDemoFunc(ctx, workspaceID)
}

// CountSuccessfulDataLogsForDemoCalls gets all the calls that were made to CountSuccessfulDataLogsForDemo.
// Check the length with:
//
//	len(mockedRepository.CountSuccessfulDataLogsForDemoCalls())
func (mock *RepositoryMock) CountSuccessfulDataLogsForDemoCalls() []struct {
	Ctx         context.Context
	WorkspaceID string
} {
	var calls []struct {
		Ctx         context.Context
		WorkspaceID string
	}
	mock.lockCountSuccessfulDataLogsForDemo.RLock()
	calls = mock.calls.CountSuccessfulDataLogsForDemo
	mock.lockCountSuccessfulDataLogsForDemo.RUnlock()
	return calls
}

// CreateChannel calls CreateChannelFunc.
func (mock *RepositoryMock) CreateChannel(ctx context.Context, workspace *entity.Workspace, channel *entity.Channel) error {
	if mock.CreateChannelFunc == nil {
		panic("RepositoryMock.CreateChannelFunc: method is nil but Repository.CreateChannel was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Workspace *entity.Workspace
		Channel   *entity.Channel
	}{
		Ctx:       ctx,
		Workspace: workspace,
		Channel:   channel,
	}
	mock.lockCreateChannel.Lock()
	mock.calls.CreateChannel = append(mock.calls.CreateChannel, callInfo)
	mock.lockCreateChannel.Unlock()
	return mock.CreateChannelFunc(ctx, workspace, channel)
}

// CreateChannelCalls gets all the calls that were made to CreateChannel.
// Check the length with:
//
//	len(mockedRepository.CreateChannelCalls())
func (mock *RepositoryMock) CreateChannelCalls() []struct {
	Ctx       context.Context
	Workspace *entity.Workspace
	Channel   *entity.Channel
} {
	var calls []struct {
		Ctx       context.Context
		Workspace *entity.Workspace
		Channel   *entity.Channel
	}
	mock.lockCreateChannel.RLock()
	calls = mock.calls.CreateChannel
	mock.lockCreateChannel.RUnlock()
	return calls
}

// CreateOrganization calls CreateOrganizationFunc.
func (mock *RepositoryMock) CreateOrganization(ctx context.Context, organization *entity.Organization, tx *sql.Tx) error {
	if mock.CreateOrganizationFunc == nil {
		panic("RepositoryMock.CreateOrganizationFunc: method is nil but Repository.CreateOrganization was just called")
	}
	callInfo := struct {
		Ctx          context.Context
		Organization *entity.Organization
		Tx           *sql.Tx
	}{
		Ctx:          ctx,
		Organization: organization,
		Tx:           tx,
	}
	mock.lockCreateOrganization.Lock()
	mock.calls.CreateOrganization = append(mock.calls.CreateOrganization, callInfo)
	mock.lockCreateOrganization.Unlock()
	return mock.CreateOrganizationFunc(ctx, organization, tx)
}

// CreateOrganizationCalls gets all the calls that were made to CreateOrganization.
// Check the length with:
//
//	len(mockedRepository.CreateOrganizationCalls())
func (mock *RepositoryMock) CreateOrganizationCalls() []struct {
	Ctx          context.Context
	Organization *entity.Organization
	Tx           *sql.Tx
} {
	var calls []struct {
		Ctx          context.Context
		Organization *entity.Organization
		Tx           *sql.Tx
	}
	mock.lockCreateOrganization.RLock()
	calls = mock.calls.CreateOrganization
	mock.lockCreateOrganization.RUnlock()
	return calls
}

// CreateSubscriptionList calls CreateSubscriptionListFunc.
func (mock *RepositoryMock) CreateSubscriptionList(ctx context.Context, workspaceID string, list *entity.SubscriptionList) error {
	if mock.CreateSubscriptionListFunc == nil {
		panic("RepositoryMock.CreateSubscriptionListFunc: method is nil but Repository.CreateSubscriptionList was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		WorkspaceID string
		List        *entity.SubscriptionList
	}{
		Ctx:         ctx,
		WorkspaceID: workspaceID,
		List:        list,
	}
	mock.lockCreateSubscriptionList.Lock()
	mock.calls.CreateSubscriptionList = append(mock.calls.CreateSubscriptionList, callInfo)
	mock.lockCreateSubscriptionList.Unlock()
	return mock.CreateSubscriptionListFunc(ctx, workspaceID, list)
}

// CreateSubscriptionListCalls gets all the calls that were made to CreateSubscriptionList.
// Check the length with:
//
//	len(mockedRepository.CreateSubscriptionListCalls())
func (mock *RepositoryMock) CreateSubscriptionListCalls() []struct {
	Ctx         context.Context
	WorkspaceID string
	List        *entity.SubscriptionList
} {
	var calls []struct {
		Ctx         context.Context
		WorkspaceID string
		List        *entity.SubscriptionList
	}
	mock.lockCreateSubscriptionList.RLock()
	calls = mock.calls.CreateSubscriptionList
	mock.lockCreateSubscriptionList.RUnlock()
	return calls
}

// CreateTable calls CreateTableFunc.
func (mock *RepositoryMock) CreateTable(ctx context.Context, workspace *entity.Workspace, table *entity.AppTableManifest) error {
	if mock.CreateTableFunc == nil {
		panic("RepositoryMock.CreateTableFunc: method is nil but Repository.CreateTable was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Workspace *entity.Workspace
		Table     *entity.AppTableManifest
	}{
		Ctx:       ctx,
		Workspace: workspace,
		Table:     table,
	}
	mock.lockCreateTable.Lock()
	mock.calls.CreateTable = append(mock.calls.CreateTable, callInfo)
	mock.lockCreateTable.Unlock()
	return mock.CreateTableFunc(ctx, workspace, table)
}

// CreateTableCalls gets all the calls that were made to CreateTable.
// Check the length with:
//
//	len(mockedRepository.CreateTableCalls())
func (mock *RepositoryMock) CreateTableCalls() []struct {
	Ctx       context.Context
	Workspace *entity.Workspace
	Table     *entity.AppTableManifest
} {
	var calls []struct {
		Ctx       context.Context
		Workspace *entity.Workspace
		Table     *entity.AppTableManifest
	}
	mock.lockCreateTable.RLock()
	calls = mock.calls.CreateTable
	mock.lockCreateTable.RUnlock()
	return calls
}

// CreateUserAlias calls CreateUserAliasFunc.
func (mock *RepositoryMock) CreateUserAlias(ctx context.Context, fromUserExternalID string, toUserExternalID string, toUserIsAuthenticated bool, tx *sql.Tx) error {
	if mock.CreateUserAliasFunc == nil {
		panic("RepositoryMock.CreateUserAliasFunc: method is nil but Repository.CreateUserAlias was just called")
	}
	callInfo := struct {
		Ctx                   context.Context
		FromUserExternalID    string
		ToUserExternalID      string
		ToUserIsAuthenticated bool
		Tx                    *sql.Tx
	}{
		Ctx:                   ctx,
		FromUserExternalID:    fromUserExternalID,
		ToUserExternalID:      toUserExternalID,
		ToUserIsAuthenticated: toUserIsAuthenticated,
		Tx:                    tx,
	}
	mock.lockCreateUserAlias.Lock()
	mock.calls.CreateUserAlias = append(mock.calls.CreateUserAlias, callInfo)
	mock.lockCreateUserAlias.Unlock()
	return mock.CreateUserAliasFunc(ctx, fromUserExternalID, toUserExternalID, toUserIsAuthenticated, tx)
}

// CreateUserAliasCalls gets all the calls that were made to CreateUserAlias.
// Check the length with:
//
//	len(mockedRepository.CreateUserAliasCalls())
func (mock *RepositoryMock) CreateUserAliasCalls() []struct {
	Ctx                   context.Context
	FromUserExternalID    string
	ToUserExternalID      string
	ToUserIsAuthenticated bool
	Tx                    *sql.Tx
} {
	var calls []struct {
		Ctx                   context.Context
		FromUserExternalID    string
		ToUserExternalID      string
		ToUserIsAuthenticated bool
		Tx                    *sql.Tx
	}
	mock.lockCreateUserAlias.RLock()
	calls = mock.calls.CreateUserAlias
	mock.lockCreateUserAlias.RUnlock()
	return calls
}

// CreateWorkspaceTables calls CreateWorkspaceTablesFunc.
func (mock *RepositoryMock) CreateWorkspaceTables(ctx context.Context, workspaceID string, tx *sql.Tx) error {
	if mock.CreateWorkspaceTablesFunc == nil {
		panic("RepositoryMock.CreateWorkspaceTablesFunc: method is nil but Repository.CreateWorkspaceTables was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		WorkspaceID string
		Tx          *sql.Tx
	}{
		Ctx:         ctx,
		WorkspaceID: workspaceID,
		Tx:          tx,
	}
	mock.lockCreateWorkspaceTables.Lock()
	mock.calls.CreateWorkspaceTables = append(mock.calls.CreateWorkspaceTables, callInfo)
	mock.lockCreateWorkspaceTables.Unlock()
	return mock.CreateWorkspaceTablesFunc(ctx, workspaceID, tx)
}

// CreateWorkspaceTablesCalls gets all the calls that were made to CreateWorkspaceTables.
// Check the length with:
//
//	len(mockedRepository.CreateWorkspaceTablesCalls())
func (mock *RepositoryMock) CreateWorkspaceTablesCalls() []struct {
	Ctx         context.Context
	WorkspaceID string
	Tx          *sql.Tx
} {
	var calls []struct {
		Ctx         context.Context
		WorkspaceID string
		Tx          *sql.Tx
	}
	mock.lockCreateWorkspaceTables.RLock()
	calls = mock.calls.CreateWorkspaceTables
	mock.lockCreateWorkspaceTables.RUnlock()
	return calls
}

// DeactivateOrganizationAccount calls DeactivateOrganizationAccountFunc.
func (mock *RepositoryMock) DeactivateOrganizationAccount(ctx context.Context, accountID string, deactivateAccountID string, organizationID string) error {
	if mock.DeactivateOrganizationAccountFunc == nil {
		panic("RepositoryMock.DeactivateOrganizationAccountFunc: method is nil but Repository.DeactivateOrganizationAccount was just called")
	}
	callInfo := struct {
		Ctx                 context.Context
		AccountID           string
		DeactivateAccountID string
		OrganizationID      string
	}{
		Ctx:                 ctx,
		AccountID:           accountID,
		DeactivateAccountID: deactivateAccountID,
		OrganizationID:      organizationID,
	}
	mock.lockDeactivateOrganizationAccount.Lock()
	mock.calls.DeactivateOrganizationAccount = append(mock.calls.DeactivateOrganizationAccount, callInfo)
	mock.lockDeactivateOrganizationAccount.Unlock()
	return mock.DeactivateOrganizationAccountFunc(ctx, accountID, deactivateAccountID, organizationID)
}

// DeactivateOrganizationAccountCalls gets all the calls that were made to DeactivateOrganizationAccount.
// Check the length with:
//
//	len(mockedRepository.DeactivateOrganizationAccountCalls())
func (mock *RepositoryMock) DeactivateOrganizationAccountCalls() []struct {
	Ctx                 context.Context
	AccountID           string
	DeactivateAccountID string
	OrganizationID      string
} {
	var calls []struct {
		Ctx                 context.Context
		AccountID           string
		DeactivateAccountID string
		OrganizationID      string
	}
	mock.lockDeactivateOrganizationAccount.RLock()
	calls = mock.calls.DeactivateOrganizationAccount
	mock.lockDeactivateOrganizationAccount.RUnlock()
	return calls
}

// DeleteApp calls DeleteAppFunc.
func (mock *RepositoryMock) DeleteApp(ctx context.Context, appID string, tx *sql.Tx) error {
	if mock.DeleteAppFunc == nil {
		panic("RepositoryMock.DeleteAppFunc: method is nil but Repository.DeleteApp was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		AppID string
		Tx    *sql.Tx
	}{
		Ctx:   ctx,
		AppID: appID,
		Tx:    tx,
	}
	mock.lockDeleteApp.Lock()
	mock.calls.DeleteApp = append(mock.calls.DeleteApp, callInfo)
	mock.lockDeleteApp.Unlock()
	return mock.DeleteAppFunc(ctx, appID, tx)
}

// DeleteAppCalls gets all the calls that were made to DeleteApp.
// Check the length with:
//
//	len(mockedRepository.DeleteAppCalls())
func (mock *RepositoryMock) DeleteAppCalls() []struct {
	Ctx   context.Context
	AppID string
	Tx    *sql.Tx
} {
	var calls []struct {
		Ctx   context.Context
		AppID string
		Tx    *sql.Tx
	}
	mock.lockDeleteApp.RLock()
	calls = mock.calls.DeleteApp
	mock.lockDeleteApp.RUnlock()
	return calls
}

// DeleteAppItemByExternalID calls DeleteAppItemByExternalIDFunc.
func (mock *RepositoryMock) DeleteAppItemByExternalID(ctx context.Context, workspace *entity.Workspace, kind string, externalID string, tx *sql.Tx) error {
	if mock.DeleteAppItemByExternalIDFunc == nil {
		panic("RepositoryMock.DeleteAppItemByExternalIDFunc: method is nil but Repository.DeleteAppItemByExternalID was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Workspace  *entity.Workspace
		Kind       string
		ExternalID string
		Tx         *sql.Tx
	}{
		Ctx:        ctx,
		Workspace:  workspace,
		Kind:       kind,
		ExternalID: externalID,
		Tx:         tx,
	}
	mock.lockDeleteAppItemByExternalID.Lock()
	mock.calls.DeleteAppItemByExternalID = append(mock.calls.DeleteAppItemByExternalID, callInfo)
	mock.lockDeleteAppItemByExternalID.Unlock()
	return mock.DeleteAppItemByExternalIDFunc(ctx, workspace, kind, externalID, tx)
}

// DeleteAppItemByExternalIDCalls gets all the calls that were made to DeleteAppItemByExternalID.
// Check the length with:
//
//	len(mockedRepository.DeleteAppItemByExternalIDCalls())
func (mock *RepositoryMock) DeleteAppItemByExternalIDCalls() []struct {
	Ctx        context.Context
	Workspace  *entity.Workspace
	Kind       string
	ExternalID string
	Tx         *sql.Tx
} {
	var calls []struct {
		Ctx        context.Context
		Workspace  *entity.Workspace
		Kind       string
		ExternalID string
		Tx         *sql.Tx
	}
	mock.lockDeleteAppItemByExternalID.RLock()
	calls = mock.calls.DeleteAppItemByExternalID
	mock.lockDeleteAppItemByExternalID.RUnlock()
	return calls
}

// DeleteAppItemByID calls DeleteAppItemByIDFunc.
func (mock *RepositoryMock) DeleteAppItemByID(ctx context.Context, workspace *entity.Workspace, kind string, ID string, tx *sql.Tx) error {
	if mock.DeleteAppItemByIDFunc == nil {
		panic("RepositoryMock.DeleteAppItemByIDFunc: method is nil but Repository.DeleteAppItemByID was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Workspace *entity.Workspace
		Kind      string
		ID        string
		Tx        *sql.Tx
	}{
		Ctx:       ctx,
		Workspace: workspace,
		Kind:      kind,
		ID:        ID,
		Tx:        tx,
	}
	mock.lockDeleteAppItemByID.Lock()
	mock.calls.DeleteAppItemByID = append(mock.calls.DeleteAppItemByID, callInfo)
	mock.lockDeleteAppItemByID.Unlock()
	return mock.DeleteAppItemByIDFunc(ctx, workspace, kind, ID, tx)
}

// DeleteAppItemByIDCalls gets all the calls that were made to DeleteAppItemByID.
// Check the length with:
//
//	len(mockedRepository.DeleteAppItemByIDCalls())
func (mock *RepositoryMock) DeleteAppItemByIDCalls() []struct {
	Ctx       context.Context
	Workspace *entity.Workspace
	Kind      string
	ID        string
	Tx        *sql.Tx
} {
	var calls []struct {
		Ctx       context.Context
		Workspace *entity.Workspace
		Kind      string
		ID        string
		Tx        *sql.Tx
	}
	mock.lockDeleteAppItemByID.RLock()
	calls = mock.calls.DeleteAppItemByID
	mock.lockDeleteAppItemByID.RUnlock()
	return calls
}

// DeleteAppTasks calls DeleteAppTasksFunc.
func (mock *RepositoryMock) DeleteAppTasks(ctx context.Context, workspaceID string, appID string, tx *sql.Tx) error {
	if mock.DeleteAppTasksFunc == nil {
		panic("RepositoryMock.DeleteAppTasksFunc: method is nil but Repository.DeleteAppTasks was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		WorkspaceID string
		AppID       string
		Tx          *sql.Tx
	}{
		Ctx:         ctx,
		WorkspaceID: workspaceID,
		AppID:       appID,
		Tx:          tx,
	}
	mock.lockDeleteAppTasks.Lock()
	mock.calls.DeleteAppTasks = append(mock.calls.DeleteAppTasks, callInfo)
	mock.lockDeleteAppTasks.Unlock()
	return mock.DeleteAppTasksFunc(ctx, workspaceID, appID, tx)
}

// DeleteAppTasksCalls gets all the calls that were made to DeleteAppTasks.
// Check the length with:
//
//	len(mockedRepository.DeleteAppTasksCalls())
func (mock *RepositoryMock) DeleteAppTasksCalls() []struct {
	Ctx         context.Context
	WorkspaceID string
	AppID       string
	Tx          *sql.Tx
} {
	var calls []struct {
		Ctx         context.Context
		WorkspaceID string
		AppID       string
		Tx          *sql.Tx
	}
	mock.lockDeleteAppTasks.RLock()
	calls = mock.calls.DeleteAppTasks
	mock.lockDeleteAppTasks.RUnlock()
	return calls
}

// DeleteCartItem calls DeleteCartItemFunc.
func (mock *RepositoryMock) DeleteCartItem(ctx context.Context, cartItemID string, userID string, tx *sql.Tx) error {
	if mock.DeleteCartItemFunc == nil {
		panic("RepositoryMock.DeleteCartItemFunc: method is nil but Repository.DeleteCartItem was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		CartItemID string
		UserID     string
		Tx         *sql.Tx
	}{
		Ctx:        ctx,
		CartItemID: cartItemID,
		UserID:     userID,
		Tx:         tx,
	}
	mock.lockDeleteCartItem.Lock()
	mock.calls.DeleteCartItem = append(mock.calls.DeleteCartItem, callInfo)
	mock.lockDeleteCartItem.Unlock()
	return mock.DeleteCartItemFunc(ctx, cartItemID, userID, tx)
}

// DeleteCartItemCalls gets all the calls that were made to DeleteCartItem.
// Check the length with:
//
//	len(mockedRepository.DeleteCartItemCalls())
func (mock *RepositoryMock) DeleteCartItemCalls() []struct {
	Ctx        context.Context
	CartItemID string
	UserID     string
	Tx         *sql.Tx
} {
	var calls []struct {
		Ctx        context.Context
		CartItemID string
		UserID     string
		Tx         *sql.Tx
	}
	mock.lockDeleteCartItem.RLock()
	calls = mock.calls.DeleteCartItem
	mock.lockDeleteCartItem.RUnlock()
	return calls
}

// DeleteChannel calls DeleteChannelFunc.
func (mock *RepositoryMock) DeleteChannel(ctx context.Context, workspace *entity.Workspace, deletedChannelID string) error {
	if mock.DeleteChannelFunc == nil {
		panic("RepositoryMock.DeleteChannelFunc: method is nil but Repository.DeleteChannel was just called")
	}
	callInfo := struct {
		Ctx              context.Context
		Workspace        *entity.Workspace
		DeletedChannelID string
	}{
		Ctx:              ctx,
		Workspace:        workspace,
		DeletedChannelID: deletedChannelID,
	}
	mock.lockDeleteChannel.Lock()
	mock.calls.DeleteChannel = append(mock.calls.DeleteChannel, callInfo)
	mock.lockDeleteChannel.Unlock()
	return mock.DeleteChannelFunc(ctx, workspace, deletedChannelID)
}

// DeleteChannelCalls gets all the calls that were made to DeleteChannel.
// Check the length with:
//
//	len(mockedRepository.DeleteChannelCalls())
func (mock *RepositoryMock) DeleteChannelCalls() []struct {
	Ctx              context.Context
	Workspace        *entity.Workspace
	DeletedChannelID string
} {
	var calls []struct {
		Ctx              context.Context
		Workspace        *entity.Workspace
		DeletedChannelID string
	}
	mock.lockDeleteChannel.RLock()
	calls = mock.calls.DeleteChannel
	mock.lockDeleteChannel.RUnlock()
	return calls
}

// DeleteColumn calls DeleteColumnFunc.
func (mock *RepositoryMock) DeleteColumn(ctx context.Context, workspace *entity.Workspace, tableName string, column *entity.TableColumn) error {
	if mock.DeleteColumnFunc == nil {
		panic("RepositoryMock.DeleteColumnFunc: method is nil but Repository.DeleteColumn was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Workspace *entity.Workspace
		TableName string
		Column    *entity.TableColumn
	}{
		Ctx:       ctx,
		Workspace: workspace,
		TableName: tableName,
		Column:    column,
	}
	mock.lockDeleteColumn.Lock()
	mock.calls.DeleteColumn = append(mock.calls.DeleteColumn, callInfo)
	mock.lockDeleteColumn.Unlock()
	return mock.DeleteColumnFunc(ctx, workspace, tableName, column)
}

// DeleteColumnCalls gets all the calls that were made to DeleteColumn.
// Check the length with:
//
//	len(mockedRepository.DeleteColumnCalls())
func (mock *RepositoryMock) DeleteColumnCalls() []struct {
	Ctx       context.Context
	Workspace *entity.Workspace
	TableName string
	Column    *entity.TableColumn
} {
	var calls []struct {
		Ctx       context.Context
		Workspace *entity.Workspace
		TableName string
		Column    *entity.TableColumn
	}
	mock.lockDeleteColumn.RLock()
	calls = mock.calls.DeleteColumn
	mock.lockDeleteColumn.RUnlock()
	return calls
}

// DeleteDomain calls DeleteDomainFunc.
func (mock *RepositoryMock) DeleteDomain(ctx context.Context, workspace *entity.Workspace, deletedDomainID string, migrateToDomainID string) error {
	if mock.DeleteDomainFunc == nil {
		panic("RepositoryMock.DeleteDomainFunc: method is nil but Repository.DeleteDomain was just called")
	}
	callInfo := struct {
		Ctx               context.Context
		Workspace         *entity.Workspace
		DeletedDomainID   string
		MigrateToDomainID string
	}{
		Ctx:               ctx,
		Workspace:         workspace,
		DeletedDomainID:   deletedDomainID,
		MigrateToDomainID: migrateToDomainID,
	}
	mock.lockDeleteDomain.Lock()
	mock.calls.DeleteDomain = append(mock.calls.DeleteDomain, callInfo)
	mock.lockDeleteDomain.Unlock()
	return mock.DeleteDomainFunc(ctx, workspace, deletedDomainID, migrateToDomainID)
}

// DeleteDomainCalls gets all the calls that were made to DeleteDomain.
// Check the length with:
//
//	len(mockedRepository.DeleteDomainCalls())
func (mock *RepositoryMock) DeleteDomainCalls() []struct {
	Ctx               context.Context
	Workspace         *entity.Workspace
	DeletedDomainID   string
	MigrateToDomainID string
} {
	var calls []struct {
		Ctx               context.Context
		Workspace         *entity.Workspace
		DeletedDomainID   string
		MigrateToDomainID string
	}
	mock.lockDeleteDomain.RLock()
	calls = mock.calls.DeleteDomain
	mock.lockDeleteDomain.RUnlock()
	return calls
}

// DeleteOrderItem calls DeleteOrderItemFunc.
func (mock *RepositoryMock) DeleteOrderItem(ctx context.Context, orderItemID string, userID string, tx *sql.Tx) error {
	if mock.DeleteOrderItemFunc == nil {
		panic("RepositoryMock.DeleteOrderItemFunc: method is nil but Repository.DeleteOrderItem was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		OrderItemID string
		UserID      string
		Tx          *sql.Tx
	}{
		Ctx:         ctx,
		OrderItemID: orderItemID,
		UserID:      userID,
		Tx:          tx,
	}
	mock.lockDeleteOrderItem.Lock()
	mock.calls.DeleteOrderItem = append(mock.calls.DeleteOrderItem, callInfo)
	mock.lockDeleteOrderItem.Unlock()
	return mock.DeleteOrderItemFunc(ctx, orderItemID, userID, tx)
}

// DeleteOrderItemCalls gets all the calls that were made to DeleteOrderItem.
// Check the length with:
//
//	len(mockedRepository.DeleteOrderItemCalls())
func (mock *RepositoryMock) DeleteOrderItemCalls() []struct {
	Ctx         context.Context
	OrderItemID string
	UserID      string
	Tx          *sql.Tx
} {
	var calls []struct {
		Ctx         context.Context
		OrderItemID string
		UserID      string
		Tx          *sql.Tx
	}
	mock.lockDeleteOrderItem.RLock()
	calls = mock.calls.DeleteOrderItem
	mock.lockDeleteOrderItem.RUnlock()
	return calls
}

// DeleteSegment calls DeleteSegmentFunc.
func (mock *RepositoryMock) DeleteSegment(ctx context.Context, workspaceID string, segmentID string) error {
	if mock.DeleteSegmentFunc == nil {
		panic("RepositoryMock.DeleteSegmentFunc: method is nil but Repository.DeleteSegment was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		WorkspaceID string
		SegmentID   string
	}{
		Ctx:         ctx,
		WorkspaceID: workspaceID,
		SegmentID:   segmentID,
	}
	mock.lockDeleteSegment.Lock()
	mock.calls.DeleteSegment = append(mock.calls.DeleteSegment, callInfo)
	mock.lockDeleteSegment.Unlock()
	return mock.DeleteSegmentFunc(ctx, workspaceID, segmentID)
}

// DeleteSegmentCalls gets all the calls that were made to DeleteSegment.
// Check the length with:
//
//	len(mockedRepository.DeleteSegmentCalls())
func (mock *RepositoryMock) DeleteSegmentCalls() []struct {
	Ctx         context.Context
	WorkspaceID string
	SegmentID   string
} {
	var calls []struct {
		Ctx         context.Context
		WorkspaceID string
		SegmentID   string
	}
	mock.lockDeleteSegment.RLock()
	calls = mock.calls.DeleteSegment
	mock.lockDeleteSegment.RUnlock()
	return calls
}

// DeleteTable calls DeleteTableFunc.
func (mock *RepositoryMock) DeleteTable(ctx context.Context, workspaceID string, tableName string) error {
	if mock.DeleteTableFunc == nil {
		panic("RepositoryMock.DeleteTableFunc: method is nil but Repository.DeleteTable was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		WorkspaceID string
		TableName   string
	}{
		Ctx:         ctx,
		WorkspaceID: workspaceID,
		TableName:   tableName,
	}
	mock.lockDeleteTable.Lock()
	mock.calls.DeleteTable = append(mock.calls.DeleteTable, callInfo)
	mock.lockDeleteTable.Unlock()
	return mock.DeleteTableFunc(ctx, workspaceID, tableName)
}

// DeleteTableCalls gets all the calls that were made to DeleteTable.
// Check the length with:
//
//	len(mockedRepository.DeleteTableCalls())
func (mock *RepositoryMock) DeleteTableCalls() []struct {
	Ctx         context.Context
	WorkspaceID string
	TableName   string
} {
	var calls []struct {
		Ctx         context.Context
		WorkspaceID string
		TableName   string
	}
	mock.lockDeleteTable.RLock()
	calls = mock.calls.DeleteTable
	mock.lockDeleteTable.RUnlock()
	return calls
}

// DeleteUserSegment calls DeleteUserSegmentFunc.
func (mock *RepositoryMock) DeleteUserSegment(ctx context.Context, userID string, segmentID string, tx *sql.Tx) error {
	if mock.DeleteUserSegmentFunc == nil {
		panic("RepositoryMock.DeleteUserSegmentFunc: method is nil but Repository.DeleteUserSegment was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		UserID    string
		SegmentID string
		Tx        *sql.Tx
	}{
		Ctx:       ctx,
		UserID:    userID,
		SegmentID: segmentID,
		Tx:        tx,
	}
	mock.lockDeleteUserSegment.Lock()
	mock.calls.DeleteUserSegment = append(mock.calls.DeleteUserSegment, callInfo)
	mock.lockDeleteUserSegment.Unlock()
	return mock.DeleteUserSegmentFunc(ctx, userID, segmentID, tx)
}

// DeleteUserSegmentCalls gets all the calls that were made to DeleteUserSegment.
// Check the length with:
//
//	len(mockedRepository.DeleteUserSegmentCalls())
func (mock *RepositoryMock) DeleteUserSegmentCalls() []struct {
	Ctx       context.Context
	UserID    string
	SegmentID string
	Tx        *sql.Tx
} {
	var calls []struct {
		Ctx       context.Context
		UserID    string
		SegmentID string
		Tx        *sql.Tx
	}
	mock.lockDeleteUserSegment.RLock()
	calls = mock.calls.DeleteUserSegment
	mock.lockDeleteUserSegment.RUnlock()
	return calls
}

// DeleteUserSegmentQueueRow calls DeleteUserSegmentQueueRowFunc.
func (mock *RepositoryMock) DeleteUserSegmentQueueRow(ctx context.Context, workspaceID string, segmentID string, segmentVersion int, userID string, tx *sql.Tx) error {
	if mock.DeleteUserSegmentQueueRowFunc == nil {
		panic("RepositoryMock.DeleteUserSegmentQueueRowFunc: method is nil but Repository.DeleteUserSegmentQueueRow was just called")
	}
	callInfo := struct {
		Ctx            context.Context
		WorkspaceID    string
		SegmentID      string
		SegmentVersion int
		UserID         string
		Tx             *sql.Tx
	}{
		Ctx:            ctx,
		WorkspaceID:    workspaceID,
		SegmentID:      segmentID,
		SegmentVersion: segmentVersion,
		UserID:         userID,
		Tx:             tx,
	}
	mock.lockDeleteUserSegmentQueueRow.Lock()
	mock.calls.DeleteUserSegmentQueueRow = append(mock.calls.DeleteUserSegmentQueueRow, callInfo)
	mock.lockDeleteUserSegmentQueueRow.Unlock()
	return mock.DeleteUserSegmentQueueRowFunc(ctx, workspaceID, segmentID, segmentVersion, userID, tx)
}

// DeleteUserSegmentQueueRowCalls gets all the calls that were made to DeleteUserSegmentQueueRow.
// Check the length with:
//
//	len(mockedRepository.DeleteUserSegmentQueueRowCalls())
func (mock *RepositoryMock) DeleteUserSegmentQueueRowCalls() []struct {
	Ctx            context.Context
	WorkspaceID    string
	SegmentID      string
	SegmentVersion int
	UserID         string
	Tx             *sql.Tx
} {
	var calls []struct {
		Ctx            context.Context
		WorkspaceID    string
		SegmentID      string
		SegmentVersion int
		UserID         string
		Tx             *sql.Tx
	}
	mock.lockDeleteUserSegmentQueueRow.RLock()
	calls = mock.calls.DeleteUserSegmentQueueRow
	mock.lockDeleteUserSegmentQueueRow.RUnlock()
	return calls
}

// DeleteWorkspace calls DeleteWorkspaceFunc.
func (mock *RepositoryMock) DeleteWorkspace(ctx context.Context, workspaceID string) error {
	if mock.DeleteWorkspaceFunc == nil {
		panic("RepositoryMock.DeleteWorkspaceFunc: method is nil but Repository.DeleteWorkspace was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		WorkspaceID string
	}{
		Ctx:         ctx,
		WorkspaceID: workspaceID,
	}
	mock.lockDeleteWorkspace.Lock()
	mock.calls.DeleteWorkspace = append(mock.calls.DeleteWorkspace, callInfo)
	mock.lockDeleteWorkspace.Unlock()
	return mock.DeleteWorkspaceFunc(ctx, workspaceID)
}

// DeleteWorkspaceCalls gets all the calls that were made to DeleteWorkspace.
// Check the length with:
//
//	len(mockedRepository.DeleteWorkspaceCalls())
func (mock *RepositoryMock) DeleteWorkspaceCalls() []struct {
	Ctx         context.Context
	WorkspaceID string
} {
	var calls []struct {
		Ctx         context.Context
		WorkspaceID string
	}
	mock.lockDeleteWorkspace.RLock()
	calls = mock.calls.DeleteWorkspace
	mock.lockDeleteWorkspace.RUnlock()
	return calls
}

// DevResetDB calls DevResetDBFunc.
func (mock *RepositoryMock) DevResetDB(ctx context.Context, rootAccount *entity.Account, defaultOrganization *entity.Organization) error {
	if mock.DevResetDBFunc == nil {
		panic("RepositoryMock.DevResetDBFunc: method is nil but Repository.DevResetDB was just called")
	}
	callInfo := struct {
		Ctx                 context.Context
		RootAccount         *entity.Account
		DefaultOrganization *entity.Organization
	}{
		Ctx:                 ctx,
		RootAccount:         rootAccount,
		DefaultOrganization: defaultOrganization,
	}
	mock.lockDevResetDB.Lock()
	mock.calls.DevResetDB = append(mock.calls.DevResetDB, callInfo)
	mock.lockDevResetDB.Unlock()
	return mock.DevResetDBFunc(ctx, rootAccount, defaultOrganization)
}

// DevResetDBCalls gets all the calls that were made to DevResetDB.
// Check the length with:
//
//	len(mockedRepository.DevResetDBCalls())
func (mock *RepositoryMock) DevResetDBCalls() []struct {
	Ctx                 context.Context
	RootAccount         *entity.Account
	DefaultOrganization *entity.Organization
} {
	var calls []struct {
		Ctx                 context.Context
		RootAccount         *entity.Account
		DefaultOrganization *entity.Organization
	}
	mock.lockDevResetDB.RLock()
	calls = mock.calls.DevResetDB
	mock.lockDevResetDB.RUnlock()
	return calls
}

// EnqueueMatchingSegmentUsers calls EnqueueMatchingSegmentUsersFunc.
func (mock *RepositoryMock) EnqueueMatchingSegmentUsers(ctx context.Context, workspaceID string, segment *entity.Segment) (int, int, error) {
	if mock.EnqueueMatchingSegmentUsersFunc == nil {
		panic("RepositoryMock.EnqueueMatchingSegmentUsersFunc: method is nil but Repository.EnqueueMatchingSegmentUsers was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		WorkspaceID string
		Segment     *entity.Segment
	}{
		Ctx:         ctx,
		WorkspaceID: workspaceID,
		Segment:     segment,
	}
	mock.lockEnqueueMatchingSegmentUsers.Lock()
	mock.calls.EnqueueMatchingSegmentUsers = append(mock.calls.EnqueueMatchingSegmentUsers, callInfo)
	mock.lockEnqueueMatchingSegmentUsers.Unlock()
	return mock.EnqueueMatchingSegmentUsersFunc(ctx, workspaceID, segment)
}

// EnqueueMatchingSegmentUsersCalls gets all the calls that were made to EnqueueMatchingSegmentUsers.
// Check the length with:
//
//	len(mockedRepository.EnqueueMatchingSegmentUsersCalls())
func (mock *RepositoryMock) EnqueueMatchingSegmentUsersCalls() []struct {
	Ctx         context.Context
	WorkspaceID string
	Segment     *entity.Segment
} {
	var calls []struct {
		Ctx         context.Context
		WorkspaceID string
		Segment     *entity.Segment
	}
	mock.lockEnqueueMatchingSegmentUsers.RLock()
	calls = mock.calls.EnqueueMatchingSegmentUsers
	mock.lockEnqueueMatchingSegmentUsers.RUnlock()
	return calls
}

// EnsureUsersLock calls EnsureUsersLockFunc.
func (mock *RepositoryMock) EnsureUsersLock(ctx context.Context, workspaceID string, lock *entity.UsersLock, withRetry bool) error {
	if mock.EnsureUsersLockFunc == nil {
		panic("RepositoryMock.EnsureUsersLockFunc: method is nil but Repository.EnsureUsersLock was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		WorkspaceID string
		Lock        *entity.UsersLock
		WithRetry   bool
	}{
		Ctx:         ctx,
		WorkspaceID: workspaceID,
		Lock:        lock,
		WithRetry:   withRetry,
	}
	mock.lockEnsureUsersLock.Lock()
	mock.calls.EnsureUsersLock = append(mock.calls.EnsureUsersLock, callInfo)
	mock.lockEnsureUsersLock.Unlock()
	return mock.EnsureUsersLockFunc(ctx, workspaceID, lock, withRetry)
}

// EnsureUsersLockCalls gets all the calls that were made to EnsureUsersLock.
// Check the length with:
//
//	len(mockedRepository.EnsureUsersLockCalls())
func (mock *RepositoryMock) EnsureUsersLockCalls() []struct {
	Ctx         context.Context
	WorkspaceID string
	Lock        *entity.UsersLock
	WithRetry   bool
} {
	var calls []struct {
		Ctx         context.Context
		WorkspaceID string
		Lock        *entity.UsersLock
		WithRetry   bool
	}
	mock.lockEnsureUsersLock.RLock()
	calls = mock.calls.EnsureUsersLock
	mock.lockEnsureUsersLock.RUnlock()
	return calls
}

// EnterUserSegmentFromQueue calls EnterUserSegmentFromQueueFunc.
func (mock *RepositoryMock) EnterUserSegmentFromQueue(ctx context.Context, workspaceID string, segmentID string, segmentVersion int) error {
	if mock.EnterUserSegmentFromQueueFunc == nil {
		panic("RepositoryMock.EnterUserSegmentFromQueueFunc: method is nil but Repository.EnterUserSegmentFromQueue was just called")
	}
	callInfo := struct {
		Ctx            context.Context
		WorkspaceID    string
		SegmentID      string
		SegmentVersion int
	}{
		Ctx:            ctx,
		WorkspaceID:    workspaceID,
		SegmentID:      segmentID,
		SegmentVersion: segmentVersion,
	}
	mock.lockEnterUserSegmentFromQueue.Lock()
	mock.calls.EnterUserSegmentFromQueue = append(mock.calls.EnterUserSegmentFromQueue, callInfo)
	mock.lockEnterUserSegmentFromQueue.Unlock()
	return mock.EnterUserSegmentFromQueueFunc(ctx, workspaceID, segmentID, segmentVersion)
}

// EnterUserSegmentFromQueueCalls gets all the calls that were made to EnterUserSegmentFromQueue.
// Check the length with:
//
//	len(mockedRepository.EnterUserSegmentFromQueueCalls())
func (mock *RepositoryMock) EnterUserSegmentFromQueueCalls() []struct {
	Ctx            context.Context
	WorkspaceID    string
	SegmentID      string
	SegmentVersion int
} {
	var calls []struct {
		Ctx            context.Context
		WorkspaceID    string
		SegmentID      string
		SegmentVersion int
	}
	mock.lockEnterUserSegmentFromQueue.RLock()
	calls = mock.calls.EnterUserSegmentFromQueue
	mock.lockEnterUserSegmentFromQueue.RUnlock()
	return calls
}

// ExitUserSegmentFromQueue calls ExitUserSegmentFromQueueFunc.
func (mock *RepositoryMock) ExitUserSegmentFromQueue(ctx context.Context, workspaceID string, segmentID string, segmentVersion int) error {
	if mock.ExitUserSegmentFromQueueFunc == nil {
		panic("RepositoryMock.ExitUserSegmentFromQueueFunc: method is nil but Repository.ExitUserSegmentFromQueue was just called")
	}
	callInfo := struct {
		Ctx            context.Context
		WorkspaceID    string
		SegmentID      string
		SegmentVersion int
	}{
		Ctx:            ctx,
		WorkspaceID:    workspaceID,
		SegmentID:      segmentID,
		SegmentVersion: segmentVersion,
	}
	mock.lockExitUserSegmentFromQueue.Lock()
	mock.calls.ExitUserSegmentFromQueue = append(mock.calls.ExitUserSegmentFromQueue, callInfo)
	mock.lockExitUserSegmentFromQueue.Unlock()
	return mock.ExitUserSegmentFromQueueFunc(ctx, workspaceID, segmentID, segmentVersion)
}

// ExitUserSegmentFromQueueCalls gets all the calls that were made to ExitUserSegmentFromQueue.
// Check the length with:
//
//	len(mockedRepository.ExitUserSegmentFromQueueCalls())
func (mock *RepositoryMock) ExitUserSegmentFromQueueCalls() []struct {
	Ctx            context.Context
	WorkspaceID    string
	SegmentID      string
	SegmentVersion int
} {
	var calls []struct {
		Ctx            context.Context
		WorkspaceID    string
		SegmentID      string
		SegmentVersion int
	}
	mock.lockExitUserSegmentFromQueue.RLock()
	calls = mock.calls.ExitUserSegmentFromQueue
	mock.lockExitUserSegmentFromQueue.RUnlock()
	return calls
}

// FetchAppItems calls FetchAppItemsFunc.
func (mock *RepositoryMock) FetchAppItems(ctx context.Context, workspace *entity.Workspace, kind string, query sq.SelectBuilder, tx *sql.Tx) ([]*entity.AppItem, error) {
	if mock.FetchAppItemsFunc == nil {
		panic("RepositoryMock.FetchAppItemsFunc: method is nil but Repository.FetchAppItems was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Workspace *entity.Workspace
		Kind      string
		Query     sq.SelectBuilder
		Tx        *sql.Tx
	}{
		Ctx:       ctx,
		Workspace: workspace,
		Kind:      kind,
		Query:     query,
		Tx:        tx,
	}
	mock.lockFetchAppItems.Lock()
	mock.calls.FetchAppItems = append(mock.calls.FetchAppItems, callInfo)
	mock.lockFetchAppItems.Unlock()
	return mock.FetchAppItemsFunc(ctx, workspace, kind, query, tx)
}

// FetchAppItemsCalls gets all the calls that were made to FetchAppItems.
// Check the length with:
//
//	len(mockedRepository.FetchAppItemsCalls())
func (mock *RepositoryMock) FetchAppItemsCalls() []struct {
	Ctx       context.Context
	Workspace *entity.Workspace
	Kind      string
	Query     sq.SelectBuilder
	Tx        *sql.Tx
} {
	var calls []struct {
		Ctx       context.Context
		Workspace *entity.Workspace
		Kind      string
		Query     sq.SelectBuilder
		Tx        *sql.Tx
	}
	mock.lockFetchAppItems.RLock()
	calls = mock.calls.FetchAppItems
	mock.lockFetchAppItems.RUnlock()
	return calls
}

// FetchCustomEvents calls FetchCustomEventsFunc.
func (mock *RepositoryMock) FetchCustomEvents(ctx context.Context, workspace *entity.Workspace, query sq.SelectBuilder, tx *sql.Tx) ([]*entity.CustomEvent, error) {
	if mock.FetchCustomEventsFunc == nil {
		panic("RepositoryMock.FetchCustomEventsFunc: method is nil but Repository.FetchCustomEvents was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Workspace *entity.Workspace
		Query     sq.SelectBuilder
		Tx        *sql.Tx
	}{
		Ctx:       ctx,
		Workspace: workspace,
		Query:     query,
		Tx:        tx,
	}
	mock.lockFetchCustomEvents.Lock()
	mock.calls.FetchCustomEvents = append(mock.calls.FetchCustomEvents, callInfo)
	mock.lockFetchCustomEvents.Unlock()
	return mock.FetchCustomEventsFunc(ctx, workspace, query, tx)
}

// FetchCustomEventsCalls gets all the calls that were made to FetchCustomEvents.
// Check the length with:
//
//	len(mockedRepository.FetchCustomEventsCalls())
func (mock *RepositoryMock) FetchCustomEventsCalls() []struct {
	Ctx       context.Context
	Workspace *entity.Workspace
	Query     sq.SelectBuilder
	Tx        *sql.Tx
} {
	var calls []struct {
		Ctx       context.Context
		Workspace *entity.Workspace
		Query     sq.SelectBuilder
		Tx        *sql.Tx
	}
	mock.lockFetchCustomEvents.RLock()
	calls = mock.calls.FetchCustomEvents
	mock.lockFetchCustomEvents.RUnlock()
	return calls
}

// FetchDevices calls FetchDevicesFunc.
func (mock *RepositoryMock) FetchDevices(ctx context.Context, workspace *entity.Workspace, query sq.SelectBuilder, tx *sql.Tx) ([]*entity.Device, error) {
	if mock.FetchDevicesFunc == nil {
		panic("RepositoryMock.FetchDevicesFunc: method is nil but Repository.FetchDevices was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Workspace *entity.Workspace
		Query     sq.SelectBuilder
		Tx        *sql.Tx
	}{
		Ctx:       ctx,
		Workspace: workspace,
		Query:     query,
		Tx:        tx,
	}
	mock.lockFetchDevices.Lock()
	mock.calls.FetchDevices = append(mock.calls.FetchDevices, callInfo)
	mock.lockFetchDevices.Unlock()
	return mock.FetchDevicesFunc(ctx, workspace, query, tx)
}

// FetchDevicesCalls gets all the calls that were made to FetchDevices.
// Check the length with:
//
//	len(mockedRepository.FetchDevicesCalls())
func (mock *RepositoryMock) FetchDevicesCalls() []struct {
	Ctx       context.Context
	Workspace *entity.Workspace
	Query     sq.SelectBuilder
	Tx        *sql.Tx
} {
	var calls []struct {
		Ctx       context.Context
		Workspace *entity.Workspace
		Query     sq.SelectBuilder
		Tx        *sql.Tx
	}
	mock.lockFetchDevices.RLock()
	calls = mock.calls.FetchDevices
	mock.lockFetchDevices.RUnlock()
	return calls
}

// FetchSessions calls FetchSessionsFunc.
func (mock *RepositoryMock) FetchSessions(ctx context.Context, workspace *entity.Workspace, query sq.SelectBuilder, tx *sql.Tx) ([]*entity.Session, error) {
	if mock.FetchSessionsFunc == nil {
		panic("RepositoryMock.FetchSessionsFunc: method is nil but Repository.FetchSessions was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Workspace *entity.Workspace
		Query     sq.SelectBuilder
		Tx        *sql.Tx
	}{
		Ctx:       ctx,
		Workspace: workspace,
		Query:     query,
		Tx:        tx,
	}
	mock.lockFetchSessions.Lock()
	mock.calls.FetchSessions = append(mock.calls.FetchSessions, callInfo)
	mock.lockFetchSessions.Unlock()
	return mock.FetchSessionsFunc(ctx, workspace, query, tx)
}

// FetchSessionsCalls gets all the calls that were made to FetchSessions.
// Check the length with:
//
//	len(mockedRepository.FetchSessionsCalls())
func (mock *RepositoryMock) FetchSessionsCalls() []struct {
	Ctx       context.Context
	Workspace *entity.Workspace
	Query     sq.SelectBuilder
	Tx        *sql.Tx
} {
	var calls []struct {
		Ctx       context.Context
		Workspace *entity.Workspace
		Query     sq.SelectBuilder
		Tx        *sql.Tx
	}
	mock.lockFetchSessions.RLock()
	calls = mock.calls.FetchSessions
	mock.lockFetchSessions.RUnlock()
	return calls
}

// FindAppItemByExternalID calls FindAppItemByExternalIDFunc.
func (mock *RepositoryMock) FindAppItemByExternalID(ctx context.Context, workspace *entity.Workspace, kind string, externalID string, tx *sql.Tx) (*entity.AppItem, error) {
	if mock.FindAppItemByExternalIDFunc == nil {
		panic("RepositoryMock.FindAppItemByExternalIDFunc: method is nil but Repository.FindAppItemByExternalID was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Workspace  *entity.Workspace
		Kind       string
		ExternalID string
		Tx         *sql.Tx
	}{
		Ctx:        ctx,
		Workspace:  workspace,
		Kind:       kind,
		ExternalID: externalID,
		Tx:         tx,
	}
	mock.lockFindAppItemByExternalID.Lock()
	mock.calls.FindAppItemByExternalID = append(mock.calls.FindAppItemByExternalID, callInfo)
	mock.lockFindAppItemByExternalID.Unlock()
	return mock.FindAppItemByExternalIDFunc(ctx, workspace, kind, externalID, tx)
}

// FindAppItemByExternalIDCalls gets all the calls that were made to FindAppItemByExternalID.
// Check the length with:
//
//	len(mockedRepository.FindAppItemByExternalIDCalls())
func (mock *RepositoryMock) FindAppItemByExternalIDCalls() []struct {
	Ctx        context.Context
	Workspace  *entity.Workspace
	Kind       string
	ExternalID string
	Tx         *sql.Tx
} {
	var calls []struct {
		Ctx        context.Context
		Workspace  *entity.Workspace
		Kind       string
		ExternalID string
		Tx         *sql.Tx
	}
	mock.lockFindAppItemByExternalID.RLock()
	calls = mock.calls.FindAppItemByExternalID
	mock.lockFindAppItemByExternalID.RUnlock()
	return calls
}

// FindAppItemByID calls FindAppItemByIDFunc.
func (mock *RepositoryMock) FindAppItemByID(ctx context.Context, workspace *entity.Workspace, kind string, id string, tx *sql.Tx) (*entity.AppItem, error) {
	if mock.FindAppItemByIDFunc == nil {
		panic("RepositoryMock.FindAppItemByIDFunc: method is nil but Repository.FindAppItemByID was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Workspace *entity.Workspace
		Kind      string
		ID        string
		Tx        *sql.Tx
	}{
		Ctx:       ctx,
		Workspace: workspace,
		Kind:      kind,
		ID:        id,
		Tx:        tx,
	}
	mock.lockFindAppItemByID.Lock()
	mock.calls.FindAppItemByID = append(mock.calls.FindAppItemByID, callInfo)
	mock.lockFindAppItemByID.Unlock()
	return mock.FindAppItemByIDFunc(ctx, workspace, kind, id, tx)
}

// FindAppItemByIDCalls gets all the calls that were made to FindAppItemByID.
// Check the length with:
//
//	len(mockedRepository.FindAppItemByIDCalls())
func (mock *RepositoryMock) FindAppItemByIDCalls() []struct {
	Ctx       context.Context
	Workspace *entity.Workspace
	Kind      string
	ID        string
	Tx        *sql.Tx
} {
	var calls []struct {
		Ctx       context.Context
		Workspace *entity.Workspace
		Kind      string
		ID        string
		Tx        *sql.Tx
	}
	mock.lockFindAppItemByID.RLock()
	calls = mock.calls.FindAppItemByID
	mock.lockFindAppItemByID.RUnlock()
	return calls
}

// FindCartByID calls FindCartByIDFunc.
func (mock *RepositoryMock) FindCartByID(ctx context.Context, workspaceID string, cartID string, userID string, tx *sql.Tx) (*entity.Cart, error) {
	if mock.FindCartByIDFunc == nil {
		panic("RepositoryMock.FindCartByIDFunc: method is nil but Repository.FindCartByID was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		WorkspaceID string
		CartID      string
		UserID      string
		Tx          *sql.Tx
	}{
		Ctx:         ctx,
		WorkspaceID: workspaceID,
		CartID:      cartID,
		UserID:      userID,
		Tx:          tx,
	}
	mock.lockFindCartByID.Lock()
	mock.calls.FindCartByID = append(mock.calls.FindCartByID, callInfo)
	mock.lockFindCartByID.Unlock()
	return mock.FindCartByIDFunc(ctx, workspaceID, cartID, userID, tx)
}

// FindCartByIDCalls gets all the calls that were made to FindCartByID.
// Check the length with:
//
//	len(mockedRepository.FindCartByIDCalls())
func (mock *RepositoryMock) FindCartByIDCalls() []struct {
	Ctx         context.Context
	WorkspaceID string
	CartID      string
	UserID      string
	Tx          *sql.Tx
} {
	var calls []struct {
		Ctx         context.Context
		WorkspaceID string
		CartID      string
		UserID      string
		Tx          *sql.Tx
	}
	mock.lockFindCartByID.RLock()
	calls = mock.calls.FindCartByID
	mock.lockFindCartByID.RUnlock()
	return calls
}

// FindCartItemsByCartID calls FindCartItemsByCartIDFunc.
func (mock *RepositoryMock) FindCartItemsByCartID(ctx context.Context, workspaceID string, cartID string, userID string, tx *sql.Tx) ([]*entity.CartItem, error) {
	if mock.FindCartItemsByCartIDFunc == nil {
		panic("RepositoryMock.FindCartItemsByCartIDFunc: method is nil but Repository.FindCartItemsByCartID was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		WorkspaceID string
		CartID      string
		UserID      string
		Tx          *sql.Tx
	}{
		Ctx:         ctx,
		WorkspaceID: workspaceID,
		CartID:      cartID,
		UserID:      userID,
		Tx:          tx,
	}
	mock.lockFindCartItemsByCartID.Lock()
	mock.calls.FindCartItemsByCartID = append(mock.calls.FindCartItemsByCartID, callInfo)
	mock.lockFindCartItemsByCartID.Unlock()
	return mock.FindCartItemsByCartIDFunc(ctx, workspaceID, cartID, userID, tx)
}

// FindCartItemsByCartIDCalls gets all the calls that were made to FindCartItemsByCartID.
// Check the length with:
//
//	len(mockedRepository.FindCartItemsByCartIDCalls())
func (mock *RepositoryMock) FindCartItemsByCartIDCalls() []struct {
	Ctx         context.Context
	WorkspaceID string
	CartID      string
	UserID      string
	Tx          *sql.Tx
} {
	var calls []struct {
		Ctx         context.Context
		WorkspaceID string
		CartID      string
		UserID      string
		Tx          *sql.Tx
	}
	mock.lockFindCartItemsByCartID.RLock()
	calls = mock.calls.FindCartItemsByCartID
	mock.lockFindCartItemsByCartID.RUnlock()
	return calls
}

// FindCustomEventByID calls FindCustomEventByIDFunc.
func (mock *RepositoryMock) FindCustomEventByID(ctx context.Context, workspace *entity.Workspace, eventID string, userID string, tx *sql.Tx) (*entity.CustomEvent, error) {
	if mock.FindCustomEventByIDFunc == nil {
		panic("RepositoryMock.FindCustomEventByIDFunc: method is nil but Repository.FindCustomEventByID was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Workspace *entity.Workspace
		EventID   string
		UserID    string
		Tx        *sql.Tx
	}{
		Ctx:       ctx,
		Workspace: workspace,
		EventID:   eventID,
		UserID:    userID,
		Tx:        tx,
	}
	mock.lockFindCustomEventByID.Lock()
	mock.calls.FindCustomEventByID = append(mock.calls.FindCustomEventByID, callInfo)
	mock.lockFindCustomEventByID.Unlock()
	return mock.FindCustomEventByIDFunc(ctx, workspace, eventID, userID, tx)
}

// FindCustomEventByIDCalls gets all the calls that were made to FindCustomEventByID.
// Check the length with:
//
//	len(mockedRepository.FindCustomEventByIDCalls())
func (mock *RepositoryMock) FindCustomEventByIDCalls() []struct {
	Ctx       context.Context
	Workspace *entity.Workspace
	EventID   string
	UserID    string
	Tx        *sql.Tx
} {
	var calls []struct {
		Ctx       context.Context
		Workspace *entity.Workspace
		EventID   string
		UserID    string
		Tx        *sql.Tx
	}
	mock.lockFindCustomEventByID.RLock()
	calls = mock.calls.FindCustomEventByID
	mock.lockFindCustomEventByID.RUnlock()
	return calls
}

// FindDeviceByID calls FindDeviceByIDFunc.
func (mock *RepositoryMock) FindDeviceByID(ctx context.Context, workspace *entity.Workspace, deviceID string, userID string, tx *sql.Tx) (*entity.Device, error) {
	if mock.FindDeviceByIDFunc == nil {
		panic("RepositoryMock.FindDeviceByIDFunc: method is nil but Repository.FindDeviceByID was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Workspace *entity.Workspace
		DeviceID  string
		UserID    string
		Tx        *sql.Tx
	}{
		Ctx:       ctx,
		Workspace: workspace,
		DeviceID:  deviceID,
		UserID:    userID,
		Tx:        tx,
	}
	mock.lockFindDeviceByID.Lock()
	mock.calls.FindDeviceByID = append(mock.calls.FindDeviceByID, callInfo)
	mock.lockFindDeviceByID.Unlock()
	return mock.FindDeviceByIDFunc(ctx, workspace, deviceID, userID, tx)
}

// FindDeviceByIDCalls gets all the calls that were made to FindDeviceByID.
// Check the length with:
//
//	len(mockedRepository.FindDeviceByIDCalls())
func (mock *RepositoryMock) FindDeviceByIDCalls() []struct {
	Ctx       context.Context
	Workspace *entity.Workspace
	DeviceID  string
	UserID    string
	Tx        *sql.Tx
} {
	var calls []struct {
		Ctx       context.Context
		Workspace *entity.Workspace
		DeviceID  string
		UserID    string
		Tx        *sql.Tx
	}
	mock.lockFindDeviceByID.RLock()
	calls = mock.calls.FindDeviceByID
	mock.lockFindDeviceByID.RUnlock()
	return calls
}

// FindEventualUsersToMergeWith calls FindEventualUsersToMergeWithFunc.
func (mock *RepositoryMock) FindEventualUsersToMergeWith(ctx context.Context, workspace *entity.Workspace, withUser *entity.User, withReconciliationKeys entity.MapOfInterfaces, tx *sql.Tx) ([]*entity.User, error) {
	if mock.FindEventualUsersToMergeWithFunc == nil {
		panic("RepositoryMock.FindEventualUsersToMergeWithFunc: method is nil but Repository.FindEventualUsersToMergeWith was just called")
	}
	callInfo := struct {
		Ctx                    context.Context
		Workspace              *entity.Workspace
		WithUser               *entity.User
		WithReconciliationKeys entity.MapOfInterfaces
		Tx                     *sql.Tx
	}{
		Ctx:                    ctx,
		Workspace:              workspace,
		WithUser:               withUser,
		WithReconciliationKeys: withReconciliationKeys,
		Tx:                     tx,
	}
	mock.lockFindEventualUsersToMergeWith.Lock()
	mock.calls.FindEventualUsersToMergeWith = append(mock.calls.FindEventualUsersToMergeWith, callInfo)
	mock.lockFindEventualUsersToMergeWith.Unlock()
	return mock.FindEventualUsersToMergeWithFunc(ctx, workspace, withUser, withReconciliationKeys, tx)
}

// FindEventualUsersToMergeWithCalls gets all the calls that were made to FindEventualUsersToMergeWith.
// Check the length with:
//
//	len(mockedRepository.FindEventualUsersToMergeWithCalls())
func (mock *RepositoryMock) FindEventualUsersToMergeWithCalls() []struct {
	Ctx                    context.Context
	Workspace              *entity.Workspace
	WithUser               *entity.User
	WithReconciliationKeys entity.MapOfInterfaces
	Tx                     *sql.Tx
} {
	var calls []struct {
		Ctx                    context.Context
		Workspace              *entity.Workspace
		WithUser               *entity.User
		WithReconciliationKeys entity.MapOfInterfaces
		Tx                     *sql.Tx
	}
	mock.lockFindEventualUsersToMergeWith.RLock()
	calls = mock.calls.FindEventualUsersToMergeWith
	mock.lockFindEventualUsersToMergeWith.RUnlock()
	return calls
}

// FindMessageByID calls FindMessageByIDFunc.
func (mock *RepositoryMock) FindMessageByID(ctx context.Context, workspace *entity.Workspace, id string, userID string, tx *sql.Tx) (*entity.Message, error) {
	if mock.FindMessageByIDFunc == nil {
		panic("RepositoryMock.FindMessageByIDFunc: method is nil but Repository.FindMessageByID was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Workspace *entity.Workspace
		ID        string
		UserID    string
		Tx        *sql.Tx
	}{
		Ctx:       ctx,
		Workspace: workspace,
		ID:        id,
		UserID:    userID,
		Tx:        tx,
	}
	mock.lockFindMessageByID.Lock()
	mock.calls.FindMessageByID = append(mock.calls.FindMessageByID, callInfo)
	mock.lockFindMessageByID.Unlock()
	return mock.FindMessageByIDFunc(ctx, workspace, id, userID, tx)
}

// FindMessageByIDCalls gets all the calls that were made to FindMessageByID.
// Check the length with:
//
//	len(mockedRepository.FindMessageByIDCalls())
func (mock *RepositoryMock) FindMessageByIDCalls() []struct {
	Ctx       context.Context
	Workspace *entity.Workspace
	ID        string
	UserID    string
	Tx        *sql.Tx
} {
	var calls []struct {
		Ctx       context.Context
		Workspace *entity.Workspace
		ID        string
		UserID    string
		Tx        *sql.Tx
	}
	mock.lockFindMessageByID.RLock()
	calls = mock.calls.FindMessageByID
	mock.lockFindMessageByID.RUnlock()
	return calls
}

// FindOrderByID calls FindOrderByIDFunc.
func (mock *RepositoryMock) FindOrderByID(ctx context.Context, workspace *entity.Workspace, orderID string, userID string, tx *sql.Tx) (*entity.Order, error) {
	if mock.FindOrderByIDFunc == nil {
		panic("RepositoryMock.FindOrderByIDFunc: method is nil but Repository.FindOrderByID was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Workspace *entity.Workspace
		OrderID   string
		UserID    string
		Tx        *sql.Tx
	}{
		Ctx:       ctx,
		Workspace: workspace,
		OrderID:   orderID,
		UserID:    userID,
		Tx:        tx,
	}
	mock.lockFindOrderByID.Lock()
	mock.calls.FindOrderByID = append(mock.calls.FindOrderByID, callInfo)
	mock.lockFindOrderByID.Unlock()
	return mock.FindOrderByIDFunc(ctx, workspace, orderID, userID, tx)
}

// FindOrderByIDCalls gets all the calls that were made to FindOrderByID.
// Check the length with:
//
//	len(mockedRepository.FindOrderByIDCalls())
func (mock *RepositoryMock) FindOrderByIDCalls() []struct {
	Ctx       context.Context
	Workspace *entity.Workspace
	OrderID   string
	UserID    string
	Tx        *sql.Tx
} {
	var calls []struct {
		Ctx       context.Context
		Workspace *entity.Workspace
		OrderID   string
		UserID    string
		Tx        *sql.Tx
	}
	mock.lockFindOrderByID.RLock()
	calls = mock.calls.FindOrderByID
	mock.lockFindOrderByID.RUnlock()
	return calls
}

// FindOrderItemsByOrderID calls FindOrderItemsByOrderIDFunc.
func (mock *RepositoryMock) FindOrderItemsByOrderID(ctx context.Context, workspaceID string, orderID string, userID string, tx *sql.Tx) ([]*entity.OrderItem, error) {
	if mock.FindOrderItemsByOrderIDFunc == nil {
		panic("RepositoryMock.FindOrderItemsByOrderIDFunc: method is nil but Repository.FindOrderItemsByOrderID was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		WorkspaceID string
		OrderID     string
		UserID      string
		Tx          *sql.Tx
	}{
		Ctx:         ctx,
		WorkspaceID: workspaceID,
		OrderID:     orderID,
		UserID:      userID,
		Tx:          tx,
	}
	mock.lockFindOrderItemsByOrderID.Lock()
	mock.calls.FindOrderItemsByOrderID = append(mock.calls.FindOrderItemsByOrderID, callInfo)
	mock.lockFindOrderItemsByOrderID.Unlock()
	return mock.FindOrderItemsByOrderIDFunc(ctx, workspaceID, orderID, userID, tx)
}

// FindOrderItemsByOrderIDCalls gets all the calls that were made to FindOrderItemsByOrderID.
// Check the length with:
//
//	len(mockedRepository.FindOrderItemsByOrderIDCalls())
func (mock *RepositoryMock) FindOrderItemsByOrderIDCalls() []struct {
	Ctx         context.Context
	WorkspaceID string
	OrderID     string
	UserID      string
	Tx          *sql.Tx
} {
	var calls []struct {
		Ctx         context.Context
		WorkspaceID string
		OrderID     string
		UserID      string
		Tx          *sql.Tx
	}
	mock.lockFindOrderItemsByOrderID.RLock()
	calls = mock.calls.FindOrderItemsByOrderID
	mock.lockFindOrderItemsByOrderID.RUnlock()
	return calls
}

// FindPageviewByID calls FindPageviewByIDFunc.
func (mock *RepositoryMock) FindPageviewByID(ctx context.Context, workspace *entity.Workspace, pageviewID string, userID string, tx *sql.Tx) (*entity.Pageview, error) {
	if mock.FindPageviewByIDFunc == nil {
		panic("RepositoryMock.FindPageviewByIDFunc: method is nil but Repository.FindPageviewByID was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Workspace  *entity.Workspace
		PageviewID string
		UserID     string
		Tx         *sql.Tx
	}{
		Ctx:        ctx,
		Workspace:  workspace,
		PageviewID: pageviewID,
		UserID:     userID,
		Tx:         tx,
	}
	mock.lockFindPageviewByID.Lock()
	mock.calls.FindPageviewByID = append(mock.calls.FindPageviewByID, callInfo)
	mock.lockFindPageviewByID.Unlock()
	return mock.FindPageviewByIDFunc(ctx, workspace, pageviewID, userID, tx)
}

// FindPageviewByIDCalls gets all the calls that were made to FindPageviewByID.
// Check the length with:
//
//	len(mockedRepository.FindPageviewByIDCalls())
func (mock *RepositoryMock) FindPageviewByIDCalls() []struct {
	Ctx        context.Context
	Workspace  *entity.Workspace
	PageviewID string
	UserID     string
	Tx         *sql.Tx
} {
	var calls []struct {
		Ctx        context.Context
		Workspace  *entity.Workspace
		PageviewID string
		UserID     string
		Tx         *sql.Tx
	}
	mock.lockFindPageviewByID.RLock()
	calls = mock.calls.FindPageviewByID
	mock.lockFindPageviewByID.RUnlock()
	return calls
}

// FindPostviewByID calls FindPostviewByIDFunc.
func (mock *RepositoryMock) FindPostviewByID(ctx context.Context, workspaceID *entity.Workspace, postviewID string, userID string, tx *sql.Tx) (*entity.Postview, error) {
	if mock.FindPostviewByIDFunc == nil {
		panic("RepositoryMock.FindPostviewByIDFunc: method is nil but Repository.FindPostviewByID was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		WorkspaceID *entity.Workspace
		PostviewID  string
		UserID      string
		Tx          *sql.Tx
	}{
		Ctx:         ctx,
		WorkspaceID: workspaceID,
		PostviewID:  postviewID,
		UserID:      userID,
		Tx:          tx,
	}
	mock.lockFindPostviewByID.Lock()
	mock.calls.FindPostviewByID = append(mock.calls.FindPostviewByID, callInfo)
	mock.lockFindPostviewByID.Unlock()
	return mock.FindPostviewByIDFunc(ctx, workspaceID, postviewID, userID, tx)
}

// FindPostviewByIDCalls gets all the calls that were made to FindPostviewByID.
// Check the length with:
//
//	len(mockedRepository.FindPostviewByIDCalls())
func (mock *RepositoryMock) FindPostviewByIDCalls() []struct {
	Ctx         context.Context
	WorkspaceID *entity.Workspace
	PostviewID  string
	UserID      string
	Tx          *sql.Tx
} {
	var calls []struct {
		Ctx         context.Context
		WorkspaceID *entity.Workspace
		PostviewID  string
		UserID      string
		Tx          *sql.Tx
	}
	mock.lockFindPostviewByID.RLock()
	calls = mock.calls.FindPostviewByID
	mock.lockFindPostviewByID.RUnlock()
	return calls
}

// FindSessionByID calls FindSessionByIDFunc.
func (mock *RepositoryMock) FindSessionByID(ctx context.Context, workspace *entity.Workspace, sessionID string, userID string, tx *sql.Tx) (*entity.Session, error) {
	if mock.FindSessionByIDFunc == nil {
		panic("RepositoryMock.FindSessionByIDFunc: method is nil but Repository.FindSessionByID was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Workspace *entity.Workspace
		SessionID string
		UserID    string
		Tx        *sql.Tx
	}{
		Ctx:       ctx,
		Workspace: workspace,
		SessionID: sessionID,
		UserID:    userID,
		Tx:        tx,
	}
	mock.lockFindSessionByID.Lock()
	mock.calls.FindSessionByID = append(mock.calls.FindSessionByID, callInfo)
	mock.lockFindSessionByID.Unlock()
	return mock.FindSessionByIDFunc(ctx, workspace, sessionID, userID, tx)
}

// FindSessionByIDCalls gets all the calls that were made to FindSessionByID.
// Check the length with:
//
//	len(mockedRepository.FindSessionByIDCalls())
func (mock *RepositoryMock) FindSessionByIDCalls() []struct {
	Ctx       context.Context
	Workspace *entity.Workspace
	SessionID string
	UserID    string
	Tx        *sql.Tx
} {
	var calls []struct {
		Ctx       context.Context
		Workspace *entity.Workspace
		SessionID string
		UserID    string
		Tx        *sql.Tx
	}
	mock.lockFindSessionByID.RLock()
	calls = mock.calls.FindSessionByID
	mock.lockFindSessionByID.RUnlock()
	return calls
}

// FindSubscriptionListUser calls FindSubscriptionListUserFunc.
func (mock *RepositoryMock) FindSubscriptionListUser(ctx context.Context, listID string, userID string, tx *sql.Tx) (*entity.SubscriptionListUser, error) {
	if mock.FindSubscriptionListUserFunc == nil {
		panic("RepositoryMock.FindSubscriptionListUserFunc: method is nil but Repository.FindSubscriptionListUser was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		ListID string
		UserID string
		Tx     *sql.Tx
	}{
		Ctx:    ctx,
		ListID: listID,
		UserID: userID,
		Tx:     tx,
	}
	mock.lockFindSubscriptionListUser.Lock()
	mock.calls.FindSubscriptionListUser = append(mock.calls.FindSubscriptionListUser, callInfo)
	mock.lockFindSubscriptionListUser.Unlock()
	return mock.FindSubscriptionListUserFunc(ctx, listID, userID, tx)
}

// FindSubscriptionListUserCalls gets all the calls that were made to FindSubscriptionListUser.
// Check the length with:
//
//	len(mockedRepository.FindSubscriptionListUserCalls())
func (mock *RepositoryMock) FindSubscriptionListUserCalls() []struct {
	Ctx    context.Context
	ListID string
	UserID string
	Tx     *sql.Tx
} {
	var calls []struct {
		Ctx    context.Context
		ListID string
		UserID string
		Tx     *sql.Tx
	}
	mock.lockFindSubscriptionListUser.RLock()
	calls = mock.calls.FindSubscriptionListUser
	mock.lockFindSubscriptionListUser.RUnlock()
	return calls
}

// FindUserAlias calls FindUserAliasFunc.
func (mock *RepositoryMock) FindUserAlias(ctx context.Context, fromUserExternalID string, tx *sql.Tx) (*entity.UserAlias, error) {
	if mock.FindUserAliasFunc == nil {
		panic("RepositoryMock.FindUserAliasFunc: method is nil but Repository.FindUserAlias was just called")
	}
	callInfo := struct {
		Ctx                context.Context
		FromUserExternalID string
		Tx                 *sql.Tx
	}{
		Ctx:                ctx,
		FromUserExternalID: fromUserExternalID,
		Tx:                 tx,
	}
	mock.lockFindUserAlias.Lock()
	mock.calls.FindUserAlias = append(mock.calls.FindUserAlias, callInfo)
	mock.lockFindUserAlias.Unlock()
	return mock.FindUserAliasFunc(ctx, fromUserExternalID, tx)
}

// FindUserAliasCalls gets all the calls that were made to FindUserAlias.
// Check the length with:
//
//	len(mockedRepository.FindUserAliasCalls())
func (mock *RepositoryMock) FindUserAliasCalls() []struct {
	Ctx                context.Context
	FromUserExternalID string
	Tx                 *sql.Tx
} {
	var calls []struct {
		Ctx                context.Context
		FromUserExternalID string
		Tx                 *sql.Tx
	}
	mock.lockFindUserAlias.RLock()
	calls = mock.calls.FindUserAlias
	mock.lockFindUserAlias.RUnlock()
	return calls
}

// FindUserByID calls FindUserByIDFunc.
func (mock *RepositoryMock) FindUserByID(ctx context.Context, workspace *entity.Workspace, userID string, tx *sql.Tx, userWith *dto.UserWith) (*entity.User, error) {
	if mock.FindUserByIDFunc == nil {
		panic("RepositoryMock.FindUserByIDFunc: method is nil but Repository.FindUserByID was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Workspace *entity.Workspace
		UserID    string
		Tx        *sql.Tx
		UserWith  *dto.UserWith
	}{
		Ctx:       ctx,
		Workspace: workspace,
		UserID:    userID,
		Tx:        tx,
		UserWith:  userWith,
	}
	mock.lockFindUserByID.Lock()
	mock.calls.FindUserByID = append(mock.calls.FindUserByID, callInfo)
	mock.lockFindUserByID.Unlock()
	return mock.FindUserByIDFunc(ctx, workspace, userID, tx, userWith)
}

// FindUserByIDCalls gets all the calls that were made to FindUserByID.
// Check the length with:
//
//	len(mockedRepository.FindUserByIDCalls())
func (mock *RepositoryMock) FindUserByIDCalls() []struct {
	Ctx       context.Context
	Workspace *entity.Workspace
	UserID    string
	Tx        *sql.Tx
	UserWith  *dto.UserWith
} {
	var calls []struct {
		Ctx       context.Context
		Workspace *entity.Workspace
		UserID    string
		Tx        *sql.Tx
		UserWith  *dto.UserWith
	}
	mock.lockFindUserByID.RLock()
	calls = mock.calls.FindUserByID
	mock.lockFindUserByID.RUnlock()
	return calls
}

// FindUserIDsWithOrdersToReattribute calls FindUserIDsWithOrdersToReattributeFunc.
func (mock *RepositoryMock) FindUserIDsWithOrdersToReattribute(ctx context.Context, workspaceID string, limit int) ([]string, error) {
	if mock.FindUserIDsWithOrdersToReattributeFunc == nil {
		panic("RepositoryMock.FindUserIDsWithOrdersToReattributeFunc: method is nil but Repository.FindUserIDsWithOrdersToReattribute was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		WorkspaceID string
		Limit       int
	}{
		Ctx:         ctx,
		WorkspaceID: workspaceID,
		Limit:       limit,
	}
	mock.lockFindUserIDsWithOrdersToReattribute.Lock()
	mock.calls.FindUserIDsWithOrdersToReattribute = append(mock.calls.FindUserIDsWithOrdersToReattribute, callInfo)
	mock.lockFindUserIDsWithOrdersToReattribute.Unlock()
	return mock.FindUserIDsWithOrdersToReattributeFunc(ctx, workspaceID, limit)
}

// FindUserIDsWithOrdersToReattributeCalls gets all the calls that were made to FindUserIDsWithOrdersToReattribute.
// Check the length with:
//
//	len(mockedRepository.FindUserIDsWithOrdersToReattributeCalls())
func (mock *RepositoryMock) FindUserIDsWithOrdersToReattributeCalls() []struct {
	Ctx         context.Context
	WorkspaceID string
	Limit       int
} {
	var calls []struct {
		Ctx         context.Context
		WorkspaceID string
		Limit       int
	}
	mock.lockFindUserIDsWithOrdersToReattribute.RLock()
	calls = mock.calls.FindUserIDsWithOrdersToReattribute
	mock.lockFindUserIDsWithOrdersToReattribute.RUnlock()
	return calls
}

// FindUsersAliased calls FindUsersAliasedFunc.
func (mock *RepositoryMock) FindUsersAliased(ctx context.Context, workspaceID string, toUserExternalID string) ([]*entity.UserAlias, error) {
	if mock.FindUsersAliasedFunc == nil {
		panic("RepositoryMock.FindUsersAliasedFunc: method is nil but Repository.FindUsersAliased was just called")
	}
	callInfo := struct {
		Ctx              context.Context
		WorkspaceID      string
		ToUserExternalID string
	}{
		Ctx:              ctx,
		WorkspaceID:      workspaceID,
		ToUserExternalID: toUserExternalID,
	}
	mock.lockFindUsersAliased.Lock()
	mock.calls.FindUsersAliased = append(mock.calls.FindUsersAliased, callInfo)
	mock.lockFindUsersAliased.Unlock()
	return mock.FindUsersAliasedFunc(ctx, workspaceID, toUserExternalID)
}

// FindUsersAliasedCalls gets all the calls that were made to FindUsersAliased.
// Check the length with:
//
//	len(mockedRepository.FindUsersAliasedCalls())
func (mock *RepositoryMock) FindUsersAliasedCalls() []struct {
	Ctx              context.Context
	WorkspaceID      string
	ToUserExternalID string
} {
	var calls []struct {
		Ctx              context.Context
		WorkspaceID      string
		ToUserExternalID string
	}
	mock.lockFindUsersAliased.RLock()
	calls = mock.calls.FindUsersAliased
	mock.lockFindUsersAliased.RUnlock()
	return calls
}

// GetAccountFromEmail calls GetAccountFromEmailFunc.
func (mock *RepositoryMock) GetAccountFromEmail(ctx context.Context, email string) (*entity.Account, error) {
	if mock.GetAccountFromEmailFunc == nil {
		panic("RepositoryMock.GetAccountFromEmailFunc: method is nil but Repository.GetAccountFromEmail was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Email string
	}{
		Ctx:   ctx,
		Email: email,
	}
	mock.lockGetAccountFromEmail.Lock()
	mock.calls.GetAccountFromEmail = append(mock.calls.GetAccountFromEmail, callInfo)
	mock.lockGetAccountFromEmail.Unlock()
	return mock.GetAccountFromEmailFunc(ctx, email)
}

// GetAccountFromEmailCalls gets all the calls that were made to GetAccountFromEmail.
// Check the length with:
//
//	len(mockedRepository.GetAccountFromEmailCalls())
func (mock *RepositoryMock) GetAccountFromEmailCalls() []struct {
	Ctx   context.Context
	Email string
} {
	var calls []struct {
		Ctx   context.Context
		Email string
	}
	mock.lockGetAccountFromEmail.RLock()
	calls = mock.calls.GetAccountFromEmail
	mock.lockGetAccountFromEmail.RUnlock()
	return calls
}

// GetAccountFromID calls GetAccountFromIDFunc.
func (mock *RepositoryMock) GetAccountFromID(ctx context.Context, accountID string) (*entity.Account, error) {
	if mock.GetAccountFromIDFunc == nil {
		panic("RepositoryMock.GetAccountFromIDFunc: method is nil but Repository.GetAccountFromID was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		AccountID string
	}{
		Ctx:       ctx,
		AccountID: accountID,
	}
	mock.lockGetAccountFromID.Lock()
	mock.calls.GetAccountFromID = append(mock.calls.GetAccountFromID, callInfo)
	mock.lockGetAccountFromID.Unlock()
	return mock.GetAccountFromIDFunc(ctx, accountID)
}

// GetAccountFromIDCalls gets all the calls that were made to GetAccountFromID.
// Check the length with:
//
//	len(mockedRepository.GetAccountFromIDCalls())
func (mock *RepositoryMock) GetAccountFromIDCalls() []struct {
	Ctx       context.Context
	AccountID string
} {
	var calls []struct {
		Ctx       context.Context
		AccountID string
	}
	mock.lockGetAccountFromID.RLock()
	calls = mock.calls.GetAccountFromID
	mock.lockGetAccountFromID.RUnlock()
	return calls
}

// GetApp calls GetAppFunc.
func (mock *RepositoryMock) GetApp(ctx context.Context, workspaceID string, appID string) (*entity.App, error) {
	if mock.GetAppFunc == nil {
		panic("RepositoryMock.GetAppFunc: method is nil but Repository.GetApp was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		WorkspaceID string
		AppID       string
	}{
		Ctx:         ctx,
		WorkspaceID: workspaceID,
		AppID:       appID,
	}
	mock.lockGetApp.Lock()
	mock.calls.GetApp = append(mock.calls.GetApp, callInfo)
	mock.lockGetApp.Unlock()
	return mock.GetAppFunc(ctx, workspaceID, appID)
}

// GetAppCalls gets all the calls that were made to GetApp.
// Check the length with:
//
//	len(mockedRepository.GetAppCalls())
func (mock *RepositoryMock) GetAppCalls() []struct {
	Ctx         context.Context
	WorkspaceID string
	AppID       string
} {
	var calls []struct {
		Ctx         context.Context
		WorkspaceID string
		AppID       string
	}
	mock.lockGetApp.RLock()
	calls = mock.calls.GetApp
	mock.lockGetApp.RUnlock()
	return calls
}

// GetBroadcastCampaign calls GetBroadcastCampaignFunc.
func (mock *RepositoryMock) GetBroadcastCampaign(ctx context.Context, workspaceID string, campaignID string) (*entity.BroadcastCampaign, error) {
	if mock.GetBroadcastCampaignFunc == nil {
		panic("RepositoryMock.GetBroadcastCampaignFunc: method is nil but Repository.GetBroadcastCampaign was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		WorkspaceID string
		CampaignID  string
	}{
		Ctx:         ctx,
		WorkspaceID: workspaceID,
		CampaignID:  campaignID,
	}
	mock.lockGetBroadcastCampaign.Lock()
	mock.calls.GetBroadcastCampaign = append(mock.calls.GetBroadcastCampaign, callInfo)
	mock.lockGetBroadcastCampaign.Unlock()
	return mock.GetBroadcastCampaignFunc(ctx, workspaceID, campaignID)
}

// GetBroadcastCampaignCalls gets all the calls that were made to GetBroadcastCampaign.
// Check the length with:
//
//	len(mockedRepository.GetBroadcastCampaignCalls())
func (mock *RepositoryMock) GetBroadcastCampaignCalls() []struct {
	Ctx         context.Context
	WorkspaceID string
	CampaignID  string
} {
	var calls []struct {
		Ctx         context.Context
		WorkspaceID string
		CampaignID  string
	}
	mock.lockGetBroadcastCampaign.RLock()
	calls = mock.calls.GetBroadcastCampaign
	mock.lockGetBroadcastCampaign.RUnlock()
	return calls
}

// GetDataLog calls GetDataLogFunc.
func (mock *RepositoryMock) GetDataLog(ctx context.Context, workspaceID string, dataLogID string) (*entity.DataLog, error) {
	if mock.GetDataLogFunc == nil {
		panic("RepositoryMock.GetDataLogFunc: method is nil but Repository.GetDataLog was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		WorkspaceID string
		DataLogID   string
	}{
		Ctx:         ctx,
		WorkspaceID: workspaceID,
		DataLogID:   dataLogID,
	}
	mock.lockGetDataLog.Lock()
	mock.calls.GetDataLog = append(mock.calls.GetDataLog, callInfo)
	mock.lockGetDataLog.Unlock()
	return mock.GetDataLogFunc(ctx, workspaceID, dataLogID)
}

// GetDataLogCalls gets all the calls that were made to GetDataLog.
// Check the length with:
//
//	len(mockedRepository.GetDataLogCalls())
func (mock *RepositoryMock) GetDataLogCalls() []struct {
	Ctx         context.Context
	WorkspaceID string
	DataLogID   string
} {
	var calls []struct {
		Ctx         context.Context
		WorkspaceID string
		DataLogID   string
	}
	mock.lockGetDataLog.RLock()
	calls = mock.calls.GetDataLog
	mock.lockGetDataLog.RUnlock()
	return calls
}

// GetDataLogChildren calls GetDataLogChildrenFunc.
func (mock *RepositoryMock) GetDataLogChildren(ctx context.Context, workspaceID string, dataLogID string) ([]*entity.DataLog, error) {
	if mock.GetDataLogChildrenFunc == nil {
		panic("RepositoryMock.GetDataLogChildrenFunc: method is nil but Repository.GetDataLogChildren was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		WorkspaceID string
		DataLogID   string
	}{
		Ctx:         ctx,
		WorkspaceID: workspaceID,
		DataLogID:   dataLogID,
	}
	mock.lockGetDataLogChildren.Lock()
	mock.calls.GetDataLogChildren = append(mock.calls.GetDataLogChildren, callInfo)
	mock.lockGetDataLogChildren.Unlock()
	return mock.GetDataLogChildrenFunc(ctx, workspaceID, dataLogID)
}

// GetDataLogChildrenCalls gets all the calls that were made to GetDataLogChildren.
// Check the length with:
//
//	len(mockedRepository.GetDataLogChildrenCalls())
func (mock *RepositoryMock) GetDataLogChildrenCalls() []struct {
	Ctx         context.Context
	WorkspaceID string
	DataLogID   string
} {
	var calls []struct {
		Ctx         context.Context
		WorkspaceID string
		DataLogID   string
	}
	mock.lockGetDataLogChildren.RLock()
	calls = mock.calls.GetDataLogChildren
	mock.lockGetDataLogChildren.RUnlock()
	return calls
}

// GetInvitation calls GetInvitationFunc.
func (mock *RepositoryMock) GetInvitation(ctx context.Context, email string, organizationID string) (*entity.OrganizationInvitation, error) {
	if mock.GetInvitationFunc == nil {
		panic("RepositoryMock.GetInvitationFunc: method is nil but Repository.GetInvitation was just called")
	}
	callInfo := struct {
		Ctx            context.Context
		Email          string
		OrganizationID string
	}{
		Ctx:            ctx,
		Email:          email,
		OrganizationID: organizationID,
	}
	mock.lockGetInvitation.Lock()
	mock.calls.GetInvitation = append(mock.calls.GetInvitation, callInfo)
	mock.lockGetInvitation.Unlock()
	return mock.GetInvitationFunc(ctx, email, organizationID)
}

// GetInvitationCalls gets all the calls that were made to GetInvitation.
// Check the length with:
//
//	len(mockedRepository.GetInvitationCalls())
func (mock *RepositoryMock) GetInvitationCalls() []struct {
	Ctx            context.Context
	Email          string
	OrganizationID string
} {
	var calls []struct {
		Ctx            context.Context
		Email          string
		OrganizationID string
	}
	mock.lockGetInvitation.RLock()
	calls = mock.calls.GetInvitation
	mock.lockGetInvitation.RUnlock()
	return calls
}

// GetMessageTemplate calls GetMessageTemplateFunc.
func (mock *RepositoryMock) GetMessageTemplate(ctx context.Context, workspaceID string, id string, version *int64, tx *sql.Tx) (*entity.MessageTemplate, error) {
	if mock.GetMessageTemplateFunc == nil {
		panic("RepositoryMock.GetMessageTemplateFunc: method is nil but Repository.GetMessageTemplate was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		WorkspaceID string
		ID          string
		Version     *int64
		Tx          *sql.Tx
	}{
		Ctx:         ctx,
		WorkspaceID: workspaceID,
		ID:          id,
		Version:     version,
		Tx:          tx,
	}
	mock.lockGetMessageTemplate.Lock()
	mock.calls.GetMessageTemplate = append(mock.calls.GetMessageTemplate, callInfo)
	mock.lockGetMessageTemplate.Unlock()
	return mock.GetMessageTemplateFunc(ctx, workspaceID, id, version, tx)
}

// GetMessageTemplateCalls gets all the calls that were made to GetMessageTemplate.
// Check the length with:
//
//	len(mockedRepository.GetMessageTemplateCalls())
func (mock *RepositoryMock) GetMessageTemplateCalls() []struct {
	Ctx         context.Context
	WorkspaceID string
	ID          string
	Version     *int64
	Tx          *sql.Tx
} {
	var calls []struct {
		Ctx         context.Context
		WorkspaceID string
		ID          string
		Version     *int64
		Tx          *sql.Tx
	}
	mock.lockGetMessageTemplate.RLock()
	calls = mock.calls.GetMessageTemplate
	mock.lockGetMessageTemplate.RUnlock()
	return calls
}

// GetOrganization calls GetOrganizationFunc.
func (mock *RepositoryMock) GetOrganization(ctx context.Context, organizationID string) (*entity.Organization, error) {
	if mock.GetOrganizationFunc == nil {
		panic("RepositoryMock.GetOrganizationFunc: method is nil but Repository.GetOrganization was just called")
	}
	callInfo := struct {
		Ctx            context.Context
		OrganizationID string
	}{
		Ctx:            ctx,
		OrganizationID: organizationID,
	}
	mock.lockGetOrganization.Lock()
	mock.calls.GetOrganization = append(mock.calls.GetOrganization, callInfo)
	mock.lockGetOrganization.Unlock()
	return mock.GetOrganizationFunc(ctx, organizationID)
}

// GetOrganizationCalls gets all the calls that were made to GetOrganization.
// Check the length with:
//
//	len(mockedRepository.GetOrganizationCalls())
func (mock *RepositoryMock) GetOrganizationCalls() []struct {
	Ctx            context.Context
	OrganizationID string
} {
	var calls []struct {
		Ctx            context.Context
		OrganizationID string
	}
	mock.lockGetOrganization.RLock()
	calls = mock.calls.GetOrganization
	mock.lockGetOrganization.RUnlock()
	return calls
}

// GetRunningTaskExecByTaskID calls GetRunningTaskExecByTaskIDFunc.
func (mock *RepositoryMock) GetRunningTaskExecByTaskID(ctx context.Context, taskID string, multipleExecKey *string, tx *sql.Tx) (*entity.TaskExec, error) {
	if mock.GetRunningTaskExecByTaskIDFunc == nil {
		panic("RepositoryMock.GetRunningTaskExecByTaskIDFunc: method is nil but Repository.GetRunningTaskExecByTaskID was just called")
	}
	callInfo := struct {
		Ctx             context.Context
		TaskID          string
		MultipleExecKey *string
		Tx              *sql.Tx
	}{
		Ctx:             ctx,
		TaskID:          taskID,
		MultipleExecKey: multipleExecKey,
		Tx:              tx,
	}
	mock.lockGetRunningTaskExecByTaskID.Lock()
	mock.calls.GetRunningTaskExecByTaskID = append(mock.calls.GetRunningTaskExecByTaskID, callInfo)
	mock.lockGetRunningTaskExecByTaskID.Unlock()
	return mock.GetRunningTaskExecByTaskIDFunc(ctx, taskID, multipleExecKey, tx)
}

// GetRunningTaskExecByTaskIDCalls gets all the calls that were made to GetRunningTaskExecByTaskID.
// Check the length with:
//
//	len(mockedRepository.GetRunningTaskExecByTaskIDCalls())
func (mock *RepositoryMock) GetRunningTaskExecByTaskIDCalls() []struct {
	Ctx             context.Context
	TaskID          string
	MultipleExecKey *string
	Tx              *sql.Tx
} {
	var calls []struct {
		Ctx             context.Context
		TaskID          string
		MultipleExecKey *string
		Tx              *sql.Tx
	}
	mock.lockGetRunningTaskExecByTaskID.RLock()
	calls = mock.calls.GetRunningTaskExecByTaskID
	mock.lockGetRunningTaskExecByTaskID.RUnlock()
	return calls
}

// GetSegment calls GetSegmentFunc.
func (mock *RepositoryMock) GetSegment(ctx context.Context, workspaceID string, segmentID string) (*entity.Segment, error) {
	if mock.GetSegmentFunc == nil {
		panic("RepositoryMock.GetSegmentFunc: method is nil but Repository.GetSegment was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		WorkspaceID string
		SegmentID   string
	}{
		Ctx:         ctx,
		WorkspaceID: workspaceID,
		SegmentID:   segmentID,
	}
	mock.lockGetSegment.Lock()
	mock.calls.GetSegment = append(mock.calls.GetSegment, callInfo)
	mock.lockGetSegment.Unlock()
	return mock.GetSegmentFunc(ctx, workspaceID, segmentID)
}

// GetSegmentCalls gets all the calls that were made to GetSegment.
// Check the length with:
//
//	len(mockedRepository.GetSegmentCalls())
func (mock *RepositoryMock) GetSegmentCalls() []struct {
	Ctx         context.Context
	WorkspaceID string
	SegmentID   string
} {
	var calls []struct {
		Ctx         context.Context
		WorkspaceID string
		SegmentID   string
	}
	mock.lockGetSegment.RLock()
	calls = mock.calls.GetSegment
	mock.lockGetSegment.RUnlock()
	return calls
}

// GetSettings calls GetSettingsFunc.
func (mock *RepositoryMock) GetSettings(ctx context.Context) (*entity.Settings, error) {
	if mock.GetSettingsFunc == nil {
		panic("RepositoryMock.GetSettingsFunc: method is nil but Repository.GetSettings was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetSettings.Lock()
	mock.calls.GetSettings = append(mock.calls.GetSettings, callInfo)
	mock.lockGetSettings.Unlock()
	return mock.GetSettingsFunc(ctx)
}

// GetSettingsCalls gets all the calls that were made to GetSettings.
// Check the length with:
//
//	len(mockedRepository.GetSettingsCalls())
func (mock *RepositoryMock) GetSettingsCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockGetSettings.RLock()
	calls = mock.calls.GetSettings
	mock.lockGetSettings.RUnlock()
	return calls
}

// GetSubscriptionList calls GetSubscriptionListFunc.
func (mock *RepositoryMock) GetSubscriptionList(ctx context.Context, workspaceID string, listID string, tx *sql.Tx) (*entity.SubscriptionList, error) {
	if mock.GetSubscriptionListFunc == nil {
		panic("RepositoryMock.GetSubscriptionListFunc: method is nil but Repository.GetSubscriptionList was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		WorkspaceID string
		ListID      string
		Tx          *sql.Tx
	}{
		Ctx:         ctx,
		WorkspaceID: workspaceID,
		ListID:      listID,
		Tx:          tx,
	}
	mock.lockGetSubscriptionList.Lock()
	mock.calls.GetSubscriptionList = append(mock.calls.GetSubscriptionList, callInfo)
	mock.lockGetSubscriptionList.Unlock()
	return mock.GetSubscriptionListFunc(ctx, workspaceID, listID, tx)
}

// GetSubscriptionListCalls gets all the calls that were made to GetSubscriptionList.
// Check the length with:
//
//	len(mockedRepository.GetSubscriptionListCalls())
func (mock *RepositoryMock) GetSubscriptionListCalls() []struct {
	Ctx         context.Context
	WorkspaceID string
	ListID      string
	Tx          *sql.Tx
} {
	var calls []struct {
		Ctx         context.Context
		WorkspaceID string
		ListID      string
		Tx          *sql.Tx
	}
	mock.lockGetSubscriptionList.RLock()
	calls = mock.calls.GetSubscriptionList
	mock.lockGetSubscriptionList.RUnlock()
	return calls
}

// GetSubscriptionListUsersToMessage calls GetSubscriptionListUsersToMessageFunc.
func (mock *RepositoryMock) GetSubscriptionListUsersToMessage(ctx context.Context, workspaceID string, listIDs []string, offset int64, limit int64) ([]*entity.SubscriptionListUser, error) {
	if mock.GetSubscriptionListUsersToMessageFunc == nil {
		panic("RepositoryMock.GetSubscriptionListUsersToMessageFunc: method is nil but Repository.GetSubscriptionListUsersToMessage was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		WorkspaceID string
		ListIDs     []string
		Offset      int64
		Limit       int64
	}{
		Ctx:         ctx,
		WorkspaceID: workspaceID,
		ListIDs:     listIDs,
		Offset:      offset,
		Limit:       limit,
	}
	mock.lockGetSubscriptionListUsersToMessage.Lock()
	mock.calls.GetSubscriptionListUsersToMessage = append(mock.calls.GetSubscriptionListUsersToMessage, callInfo)
	mock.lockGetSubscriptionListUsersToMessage.Unlock()
	return mock.GetSubscriptionListUsersToMessageFunc(ctx, workspaceID, listIDs, offset, limit)
}

// GetSubscriptionListUsersToMessageCalls gets all the calls that were made to GetSubscriptionListUsersToMessage.
// Check the length with:
//
//	len(mockedRepository.GetSubscriptionListUsersToMessageCalls())
func (mock *RepositoryMock) GetSubscriptionListUsersToMessageCalls() []struct {
	Ctx         context.Context
	WorkspaceID string
	ListIDs     []string
	Offset      int64
	Limit       int64
} {
	var calls []struct {
		Ctx         context.Context
		WorkspaceID string
		ListIDs     []string
		Offset      int64
		Limit       int64
	}
	mock.lockGetSubscriptionListUsersToMessage.RLock()
	calls = mock.calls.GetSubscriptionListUsersToMessage
	mock.lockGetSubscriptionListUsersToMessage.RUnlock()
	return calls
}

// GetSystemConnection calls GetSystemConnectionFunc.
func (mock *RepositoryMock) GetSystemConnection(ctx context.Context) (*sql.Conn, error) {
	if mock.GetSystemConnectionFunc == nil {
		panic("RepositoryMock.GetSystemConnectionFunc: method is nil but Repository.GetSystemConnection was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetSystemConnection.Lock()
	mock.calls.GetSystemConnection = append(mock.calls.GetSystemConnection, callInfo)
	mock.lockGetSystemConnection.Unlock()
	return mock.GetSystemConnectionFunc(ctx)
}

// GetSystemConnectionCalls gets all the calls that were made to GetSystemConnection.
// Check the length with:
//
//	len(mockedRepository.GetSystemConnectionCalls())
func (mock *RepositoryMock) GetSystemConnectionCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockGetSystemConnection.RLock()
	calls = mock.calls.GetSystemConnection
	mock.lockGetSystemConnection.RUnlock()
	return calls
}

// GetTask calls GetTaskFunc.
func (mock *RepositoryMock) GetTask(ctx context.Context, workspaceID string, taskID string, tx *sql.Tx) (*entity.Task, error) {
	if mock.GetTaskFunc == nil {
		panic("RepositoryMock.GetTaskFunc: method is nil but Repository.GetTask was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		WorkspaceID string
		TaskID      string
		Tx          *sql.Tx
	}{
		Ctx:         ctx,
		WorkspaceID: workspaceID,
		TaskID:      taskID,
		Tx:          tx,
	}
	mock.lockGetTask.Lock()
	mock.calls.GetTask = append(mock.calls.GetTask, callInfo)
	mock.lockGetTask.Unlock()
	return mock.GetTaskFunc(ctx, workspaceID, taskID, tx)
}

// GetTaskCalls gets all the calls that were made to GetTask.
// Check the length with:
//
//	len(mockedRepository.GetTaskCalls())
func (mock *RepositoryMock) GetTaskCalls() []struct {
	Ctx         context.Context
	WorkspaceID string
	TaskID      string
	Tx          *sql.Tx
} {
	var calls []struct {
		Ctx         context.Context
		WorkspaceID string
		TaskID      string
		Tx          *sql.Tx
	}
	mock.lockGetTask.RLock()
	calls = mock.calls.GetTask
	mock.lockGetTask.RUnlock()
	return calls
}

// GetTaskExec calls GetTaskExecFunc.
func (mock *RepositoryMock) GetTaskExec(ctx context.Context, workspaceID string, taskID string) (*entity.TaskExec, error) {
	if mock.GetTaskExecFunc == nil {
		panic("RepositoryMock.GetTaskExecFunc: method is nil but Repository.GetTaskExec was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		WorkspaceID string
		TaskID      string
	}{
		Ctx:         ctx,
		WorkspaceID: workspaceID,
		TaskID:      taskID,
	}
	mock.lockGetTaskExec.Lock()
	mock.calls.GetTaskExec = append(mock.calls.GetTaskExec, callInfo)
	mock.lockGetTaskExec.Unlock()
	return mock.GetTaskExecFunc(ctx, workspaceID, taskID)
}

// GetTaskExecCalls gets all the calls that were made to GetTaskExec.
// Check the length with:
//
//	len(mockedRepository.GetTaskExecCalls())
func (mock *RepositoryMock) GetTaskExecCalls() []struct {
	Ctx         context.Context
	WorkspaceID string
	TaskID      string
} {
	var calls []struct {
		Ctx         context.Context
		WorkspaceID string
		TaskID      string
	}
	mock.lockGetTaskExec.RLock()
	calls = mock.calls.GetTaskExec
	mock.lockGetTaskExec.RUnlock()
	return calls
}

// GetTaskExecJob calls GetTaskExecJobFunc.
func (mock *RepositoryMock) GetTaskExecJob(ctx context.Context, workspaceID string, jobID string) (*entity.TaskExecJob, error) {
	if mock.GetTaskExecJobFunc == nil {
		panic("RepositoryMock.GetTaskExecJobFunc: method is nil but Repository.GetTaskExecJob was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		WorkspaceID string
		JobID       string
	}{
		Ctx:         ctx,
		WorkspaceID: workspaceID,
		JobID:       jobID,
	}
	mock.lockGetTaskExecJob.Lock()
	mock.calls.GetTaskExecJob = append(mock.calls.GetTaskExecJob, callInfo)
	mock.lockGetTaskExecJob.Unlock()
	return mock.GetTaskExecJobFunc(ctx, workspaceID, jobID)
}

// GetTaskExecJobCalls gets all the calls that were made to GetTaskExecJob.
// Check the length with:
//
//	len(mockedRepository.GetTaskExecJobCalls())
func (mock *RepositoryMock) GetTaskExecJobCalls() []struct {
	Ctx         context.Context
	WorkspaceID string
	JobID       string
} {
	var calls []struct {
		Ctx         context.Context
		WorkspaceID string
		JobID       string
	}
	mock.lockGetTaskExecJob.RLock()
	calls = mock.calls.GetTaskExecJob
	mock.lockGetTaskExecJob.RUnlock()
	return calls
}

// GetTaskExecJobs calls GetTaskExecJobsFunc.
func (mock *RepositoryMock) GetTaskExecJobs(ctx context.Context, workspaceID string, taskExecID string, offset int, limit int) ([]*entity.TaskExecJob, int, error) {
	if mock.GetTaskExecJobsFunc == nil {
		panic("RepositoryMock.GetTaskExecJobsFunc: method is nil but Repository.GetTaskExecJobs was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		WorkspaceID string
		TaskExecID  string
		Offset      int
		Limit       int
	}{
		Ctx:         ctx,
		WorkspaceID: workspaceID,
		TaskExecID:  taskExecID,
		Offset:      offset,
		Limit:       limit,
	}
	mock.lockGetTaskExecJobs.Lock()
	mock.calls.GetTaskExecJobs = append(mock.calls.GetTaskExecJobs, callInfo)
	mock.lockGetTaskExecJobs.Unlock()
	return mock.GetTaskExecJobsFunc(ctx, workspaceID, taskExecID, offset, limit)
}

// GetTaskExecJobsCalls gets all the calls that were made to GetTaskExecJobs.
// Check the length with:
//
//	len(mockedRepository.GetTaskExecJobsCalls())
func (mock *RepositoryMock) GetTaskExecJobsCalls() []struct {
	Ctx         context.Context
	WorkspaceID string
	TaskExecID  string
	Offset      int
	Limit       int
} {
	var calls []struct {
		Ctx         context.Context
		WorkspaceID string
		TaskExecID  string
		Offset      int
		Limit       int
	}
	mock.lockGetTaskExecJobs.RLock()
	calls = mock.calls.GetTaskExecJobs
	mock.lockGetTaskExecJobs.RUnlock()
	return calls
}

// GetUsersNotInSubscriptionList calls GetUsersNotInSubscriptionListFunc.
func (mock *RepositoryMock) GetUsersNotInSubscriptionList(ctx context.Context, workspaceID string, listID string, offset int64, limit int64, segmentID *string) ([]*dto.UserToImportToSubscriptionList, error) {
	if mock.GetUsersNotInSubscriptionListFunc == nil {
		panic("RepositoryMock.GetUsersNotInSubscriptionListFunc: method is nil but Repository.GetUsersNotInSubscriptionList was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		WorkspaceID string
		ListID      string
		Offset      int64
		Limit       int64
		SegmentID   *string
	}{
		Ctx:         ctx,
		WorkspaceID: workspaceID,
		ListID:      listID,
		Offset:      offset,
		Limit:       limit,
		SegmentID:   segmentID,
	}
	mock.lockGetUsersNotInSubscriptionList.Lock()
	mock.calls.GetUsersNotInSubscriptionList = append(mock.calls.GetUsersNotInSubscriptionList, callInfo)
	mock.lockGetUsersNotInSubscriptionList.Unlock()
	return mock.GetUsersNotInSubscriptionListFunc(ctx, workspaceID, listID, offset, limit, segmentID)
}

// GetUsersNotInSubscriptionListCalls gets all the calls that were made to GetUsersNotInSubscriptionList.
// Check the length with:
//
//	len(mockedRepository.GetUsersNotInSubscriptionListCalls())
func (mock *RepositoryMock) GetUsersNotInSubscriptionListCalls() []struct {
	Ctx         context.Context
	WorkspaceID string
	ListID      string
	Offset      int64
	Limit       int64
	SegmentID   *string
} {
	var calls []struct {
		Ctx         context.Context
		WorkspaceID string
		ListID      string
		Offset      int64
		Limit       int64
		SegmentID   *string
	}
	mock.lockGetUsersNotInSubscriptionList.RLock()
	calls = mock.calls.GetUsersNotInSubscriptionList
	mock.lockGetUsersNotInSubscriptionList.RUnlock()
	return calls
}

// GetWorkspace calls GetWorkspaceFunc.
func (mock *RepositoryMock) GetWorkspace(ctx context.Context, workspaceID string) (*entity.Workspace, error) {
	if mock.GetWorkspaceFunc == nil {
		panic("RepositoryMock.GetWorkspaceFunc: method is nil but Repository.GetWorkspace was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		WorkspaceID string
	}{
		Ctx:         ctx,
		WorkspaceID: workspaceID,
	}
	mock.lockGetWorkspace.Lock()
	mock.calls.GetWorkspace = append(mock.calls.GetWorkspace, callInfo)
	mock.lockGetWorkspace.Unlock()
	return mock.GetWorkspaceFunc(ctx, workspaceID)
}

// GetWorkspaceCalls gets all the calls that were made to GetWorkspace.
// Check the length with:
//
//	len(mockedRepository.GetWorkspaceCalls())
func (mock *RepositoryMock) GetWorkspaceCalls() []struct {
	Ctx         context.Context
	WorkspaceID string
} {
	var calls []struct {
		Ctx         context.Context
		WorkspaceID string
	}
	mock.lockGetWorkspace.RLock()
	calls = mock.calls.GetWorkspace
	mock.lockGetWorkspace.RUnlock()
	return calls
}

// GetWorkspaceConnection calls GetWorkspaceConnectionFunc.
func (mock *RepositoryMock) GetWorkspaceConnection(ctx context.Context, workspaceID string) (*sql.Conn, error) {
	if mock.GetWorkspaceConnectionFunc == nil {
		panic("RepositoryMock.GetWorkspaceConnectionFunc: method is nil but Repository.GetWorkspaceConnection was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		WorkspaceID string
	}{
		Ctx:         ctx,
		WorkspaceID: workspaceID,
	}
	mock.lockGetWorkspaceConnection.Lock()
	mock.calls.GetWorkspaceConnection = append(mock.calls.GetWorkspaceConnection, callInfo)
	mock.lockGetWorkspaceConnection.Unlock()
	return mock.GetWorkspaceConnectionFunc(ctx, workspaceID)
}

// GetWorkspaceConnectionCalls gets all the calls that were made to GetWorkspaceConnection.
// Check the length with:
//
//	len(mockedRepository.GetWorkspaceConnectionCalls())
func (mock *RepositoryMock) GetWorkspaceConnectionCalls() []struct {
	Ctx         context.Context
	WorkspaceID string
} {
	var calls []struct {
		Ctx         context.Context
		WorkspaceID string
	}
	mock.lockGetWorkspaceConnection.RLock()
	calls = mock.calls.GetWorkspaceConnection
	mock.lockGetWorkspaceConnection.RUnlock()
	return calls
}

// HasDataLogsToReprocess calls HasDataLogsToReprocessFunc.
func (mock *RepositoryMock) HasDataLogsToReprocess(ctx context.Context, workspaceID string, untilDate time.Time) (bool, error) {
	if mock.HasDataLogsToReprocessFunc == nil {
		panic("RepositoryMock.HasDataLogsToReprocessFunc: method is nil but Repository.HasDataLogsToReprocess was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		WorkspaceID string
		UntilDate   time.Time
	}{
		Ctx:         ctx,
		WorkspaceID: workspaceID,
		UntilDate:   untilDate,
	}
	mock.lockHasDataLogsToReprocess.Lock()
	mock.calls.HasDataLogsToReprocess = append(mock.calls.HasDataLogsToReprocess, callInfo)
	mock.lockHasDataLogsToReprocess.Unlock()
	return mock.HasDataLogsToReprocessFunc(ctx, workspaceID, untilDate)
}

// HasDataLogsToReprocessCalls gets all the calls that were made to HasDataLogsToReprocess.
// Check the length with:
//
//	len(mockedRepository.HasDataLogsToReprocessCalls())
func (mock *RepositoryMock) HasDataLogsToReprocessCalls() []struct {
	Ctx         context.Context
	WorkspaceID string
	UntilDate   time.Time
} {
	var calls []struct {
		Ctx         context.Context
		WorkspaceID string
		UntilDate   time.Time
	}
	mock.lockHasDataLogsToReprocess.RLock()
	calls = mock.calls.HasDataLogsToReprocess
	mock.lockHasDataLogsToReprocess.RUnlock()
	return calls
}

// InsertAccount calls InsertAccountFunc.
func (mock *RepositoryMock) InsertAccount(ctx context.Context, account *entity.Account, organizationID string, fromAccountID string, tx *sql.Tx) error {
	if mock.InsertAccountFunc == nil {
		panic("RepositoryMock.InsertAccountFunc: method is nil but Repository.InsertAccount was just called")
	}
	callInfo := struct {
		Ctx            context.Context
		Account        *entity.Account
		OrganizationID string
		FromAccountID  string
		Tx             *sql.Tx
	}{
		Ctx:            ctx,
		Account:        account,
		OrganizationID: organizationID,
		FromAccountID:  fromAccountID,
		Tx:             tx,
	}
	mock.lockInsertAccount.Lock()
	mock.calls.InsertAccount = append(mock.calls.InsertAccount, callInfo)
	mock.lockInsertAccount.Unlock()
	return mock.InsertAccountFunc(ctx, account, organizationID, fromAccountID, tx)
}

// InsertAccountCalls gets all the calls that were made to InsertAccount.
// Check the length with:
//
//	len(mockedRepository.InsertAccountCalls())
func (mock *RepositoryMock) InsertAccountCalls() []struct {
	Ctx            context.Context
	Account        *entity.Account
	OrganizationID string
	FromAccountID  string
	Tx             *sql.Tx
} {
	var calls []struct {
		Ctx            context.Context
		Account        *entity.Account
		OrganizationID string
		FromAccountID  string
		Tx             *sql.Tx
	}
	mock.lockInsertAccount.RLock()
	calls = mock.calls.InsertAccount
	mock.lockInsertAccount.RUnlock()
	return calls
}

// InsertAccountSession calls InsertAccountSessionFunc.
func (mock *RepositoryMock) InsertAccountSession(ctx context.Context, accountSession *entity.AccountSession) error {
	if mock.InsertAccountSessionFunc == nil {
		panic("RepositoryMock.InsertAccountSessionFunc: method is nil but Repository.InsertAccountSession was just called")
	}
	callInfo := struct {
		Ctx            context.Context
		AccountSession *entity.AccountSession
	}{
		Ctx:            ctx,
		AccountSession: accountSession,
	}
	mock.lockInsertAccountSession.Lock()
	mock.calls.InsertAccountSession = append(mock.calls.InsertAccountSession, callInfo)
	mock.lockInsertAccountSession.Unlock()
	return mock.InsertAccountSessionFunc(ctx, accountSession)
}

// InsertAccountSessionCalls gets all the calls that were made to InsertAccountSession.
// Check the length with:
//
//	len(mockedRepository.InsertAccountSessionCalls())
func (mock *RepositoryMock) InsertAccountSessionCalls() []struct {
	Ctx            context.Context
	AccountSession *entity.AccountSession
} {
	var calls []struct {
		Ctx            context.Context
		AccountSession *entity.AccountSession
	}
	mock.lockInsertAccountSession.RLock()
	calls = mock.calls.InsertAccountSession
	mock.lockInsertAccountSession.RUnlock()
	return calls
}

// InsertApp calls InsertAppFunc.
func (mock *RepositoryMock) InsertApp(ctx context.Context, app *entity.App, tx *sql.Tx) error {
	if mock.InsertAppFunc == nil {
		panic("RepositoryMock.InsertAppFunc: method is nil but Repository.InsertApp was just called")
	}
	callInfo := struct {
		Ctx context.Context
		App *entity.App
		Tx  *sql.Tx
	}{
		Ctx: ctx,
		App: app,
		Tx:  tx,
	}
	mock.lockInsertApp.Lock()
	mock.calls.InsertApp = append(mock.calls.InsertApp, callInfo)
	mock.lockInsertApp.Unlock()
	return mock.InsertAppFunc(ctx, app, tx)
}

// InsertAppCalls gets all the calls that were made to InsertApp.
// Check the length with:
//
//	len(mockedRepository.InsertAppCalls())
func (mock *RepositoryMock) InsertAppCalls() []struct {
	Ctx context.Context
	App *entity.App
	Tx  *sql.Tx
} {
	var calls []struct {
		Ctx context.Context
		App *entity.App
		Tx  *sql.Tx
	}
	mock.lockInsertApp.RLock()
	calls = mock.calls.InsertApp
	mock.lockInsertApp.RUnlock()
	return calls
}

// InsertAppItem calls InsertAppItemFunc.
func (mock *RepositoryMock) InsertAppItem(ctx context.Context, kind string, upsertedAppItem *entity.AppItem, tx *sql.Tx) error {
	if mock.InsertAppItemFunc == nil {
		panic("RepositoryMock.InsertAppItemFunc: method is nil but Repository.InsertAppItem was just called")
	}
	callInfo := struct {
		Ctx             context.Context
		Kind            string
		UpsertedAppItem *entity.AppItem
		Tx              *sql.Tx
	}{
		Ctx:             ctx,
		Kind:            kind,
		UpsertedAppItem: upsertedAppItem,
		Tx:              tx,
	}
	mock.lockInsertAppItem.Lock()
	mock.calls.InsertAppItem = append(mock.calls.InsertAppItem, callInfo)
	mock.lockInsertAppItem.Unlock()
	return mock.InsertAppItemFunc(ctx, kind, upsertedAppItem, tx)
}

// InsertAppItemCalls gets all the calls that were made to InsertAppItem.
// Check the length with:
//
//	len(mockedRepository.InsertAppItemCalls())
func (mock *RepositoryMock) InsertAppItemCalls() []struct {
	Ctx             context.Context
	Kind            string
	UpsertedAppItem *entity.AppItem
	Tx              *sql.Tx
} {
	var calls []struct {
		Ctx             context.Context
		Kind            string
		UpsertedAppItem *entity.AppItem
		Tx              *sql.Tx
	}
	mock.lockInsertAppItem.RLock()
	calls = mock.calls.InsertAppItem
	mock.lockInsertAppItem.RUnlock()
	return calls
}

// InsertBroadcastCampaign calls InsertBroadcastCampaignFunc.
func (mock *RepositoryMock) InsertBroadcastCampaign(ctx context.Context, workspaceID string, campaign *entity.BroadcastCampaign) error {
	if mock.InsertBroadcastCampaignFunc == nil {
		panic("RepositoryMock.InsertBroadcastCampaignFunc: method is nil but Repository.InsertBroadcastCampaign was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		WorkspaceID string
		Campaign    *entity.BroadcastCampaign
	}{
		Ctx:         ctx,
		WorkspaceID: workspaceID,
		Campaign:    campaign,
	}
	mock.lockInsertBroadcastCampaign.Lock()
	mock.calls.InsertBroadcastCampaign = append(mock.calls.InsertBroadcastCampaign, callInfo)
	mock.lockInsertBroadcastCampaign.Unlock()
	return mock.InsertBroadcastCampaignFunc(ctx, workspaceID, campaign)
}

// InsertBroadcastCampaignCalls gets all the calls that were made to InsertBroadcastCampaign.
// Check the length with:
//
//	len(mockedRepository.InsertBroadcastCampaignCalls())
func (mock *RepositoryMock) InsertBroadcastCampaignCalls() []struct {
	Ctx         context.Context
	WorkspaceID string
	Campaign    *entity.BroadcastCampaign
} {
	var calls []struct {
		Ctx         context.Context
		WorkspaceID string
		Campaign    *entity.BroadcastCampaign
	}
	mock.lockInsertBroadcastCampaign.RLock()
	calls = mock.calls.InsertBroadcastCampaign
	mock.lockInsertBroadcastCampaign.RUnlock()
	return calls
}

// InsertCart calls InsertCartFunc.
func (mock *RepositoryMock) InsertCart(ctx context.Context, cart *entity.Cart, tx *sql.Tx) error {
	if mock.InsertCartFunc == nil {
		panic("RepositoryMock.InsertCartFunc: method is nil but Repository.InsertCart was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Cart *entity.Cart
		Tx   *sql.Tx
	}{
		Ctx:  ctx,
		Cart: cart,
		Tx:   tx,
	}
	mock.lockInsertCart.Lock()
	mock.calls.InsertCart = append(mock.calls.InsertCart, callInfo)
	mock.lockInsertCart.Unlock()
	return mock.InsertCartFunc(ctx, cart, tx)
}

// InsertCartCalls gets all the calls that were made to InsertCart.
// Check the length with:
//
//	len(mockedRepository.InsertCartCalls())
func (mock *RepositoryMock) InsertCartCalls() []struct {
	Ctx  context.Context
	Cart *entity.Cart
	Tx   *sql.Tx
} {
	var calls []struct {
		Ctx  context.Context
		Cart *entity.Cart
		Tx   *sql.Tx
	}
	mock.lockInsertCart.RLock()
	calls = mock.calls.InsertCart
	mock.lockInsertCart.RUnlock()
	return calls
}

// InsertCartItem calls InsertCartItemFunc.
func (mock *RepositoryMock) InsertCartItem(ctx context.Context, cartItem *entity.CartItem, tx *sql.Tx) error {
	if mock.InsertCartItemFunc == nil {
		panic("RepositoryMock.InsertCartItemFunc: method is nil but Repository.InsertCartItem was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		CartItem *entity.CartItem
		Tx       *sql.Tx
	}{
		Ctx:      ctx,
		CartItem: cartItem,
		Tx:       tx,
	}
	mock.lockInsertCartItem.Lock()
	mock.calls.InsertCartItem = append(mock.calls.InsertCartItem, callInfo)
	mock.lockInsertCartItem.Unlock()
	return mock.InsertCartItemFunc(ctx, cartItem, tx)
}

// InsertCartItemCalls gets all the calls that were made to InsertCartItem.
// Check the length with:
//
//	len(mockedRepository.InsertCartItemCalls())
func (mock *RepositoryMock) InsertCartItemCalls() []struct {
	Ctx      context.Context
	CartItem *entity.CartItem
	Tx       *sql.Tx
} {
	var calls []struct {
		Ctx      context.Context
		CartItem *entity.CartItem
		Tx       *sql.Tx
	}
	mock.lockInsertCartItem.RLock()
	calls = mock.calls.InsertCartItem
	mock.lockInsertCartItem.RUnlock()
	return calls
}

// InsertCustomEvent calls InsertCustomEventFunc.
func (mock *RepositoryMock) InsertCustomEvent(ctx context.Context, event *entity.CustomEvent, tx *sql.Tx) error {
	if mock.InsertCustomEventFunc == nil {
		panic("RepositoryMock.InsertCustomEventFunc: method is nil but Repository.InsertCustomEvent was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Event *entity.CustomEvent
		Tx    *sql.Tx
	}{
		Ctx:   ctx,
		Event: event,
		Tx:    tx,
	}
	mock.lockInsertCustomEvent.Lock()
	mock.calls.InsertCustomEvent = append(mock.calls.InsertCustomEvent, callInfo)
	mock.lockInsertCustomEvent.Unlock()
	return mock.InsertCustomEventFunc(ctx, event, tx)
}

// InsertCustomEventCalls gets all the calls that were made to InsertCustomEvent.
// Check the length with:
//
//	len(mockedRepository.InsertCustomEventCalls())
func (mock *RepositoryMock) InsertCustomEventCalls() []struct {
	Ctx   context.Context
	Event *entity.CustomEvent
	Tx    *sql.Tx
} {
	var calls []struct {
		Ctx   context.Context
		Event *entity.CustomEvent
		Tx    *sql.Tx
	}
	mock.lockInsertCustomEvent.RLock()
	calls = mock.calls.InsertCustomEvent
	mock.lockInsertCustomEvent.RUnlock()
	return calls
}

// InsertDataLog calls InsertDataLogFunc.
func (mock *RepositoryMock) InsertDataLog(ctx context.Context, workspaceID string, dataLog *entity.DataLog, tx *sql.Tx) error {
	if mock.InsertDataLogFunc == nil {
		panic("RepositoryMock.InsertDataLogFunc: method is nil but Repository.InsertDataLog was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		WorkspaceID string
		DataLog     *entity.DataLog
		Tx          *sql.Tx
	}{
		Ctx:         ctx,
		WorkspaceID: workspaceID,
		DataLog:     dataLog,
		Tx:          tx,
	}
	mock.lockInsertDataLog.Lock()
	mock.calls.InsertDataLog = append(mock.calls.InsertDataLog, callInfo)
	mock.lockInsertDataLog.Unlock()
	return mock.InsertDataLogFunc(ctx, workspaceID, dataLog, tx)
}

// InsertDataLogCalls gets all the calls that were made to InsertDataLog.
// Check the length with:
//
//	len(mockedRepository.InsertDataLogCalls())
func (mock *RepositoryMock) InsertDataLogCalls() []struct {
	Ctx         context.Context
	WorkspaceID string
	DataLog     *entity.DataLog
	Tx          *sql.Tx
} {
	var calls []struct {
		Ctx         context.Context
		WorkspaceID string
		DataLog     *entity.DataLog
		Tx          *sql.Tx
	}
	mock.lockInsertDataLog.RLock()
	calls = mock.calls.InsertDataLog
	mock.lockInsertDataLog.RUnlock()
	return calls
}

// InsertDevice calls InsertDeviceFunc.
func (mock *RepositoryMock) InsertDevice(ctx context.Context, device *entity.Device, tx *sql.Tx) error {
	if mock.InsertDeviceFunc == nil {
		panic("RepositoryMock.InsertDeviceFunc: method is nil but Repository.InsertDevice was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Device *entity.Device
		Tx     *sql.Tx
	}{
		Ctx:    ctx,
		Device: device,
		Tx:     tx,
	}
	mock.lockInsertDevice.Lock()
	mock.calls.InsertDevice = append(mock.calls.InsertDevice, callInfo)
	mock.lockInsertDevice.Unlock()
	return mock.InsertDeviceFunc(ctx, device, tx)
}

// InsertDeviceCalls gets all the calls that were made to InsertDevice.
// Check the length with:
//
//	len(mockedRepository.InsertDeviceCalls())
func (mock *RepositoryMock) InsertDeviceCalls() []struct {
	Ctx    context.Context
	Device *entity.Device
	Tx     *sql.Tx
} {
	var calls []struct {
		Ctx    context.Context
		Device *entity.Device
		Tx     *sql.Tx
	}
	mock.lockInsertDevice.RLock()
	calls = mock.calls.InsertDevice
	mock.lockInsertDevice.RUnlock()
	return calls
}

// InsertMessage calls InsertMessageFunc.
func (mock *RepositoryMock) InsertMessage(ctx context.Context, message *entity.Message, tx *sql.Tx) error {
	if mock.InsertMessageFunc == nil {
		panic("RepositoryMock.InsertMessageFunc: method is nil but Repository.InsertMessage was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Message *entity.Message
		Tx      *sql.Tx
	}{
		Ctx:     ctx,
		Message: message,
		Tx:      tx,
	}
	mock.lockInsertMessage.Lock()
	mock.calls.InsertMessage = append(mock.calls.InsertMessage, callInfo)
	mock.lockInsertMessage.Unlock()
	return mock.InsertMessageFunc(ctx, message, tx)
}

// InsertMessageCalls gets all the calls that were made to InsertMessage.
// Check the length with:
//
//	len(mockedRepository.InsertMessageCalls())
func (mock *RepositoryMock) InsertMessageCalls() []struct {
	Ctx     context.Context
	Message *entity.Message
	Tx      *sql.Tx
} {
	var calls []struct {
		Ctx     context.Context
		Message *entity.Message
		Tx      *sql.Tx
	}
	mock.lockInsertMessage.RLock()
	calls = mock.calls.InsertMessage
	mock.lockInsertMessage.RUnlock()
	return calls
}

// InsertMessageTemplate calls InsertMessageTemplateFunc.
func (mock *RepositoryMock) InsertMessageTemplate(ctx context.Context, workspaceID string, template *entity.MessageTemplate, tx *sql.Tx) error {
	if mock.InsertMessageTemplateFunc == nil {
		panic("RepositoryMock.InsertMessageTemplateFunc: method is nil but Repository.InsertMessageTemplate was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		WorkspaceID string
		Template    *entity.MessageTemplate
		Tx          *sql.Tx
	}{
		Ctx:         ctx,
		WorkspaceID: workspaceID,
		Template:    template,
		Tx:          tx,
	}
	mock.lockInsertMessageTemplate.Lock()
	mock.calls.InsertMessageTemplate = append(mock.calls.InsertMessageTemplate, callInfo)
	mock.lockInsertMessageTemplate.Unlock()
	return mock.InsertMessageTemplateFunc(ctx, workspaceID, template, tx)
}

// InsertMessageTemplateCalls gets all the calls that were made to InsertMessageTemplate.
// Check the length with:
//
//	len(mockedRepository.InsertMessageTemplateCalls())
func (mock *RepositoryMock) InsertMessageTemplateCalls() []struct {
	Ctx         context.Context
	WorkspaceID string
	Template    *entity.MessageTemplate
	Tx          *sql.Tx
} {
	var calls []struct {
		Ctx         context.Context
		WorkspaceID string
		Template    *entity.MessageTemplate
		Tx          *sql.Tx
	}
	mock.lockInsertMessageTemplate.RLock()
	calls = mock.calls.InsertMessageTemplate
	mock.lockInsertMessageTemplate.RUnlock()
	return calls
}

// InsertOrder calls InsertOrderFunc.
func (mock *RepositoryMock) InsertOrder(ctx context.Context, order *entity.Order, tx *sql.Tx) error {
	if mock.InsertOrderFunc == nil {
		panic("RepositoryMock.InsertOrderFunc: method is nil but Repository.InsertOrder was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Order *entity.Order
		Tx    *sql.Tx
	}{
		Ctx:   ctx,
		Order: order,
		Tx:    tx,
	}
	mock.lockInsertOrder.Lock()
	mock.calls.InsertOrder = append(mock.calls.InsertOrder, callInfo)
	mock.lockInsertOrder.Unlock()
	return mock.InsertOrderFunc(ctx, order, tx)
}

// InsertOrderCalls gets all the calls that were made to InsertOrder.
// Check the length with:
//
//	len(mockedRepository.InsertOrderCalls())
func (mock *RepositoryMock) InsertOrderCalls() []struct {
	Ctx   context.Context
	Order *entity.Order
	Tx    *sql.Tx
} {
	var calls []struct {
		Ctx   context.Context
		Order *entity.Order
		Tx    *sql.Tx
	}
	mock.lockInsertOrder.RLock()
	calls = mock.calls.InsertOrder
	mock.lockInsertOrder.RUnlock()
	return calls
}

// InsertOrderItem calls InsertOrderItemFunc.
func (mock *RepositoryMock) InsertOrderItem(ctx context.Context, orderItem *entity.OrderItem, tx *sql.Tx) error {
	if mock.InsertOrderItemFunc == nil {
		panic("RepositoryMock.InsertOrderItemFunc: method is nil but Repository.InsertOrderItem was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		OrderItem *entity.OrderItem
		Tx        *sql.Tx
	}{
		Ctx:       ctx,
		OrderItem: orderItem,
		Tx:        tx,
	}
	mock.lockInsertOrderItem.Lock()
	mock.calls.InsertOrderItem = append(mock.calls.InsertOrderItem, callInfo)
	mock.lockInsertOrderItem.Unlock()
	return mock.InsertOrderItemFunc(ctx, orderItem, tx)
}

// InsertOrderItemCalls gets all the calls that were made to InsertOrderItem.
// Check the length with:
//
//	len(mockedRepository.InsertOrderItemCalls())
func (mock *RepositoryMock) InsertOrderItemCalls() []struct {
	Ctx       context.Context
	OrderItem *entity.OrderItem
	Tx        *sql.Tx
} {
	var calls []struct {
		Ctx       context.Context
		OrderItem *entity.OrderItem
		Tx        *sql.Tx
	}
	mock.lockInsertOrderItem.RLock()
	calls = mock.calls.InsertOrderItem
	mock.lockInsertOrderItem.RUnlock()
	return calls
}

// InsertPageview calls InsertPageviewFunc.
func (mock *RepositoryMock) InsertPageview(ctx context.Context, pageview *entity.Pageview, tx *sql.Tx) error {
	if mock.InsertPageviewFunc == nil {
		panic("RepositoryMock.InsertPageviewFunc: method is nil but Repository.InsertPageview was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Pageview *entity.Pageview
		Tx       *sql.Tx
	}{
		Ctx:      ctx,
		Pageview: pageview,
		Tx:       tx,
	}
	mock.lockInsertPageview.Lock()
	mock.calls.InsertPageview = append(mock.calls.InsertPageview, callInfo)
	mock.lockInsertPageview.Unlock()
	return mock.InsertPageviewFunc(ctx, pageview, tx)
}

// InsertPageviewCalls gets all the calls that were made to InsertPageview.
// Check the length with:
//
//	len(mockedRepository.InsertPageviewCalls())
func (mock *RepositoryMock) InsertPageviewCalls() []struct {
	Ctx      context.Context
	Pageview *entity.Pageview
	Tx       *sql.Tx
} {
	var calls []struct {
		Ctx      context.Context
		Pageview *entity.Pageview
		Tx       *sql.Tx
	}
	mock.lockInsertPageview.RLock()
	calls = mock.calls.InsertPageview
	mock.lockInsertPageview.RUnlock()
	return calls
}

// InsertPostview calls InsertPostviewFunc.
func (mock *RepositoryMock) InsertPostview(ctx context.Context, postview *entity.Postview, tx *sql.Tx) error {
	if mock.InsertPostviewFunc == nil {
		panic("RepositoryMock.InsertPostviewFunc: method is nil but Repository.InsertPostview was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Postview *entity.Postview
		Tx       *sql.Tx
	}{
		Ctx:      ctx,
		Postview: postview,
		Tx:       tx,
	}
	mock.lockInsertPostview.Lock()
	mock.calls.InsertPostview = append(mock.calls.InsertPostview, callInfo)
	mock.lockInsertPostview.Unlock()
	return mock.InsertPostviewFunc(ctx, postview, tx)
}

// InsertPostviewCalls gets all the calls that were made to InsertPostview.
// Check the length with:
//
//	len(mockedRepository.InsertPostviewCalls())
func (mock *RepositoryMock) InsertPostviewCalls() []struct {
	Ctx      context.Context
	Postview *entity.Postview
	Tx       *sql.Tx
} {
	var calls []struct {
		Ctx      context.Context
		Postview *entity.Postview
		Tx       *sql.Tx
	}
	mock.lockInsertPostview.RLock()
	calls = mock.calls.InsertPostview
	mock.lockInsertPostview.RUnlock()
	return calls
}

// InsertSegment calls InsertSegmentFunc.
func (mock *RepositoryMock) InsertSegment(ctx context.Context, segment *entity.Segment, tx *sql.Tx) error {
	if mock.InsertSegmentFunc == nil {
		panic("RepositoryMock.InsertSegmentFunc: method is nil but Repository.InsertSegment was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Segment *entity.Segment
		Tx      *sql.Tx
	}{
		Ctx:     ctx,
		Segment: segment,
		Tx:      tx,
	}
	mock.lockInsertSegment.Lock()
	mock.calls.InsertSegment = append(mock.calls.InsertSegment, callInfo)
	mock.lockInsertSegment.Unlock()
	return mock.InsertSegmentFunc(ctx, segment, tx)
}

// InsertSegmentCalls gets all the calls that were made to InsertSegment.
// Check the length with:
//
//	len(mockedRepository.InsertSegmentCalls())
func (mock *RepositoryMock) InsertSegmentCalls() []struct {
	Ctx     context.Context
	Segment *entity.Segment
	Tx      *sql.Tx
} {
	var calls []struct {
		Ctx     context.Context
		Segment *entity.Segment
		Tx      *sql.Tx
	}
	mock.lockInsertSegment.RLock()
	calls = mock.calls.InsertSegment
	mock.lockInsertSegment.RUnlock()
	return calls
}

// InsertSegmentDataLogs calls InsertSegmentDataLogsFunc.
func (mock *RepositoryMock) InsertSegmentDataLogs(ctx context.Context, workspaceID string, segmentID string, segmentVersion int, taskID string, isEnter bool, createdAt time.Time, checkpoint int) error {
	if mock.InsertSegmentDataLogsFunc == nil {
		panic("RepositoryMock.InsertSegmentDataLogsFunc: method is nil but Repository.InsertSegmentDataLogs was just called")
	}
	callInfo := struct {
		Ctx            context.Context
		WorkspaceID    string
		SegmentID      string
		SegmentVersion int
		TaskID         string
		IsEnter        bool
		CreatedAt      time.Time
		Checkpoint     int
	}{
		Ctx:            ctx,
		WorkspaceID:    workspaceID,
		SegmentID:      segmentID,
		SegmentVersion: segmentVersion,
		TaskID:         taskID,
		IsEnter:        isEnter,
		CreatedAt:      createdAt,
		Checkpoint:     checkpoint,
	}
	mock.lockInsertSegmentDataLogs.Lock()
	mock.calls.InsertSegmentDataLogs = append(mock.calls.InsertSegmentDataLogs, callInfo)
	mock.lockInsertSegmentDataLogs.Unlock()
	return mock.InsertSegmentDataLogsFunc(ctx, workspaceID, segmentID, segmentVersion, taskID, isEnter, createdAt, checkpoint)
}

// InsertSegmentDataLogsCalls gets all the calls that were made to InsertSegmentDataLogs.
// Check the length with:
//
//	len(mockedRepository.InsertSegmentDataLogsCalls())
func (mock *RepositoryMock) InsertSegmentDataLogsCalls() []struct {
	Ctx            context.Context
	WorkspaceID    string
	SegmentID      string
	SegmentVersion int
	TaskID         string
	IsEnter        bool
	CreatedAt      time.Time
	Checkpoint     int
} {
	var calls []struct {
		Ctx            context.Context
		WorkspaceID    string
		SegmentID      string
		SegmentVersion int
		TaskID         string
		IsEnter        bool
		CreatedAt      time.Time
		Checkpoint     int
	}
	mock.lockInsertSegmentDataLogs.RLock()
	calls = mock.calls.InsertSegmentDataLogs
	mock.lockInsertSegmentDataLogs.RUnlock()
	return calls
}

// InsertServiceAccount calls InsertServiceAccountFunc.
func (mock *RepositoryMock) InsertServiceAccount(ctx context.Context, account *entity.Account, organizationID string, fromAccountID string, workspaceScopes entity.WorkspacesScopes) error {
	if mock.InsertServiceAccountFunc == nil {
		panic("RepositoryMock.InsertServiceAccountFunc: method is nil but Repository.InsertServiceAccount was just called")
	}
	callInfo := struct {
		Ctx             context.Context
		Account         *entity.Account
		OrganizationID  string
		FromAccountID   string
		WorkspaceScopes entity.WorkspacesScopes
	}{
		Ctx:             ctx,
		Account:         account,
		OrganizationID:  organizationID,
		FromAccountID:   fromAccountID,
		WorkspaceScopes: workspaceScopes,
	}
	mock.lockInsertServiceAccount.Lock()
	mock.calls.InsertServiceAccount = append(mock.calls.InsertServiceAccount, callInfo)
	mock.lockInsertServiceAccount.Unlock()
	return mock.InsertServiceAccountFunc(ctx, account, organizationID, fromAccountID, workspaceScopes)
}

// InsertServiceAccountCalls gets all the calls that were made to InsertServiceAccount.
// Check the length with:
//
//	len(mockedRepository.InsertServiceAccountCalls())
func (mock *RepositoryMock) InsertServiceAccountCalls() []struct {
	Ctx             context.Context
	Account         *entity.Account
	OrganizationID  string
	FromAccountID   string
	WorkspaceScopes entity.WorkspacesScopes
} {
	var calls []struct {
		Ctx             context.Context
		Account         *entity.Account
		OrganizationID  string
		FromAccountID   string
		WorkspaceScopes entity.WorkspacesScopes
	}
	mock.lockInsertServiceAccount.RLock()
	calls = mock.calls.InsertServiceAccount
	mock.lockInsertServiceAccount.RUnlock()
	return calls
}

// InsertSession calls InsertSessionFunc.
func (mock *RepositoryMock) InsertSession(ctx context.Context, session *entity.Session, tx *sql.Tx) error {
	if mock.InsertSessionFunc == nil {
		panic("RepositoryMock.InsertSessionFunc: method is nil but Repository.InsertSession was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Session *entity.Session
		Tx      *sql.Tx
	}{
		Ctx:     ctx,
		Session: session,
		Tx:      tx,
	}
	mock.lockInsertSession.Lock()
	mock.calls.InsertSession = append(mock.calls.InsertSession, callInfo)
	mock.lockInsertSession.Unlock()
	return mock.InsertSessionFunc(ctx, session, tx)
}

// InsertSessionCalls gets all the calls that were made to InsertSession.
// Check the length with:
//
//	len(mockedRepository.InsertSessionCalls())
func (mock *RepositoryMock) InsertSessionCalls() []struct {
	Ctx     context.Context
	Session *entity.Session
	Tx      *sql.Tx
} {
	var calls []struct {
		Ctx     context.Context
		Session *entity.Session
		Tx      *sql.Tx
	}
	mock.lockInsertSession.RLock()
	calls = mock.calls.InsertSession
	mock.lockInsertSession.RUnlock()
	return calls
}

// InsertSubscriptionListUser calls InsertSubscriptionListUserFunc.
func (mock *RepositoryMock) InsertSubscriptionListUser(ctx context.Context, subscription *entity.SubscriptionListUser, tx *sql.Tx) error {
	if mock.InsertSubscriptionListUserFunc == nil {
		panic("RepositoryMock.InsertSubscriptionListUserFunc: method is nil but Repository.InsertSubscriptionListUser was just called")
	}
	callInfo := struct {
		Ctx          context.Context
		Subscription *entity.SubscriptionListUser
		Tx           *sql.Tx
	}{
		Ctx:          ctx,
		Subscription: subscription,
		Tx:           tx,
	}
	mock.lockInsertSubscriptionListUser.Lock()
	mock.calls.InsertSubscriptionListUser = append(mock.calls.InsertSubscriptionListUser, callInfo)
	mock.lockInsertSubscriptionListUser.Unlock()
	return mock.InsertSubscriptionListUserFunc(ctx, subscription, tx)
}

// InsertSubscriptionListUserCalls gets all the calls that were made to InsertSubscriptionListUser.
// Check the length with:
//
//	len(mockedRepository.InsertSubscriptionListUserCalls())
func (mock *RepositoryMock) InsertSubscriptionListUserCalls() []struct {
	Ctx          context.Context
	Subscription *entity.SubscriptionListUser
	Tx           *sql.Tx
} {
	var calls []struct {
		Ctx          context.Context
		Subscription *entity.SubscriptionListUser
		Tx           *sql.Tx
	}
	mock.lockInsertSubscriptionListUser.RLock()
	calls = mock.calls.InsertSubscriptionListUser
	mock.lockInsertSubscriptionListUser.RUnlock()
	return calls
}

// InsertTask calls InsertTaskFunc.
func (mock *RepositoryMock) InsertTask(ctx context.Context, task *entity.Task, tx *sql.Tx) error {
	if mock.InsertTaskFunc == nil {
		panic("RepositoryMock.InsertTaskFunc: method is nil but Repository.InsertTask was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Task *entity.Task
		Tx   *sql.Tx
	}{
		Ctx:  ctx,
		Task: task,
		Tx:   tx,
	}
	mock.lockInsertTask.Lock()
	mock.calls.InsertTask = append(mock.calls.InsertTask, callInfo)
	mock.lockInsertTask.Unlock()
	return mock.InsertTaskFunc(ctx, task, tx)
}

// InsertTaskCalls gets all the calls that were made to InsertTask.
// Check the length with:
//
//	len(mockedRepository.InsertTaskCalls())
func (mock *RepositoryMock) InsertTaskCalls() []struct {
	Ctx  context.Context
	Task *entity.Task
	Tx   *sql.Tx
} {
	var calls []struct {
		Ctx  context.Context
		Task *entity.Task
		Tx   *sql.Tx
	}
	mock.lockInsertTask.RLock()
	calls = mock.calls.InsertTask
	mock.lockInsertTask.RUnlock()
	return calls
}

// InsertTaskExec calls InsertTaskExecFunc.
func (mock *RepositoryMock) InsertTaskExec(ctx context.Context, workspaceID string, task *entity.TaskExec, job *entity.TaskExecJob, tx *sql.Tx) error {
	if mock.InsertTaskExecFunc == nil {
		panic("RepositoryMock.InsertTaskExecFunc: method is nil but Repository.InsertTaskExec was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		WorkspaceID string
		Task        *entity.TaskExec
		Job         *entity.TaskExecJob
		Tx          *sql.Tx
	}{
		Ctx:         ctx,
		WorkspaceID: workspaceID,
		Task:        task,
		Job:         job,
		Tx:          tx,
	}
	mock.lockInsertTaskExec.Lock()
	mock.calls.InsertTaskExec = append(mock.calls.InsertTaskExec, callInfo)
	mock.lockInsertTaskExec.Unlock()
	return mock.InsertTaskExecFunc(ctx, workspaceID, task, job, tx)
}

// InsertTaskExecCalls gets all the calls that were made to InsertTaskExec.
// Check the length with:
//
//	len(mockedRepository.InsertTaskExecCalls())
func (mock *RepositoryMock) InsertTaskExecCalls() []struct {
	Ctx         context.Context
	WorkspaceID string
	Task        *entity.TaskExec
	Job         *entity.TaskExecJob
	Tx          *sql.Tx
} {
	var calls []struct {
		Ctx         context.Context
		WorkspaceID string
		Task        *entity.TaskExec
		Job         *entity.TaskExecJob
		Tx          *sql.Tx
	}
	mock.lockInsertTaskExec.RLock()
	calls = mock.calls.InsertTaskExec
	mock.lockInsertTaskExec.RUnlock()
	return calls
}

// InsertUser calls InsertUserFunc.
func (mock *RepositoryMock) InsertUser(ctx context.Context, user *entity.User, tx *sql.Tx) error {
	if mock.InsertUserFunc == nil {
		panic("RepositoryMock.InsertUserFunc: method is nil but Repository.InsertUser was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		User *entity.User
		Tx   *sql.Tx
	}{
		Ctx:  ctx,
		User: user,
		Tx:   tx,
	}
	mock.lockInsertUser.Lock()
	mock.calls.InsertUser = append(mock.calls.InsertUser, callInfo)
	mock.lockInsertUser.Unlock()
	return mock.InsertUserFunc(ctx, user, tx)
}

// InsertUserCalls gets all the calls that were made to InsertUser.
// Check the length with:
//
//	len(mockedRepository.InsertUserCalls())
func (mock *RepositoryMock) InsertUserCalls() []struct {
	Ctx  context.Context
	User *entity.User
	Tx   *sql.Tx
} {
	var calls []struct {
		Ctx  context.Context
		User *entity.User
		Tx   *sql.Tx
	}
	mock.lockInsertUser.RLock()
	calls = mock.calls.InsertUser
	mock.lockInsertUser.RUnlock()
	return calls
}

// InsertUserSegment calls InsertUserSegmentFunc.
func (mock *RepositoryMock) InsertUserSegment(ctx context.Context, userSegment *entity.UserSegment, tx *sql.Tx) error {
	if mock.InsertUserSegmentFunc == nil {
		panic("RepositoryMock.InsertUserSegmentFunc: method is nil but Repository.InsertUserSegment was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		UserSegment *entity.UserSegment
		Tx          *sql.Tx
	}{
		Ctx:         ctx,
		UserSegment: userSegment,
		Tx:          tx,
	}
	mock.lockInsertUserSegment.Lock()
	mock.calls.InsertUserSegment = append(mock.calls.InsertUserSegment, callInfo)
	mock.lockInsertUserSegment.Unlock()
	return mock.InsertUserSegmentFunc(ctx, userSegment, tx)
}

// InsertUserSegmentCalls gets all the calls that were made to InsertUserSegment.
// Check the length with:
//
//	len(mockedRepository.InsertUserSegmentCalls())
func (mock *RepositoryMock) InsertUserSegmentCalls() []struct {
	Ctx         context.Context
	UserSegment *entity.UserSegment
	Tx          *sql.Tx
} {
	var calls []struct {
		Ctx         context.Context
		UserSegment *entity.UserSegment
		Tx          *sql.Tx
	}
	mock.lockInsertUserSegment.RLock()
	calls = mock.calls.InsertUserSegment
	mock.lockInsertUserSegment.RUnlock()
	return calls
}

// InsertWorkspace calls InsertWorkspaceFunc.
func (mock *RepositoryMock) InsertWorkspace(ctx context.Context, workspace *entity.Workspace, tx *sql.Tx) error {
	if mock.InsertWorkspaceFunc == nil {
		panic("RepositoryMock.InsertWorkspaceFunc: method is nil but Repository.InsertWorkspace was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Workspace *entity.Workspace
		Tx        *sql.Tx
	}{
		Ctx:       ctx,
		Workspace: workspace,
		Tx:        tx,
	}
	mock.lockInsertWorkspace.Lock()
	mock.calls.InsertWorkspace = append(mock.calls.InsertWorkspace, callInfo)
	mock.lockInsertWorkspace.Unlock()
	return mock.InsertWorkspaceFunc(ctx, workspace, tx)
}

// InsertWorkspaceCalls gets all the calls that were made to InsertWorkspace.
// Check the length with:
//
//	len(mockedRepository.InsertWorkspaceCalls())
func (mock *RepositoryMock) InsertWorkspaceCalls() []struct {
	Ctx       context.Context
	Workspace *entity.Workspace
	Tx        *sql.Tx
} {
	var calls []struct {
		Ctx       context.Context
		Workspace *entity.Workspace
		Tx        *sql.Tx
	}
	mock.lockInsertWorkspace.RLock()
	calls = mock.calls.InsertWorkspace
	mock.lockInsertWorkspace.RUnlock()
	return calls
}

// Install calls InstallFunc.
func (mock *RepositoryMock) Install(ctx context.Context, rootAccount *entity.Account, defaultOrganization *entity.Organization) error {
	if mock.InstallFunc == nil {
		panic("RepositoryMock.InstallFunc: method is nil but Repository.Install was just called")
	}
	callInfo := struct {
		Ctx                 context.Context
		RootAccount         *entity.Account
		DefaultOrganization *entity.Organization
	}{
		Ctx:                 ctx,
		RootAccount:         rootAccount,
		DefaultOrganization: defaultOrganization,
	}
	mock.lockInstall.Lock()
	mock.calls.Install = append(mock.calls.Install, callInfo)
	mock.lockInstall.Unlock()
	return mock.InstallFunc(ctx, rootAccount, defaultOrganization)
}

// InstallCalls gets all the calls that were made to Install.
// Check the length with:
//
//	len(mockedRepository.InstallCalls())
func (mock *RepositoryMock) InstallCalls() []struct {
	Ctx                 context.Context
	RootAccount         *entity.Account
	DefaultOrganization *entity.Organization
} {
	var calls []struct {
		Ctx                 context.Context
		RootAccount         *entity.Account
		DefaultOrganization *entity.Organization
	}
	mock.lockInstall.RLock()
	calls = mock.calls.Install
	mock.lockInstall.RUnlock()
	return calls
}

// IsAccountOfOrganization calls IsAccountOfOrganizationFunc.
func (mock *RepositoryMock) IsAccountOfOrganization(ctx context.Context, accountId string, organizationId string, shouldBeOwner bool) (bool, error) {
	if mock.IsAccountOfOrganizationFunc == nil {
		panic("RepositoryMock.IsAccountOfOrganizationFunc: method is nil but Repository.IsAccountOfOrganization was just called")
	}
	callInfo := struct {
		Ctx            context.Context
		AccountId      string
		OrganizationId string
		ShouldBeOwner  bool
	}{
		Ctx:            ctx,
		AccountId:      accountId,
		OrganizationId: organizationId,
		ShouldBeOwner:  shouldBeOwner,
	}
	mock.lockIsAccountOfOrganization.Lock()
	mock.calls.IsAccountOfOrganization = append(mock.calls.IsAccountOfOrganization, callInfo)
	mock.lockIsAccountOfOrganization.Unlock()
	return mock.IsAccountOfOrganizationFunc(ctx, accountId, organizationId, shouldBeOwner)
}

// IsAccountOfOrganizationCalls gets all the calls that were made to IsAccountOfOrganization.
// Check the length with:
//
//	len(mockedRepository.IsAccountOfOrganizationCalls())
func (mock *RepositoryMock) IsAccountOfOrganizationCalls() []struct {
	Ctx            context.Context
	AccountId      string
	OrganizationId string
	ShouldBeOwner  bool
} {
	var calls []struct {
		Ctx            context.Context
		AccountId      string
		OrganizationId string
		ShouldBeOwner  bool
	}
	mock.lockIsAccountOfOrganization.RLock()
	calls = mock.calls.IsAccountOfOrganization
	mock.lockIsAccountOfOrganization.RUnlock()
	return calls
}

// IsDuplicateEntry calls IsDuplicateEntryFunc.
func (mock *RepositoryMock) IsDuplicateEntry(err error) bool {
	if mock.IsDuplicateEntryFunc == nil {
		panic("RepositoryMock.IsDuplicateEntryFunc: method is nil but Repository.IsDuplicateEntry was just called")
	}
	callInfo := struct {
		Err error
	}{
		Err: err,
	}
	mock.lockIsDuplicateEntry.Lock()
	mock.calls.IsDuplicateEntry = append(mock.calls.IsDuplicateEntry, callInfo)
	mock.lockIsDuplicateEntry.Unlock()
	return mock.IsDuplicateEntryFunc(err)
}

// IsDuplicateEntryCalls gets all the calls that were made to IsDuplicateEntry.
// Check the length with:
//
//	len(mockedRepository.IsDuplicateEntryCalls())
func (mock *RepositoryMock) IsDuplicateEntryCalls() []struct {
	Err error
} {
	var calls []struct {
		Err error
	}
	mock.lockIsDuplicateEntry.RLock()
	calls = mock.calls.IsDuplicateEntry
	mock.lockIsDuplicateEntry.RUnlock()
	return calls
}

// IsExistingColumnTheSame calls IsExistingColumnTheSameFunc.
func (mock *RepositoryMock) IsExistingColumnTheSame(ctx context.Context, workspaceID string, tableName string, column *entity.TableColumn) error {
	if mock.IsExistingColumnTheSameFunc == nil {
		panic("RepositoryMock.IsExistingColumnTheSameFunc: method is nil but Repository.IsExistingColumnTheSame was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		WorkspaceID string
		TableName   string
		Column      *entity.TableColumn
	}{
		Ctx:         ctx,
		WorkspaceID: workspaceID,
		TableName:   tableName,
		Column:      column,
	}
	mock.lockIsExistingColumnTheSame.Lock()
	mock.calls.IsExistingColumnTheSame = append(mock.calls.IsExistingColumnTheSame, callInfo)
	mock.lockIsExistingColumnTheSame.Unlock()
	return mock.IsExistingColumnTheSameFunc(ctx, workspaceID, tableName, column)
}

// IsExistingColumnTheSameCalls gets all the calls that were made to IsExistingColumnTheSame.
// Check the length with:
//
//	len(mockedRepository.IsExistingColumnTheSameCalls())
func (mock *RepositoryMock) IsExistingColumnTheSameCalls() []struct {
	Ctx         context.Context
	WorkspaceID string
	TableName   string
	Column      *entity.TableColumn
} {
	var calls []struct {
		Ctx         context.Context
		WorkspaceID string
		TableName   string
		Column      *entity.TableColumn
	}
	mock.lockIsExistingColumnTheSame.RLock()
	calls = mock.calls.IsExistingColumnTheSame
	mock.lockIsExistingColumnTheSame.RUnlock()
	return calls
}

// IsExistingTableTheSame calls IsExistingTableTheSameFunc.
func (mock *RepositoryMock) IsExistingTableTheSame(ctx context.Context, workspaceID string, table *entity.AppTableManifest) error {
	if mock.IsExistingTableTheSameFunc == nil {
		panic("RepositoryMock.IsExistingTableTheSameFunc: method is nil but Repository.IsExistingTableTheSame was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		WorkspaceID string
		Table       *entity.AppTableManifest
	}{
		Ctx:         ctx,
		WorkspaceID: workspaceID,
		Table:       table,
	}
	mock.lockIsExistingTableTheSame.Lock()
	mock.calls.IsExistingTableTheSame = append(mock.calls.IsExistingTableTheSame, callInfo)
	mock.lockIsExistingTableTheSame.Unlock()
	return mock.IsExistingTableTheSameFunc(ctx, workspaceID, table)
}

// IsExistingTableTheSameCalls gets all the calls that were made to IsExistingTableTheSame.
// Check the length with:
//
//	len(mockedRepository.IsExistingTableTheSameCalls())
func (mock *RepositoryMock) IsExistingTableTheSameCalls() []struct {
	Ctx         context.Context
	WorkspaceID string
	Table       *entity.AppTableManifest
} {
	var calls []struct {
		Ctx         context.Context
		WorkspaceID string
		Table       *entity.AppTableManifest
	}
	mock.lockIsExistingTableTheSame.RLock()
	calls = mock.calls.IsExistingTableTheSame
	mock.lockIsExistingTableTheSame.RUnlock()
	return calls
}

// ListAccountsForOrganization calls ListAccountsForOrganizationFunc.
func (mock *RepositoryMock) ListAccountsForOrganization(ctx context.Context, organizationID string) ([]*entity.AccountWithOrganizationRole, error) {
	if mock.ListAccountsForOrganizationFunc == nil {
		panic("RepositoryMock.ListAccountsForOrganizationFunc: method is nil but Repository.ListAccountsForOrganization was just called")
	}
	callInfo := struct {
		Ctx            context.Context
		OrganizationID string
	}{
		Ctx:            ctx,
		OrganizationID: organizationID,
	}
	mock.lockListAccountsForOrganization.Lock()
	mock.calls.ListAccountsForOrganization = append(mock.calls.ListAccountsForOrganization, callInfo)
	mock.lockListAccountsForOrganization.Unlock()
	return mock.ListAccountsForOrganizationFunc(ctx, organizationID)
}

// ListAccountsForOrganizationCalls gets all the calls that were made to ListAccountsForOrganization.
// Check the length with:
//
//	len(mockedRepository.ListAccountsForOrganizationCalls())
func (mock *RepositoryMock) ListAccountsForOrganizationCalls() []struct {
	Ctx            context.Context
	OrganizationID string
} {
	var calls []struct {
		Ctx            context.Context
		OrganizationID string
	}
	mock.lockListAccountsForOrganization.RLock()
	calls = mock.calls.ListAccountsForOrganization
	mock.lockListAccountsForOrganization.RUnlock()
	return calls
}

// ListApps calls ListAppsFunc.
func (mock *RepositoryMock) ListApps(ctx context.Context, workspaceID string) ([]*entity.App, error) {
	if mock.ListAppsFunc == nil {
		panic("RepositoryMock.ListAppsFunc: method is nil but Repository.ListApps was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		WorkspaceID string
	}{
		Ctx:         ctx,
		WorkspaceID: workspaceID,
	}
	mock.lockListApps.Lock()
	mock.calls.ListApps = append(mock.calls.ListApps, callInfo)
	mock.lockListApps.Unlock()
	return mock.ListAppsFunc(ctx, workspaceID)
}

// ListAppsCalls gets all the calls that were made to ListApps.
// Check the length with:
//
//	len(mockedRepository.ListAppsCalls())
func (mock *RepositoryMock) ListAppsCalls() []struct {
	Ctx         context.Context
	WorkspaceID string
} {
	var calls []struct {
		Ctx         context.Context
		WorkspaceID string
	}
	mock.lockListApps.RLock()
	calls = mock.calls.ListApps
	mock.lockListApps.RUnlock()
	return calls
}

// ListBroadcastCampaigns calls ListBroadcastCampaignsFunc.
func (mock *RepositoryMock) ListBroadcastCampaigns(ctx context.Context, workspaceID string, params *dto.BroadcastCampaignListParams) ([]*entity.BroadcastCampaign, error) {
	if mock.ListBroadcastCampaignsFunc == nil {
		panic("RepositoryMock.ListBroadcastCampaignsFunc: method is nil but Repository.ListBroadcastCampaigns was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		WorkspaceID string
		Params      *dto.BroadcastCampaignListParams
	}{
		Ctx:         ctx,
		WorkspaceID: workspaceID,
		Params:      params,
	}
	mock.lockListBroadcastCampaigns.Lock()
	mock.calls.ListBroadcastCampaigns = append(mock.calls.ListBroadcastCampaigns, callInfo)
	mock.lockListBroadcastCampaigns.Unlock()
	return mock.ListBroadcastCampaignsFunc(ctx, workspaceID, params)
}

// ListBroadcastCampaignsCalls gets all the calls that were made to ListBroadcastCampaigns.
// Check the length with:
//
//	len(mockedRepository.ListBroadcastCampaignsCalls())
func (mock *RepositoryMock) ListBroadcastCampaignsCalls() []struct {
	Ctx         context.Context
	WorkspaceID string
	Params      *dto.BroadcastCampaignListParams
} {
	var calls []struct {
		Ctx         context.Context
		WorkspaceID string
		Params      *dto.BroadcastCampaignListParams
	}
	mock.lockListBroadcastCampaigns.RLock()
	calls = mock.calls.ListBroadcastCampaigns
	mock.lockListBroadcastCampaigns.RUnlock()
	return calls
}

// ListCustomEventsForUser calls ListCustomEventsForUserFunc.
func (mock *RepositoryMock) ListCustomEventsForUser(ctx context.Context, workspace *entity.Workspace, userID string, orderBy string, tx *sql.Tx) ([]*entity.CustomEvent, error) {
	if mock.ListCustomEventsForUserFunc == nil {
		panic("RepositoryMock.ListCustomEventsForUserFunc: method is nil but Repository.ListCustomEventsForUser was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Workspace *entity.Workspace
		UserID    string
		OrderBy   string
		Tx        *sql.Tx
	}{
		Ctx:       ctx,
		Workspace: workspace,
		UserID:    userID,
		OrderBy:   orderBy,
		Tx:        tx,
	}
	mock.lockListCustomEventsForUser.Lock()
	mock.calls.ListCustomEventsForUser = append(mock.calls.ListCustomEventsForUser, callInfo)
	mock.lockListCustomEventsForUser.Unlock()
	return mock.ListCustomEventsForUserFunc(ctx, workspace, userID, orderBy, tx)
}

// ListCustomEventsForUserCalls gets all the calls that were made to ListCustomEventsForUser.
// Check the length with:
//
//	len(mockedRepository.ListCustomEventsForUserCalls())
func (mock *RepositoryMock) ListCustomEventsForUserCalls() []struct {
	Ctx       context.Context
	Workspace *entity.Workspace
	UserID    string
	OrderBy   string
	Tx        *sql.Tx
} {
	var calls []struct {
		Ctx       context.Context
		Workspace *entity.Workspace
		UserID    string
		OrderBy   string
		Tx        *sql.Tx
	}
	mock.lockListCustomEventsForUser.RLock()
	calls = mock.calls.ListCustomEventsForUser
	mock.lockListCustomEventsForUser.RUnlock()
	return calls
}

// ListDataLogs calls ListDataLogsFunc.
func (mock *RepositoryMock) ListDataLogs(ctx context.Context, workspaceID string, params *dto.DataLogListParams) ([]*entity.DataLog, string, int, error) {
	if mock.ListDataLogsFunc == nil {
		panic("RepositoryMock.ListDataLogsFunc: method is nil but Repository.ListDataLogs was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		WorkspaceID string
		Params      *dto.DataLogListParams
	}{
		Ctx:         ctx,
		WorkspaceID: workspaceID,
		Params:      params,
	}
	mock.lockListDataLogs.Lock()
	mock.calls.ListDataLogs = append(mock.calls.ListDataLogs, callInfo)
	mock.lockListDataLogs.Unlock()
	return mock.ListDataLogsFunc(ctx, workspaceID, params)
}

// ListDataLogsCalls gets all the calls that were made to ListDataLogs.
// Check the length with:
//
//	len(mockedRepository.ListDataLogsCalls())
func (mock *RepositoryMock) ListDataLogsCalls() []struct {
	Ctx         context.Context
	WorkspaceID string
	Params      *dto.DataLogListParams
} {
	var calls []struct {
		Ctx         context.Context
		WorkspaceID string
		Params      *dto.DataLogListParams
	}
	mock.lockListDataLogs.RLock()
	calls = mock.calls.ListDataLogs
	mock.lockListDataLogs.RUnlock()
	return calls
}

// ListDataLogsToReprocess calls ListDataLogsToReprocessFunc.
func (mock *RepositoryMock) ListDataLogsToReprocess(ctx context.Context, workspaceID string, lastID string, lastIDEventAt time.Time, limit int) ([]*entity.DataLog, error) {
	if mock.ListDataLogsToReprocessFunc == nil {
		panic("RepositoryMock.ListDataLogsToReprocessFunc: method is nil but Repository.ListDataLogsToReprocess was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		WorkspaceID   string
		LastID        string
		LastIDEventAt time.Time
		Limit         int
	}{
		Ctx:           ctx,
		WorkspaceID:   workspaceID,
		LastID:        lastID,
		LastIDEventAt: lastIDEventAt,
		Limit:         limit,
	}
	mock.lockListDataLogsToReprocess.Lock()
	mock.calls.ListDataLogsToReprocess = append(mock.calls.ListDataLogsToReprocess, callInfo)
	mock.lockListDataLogsToReprocess.Unlock()
	return mock.ListDataLogsToReprocessFunc(ctx, workspaceID, lastID, lastIDEventAt, limit)
}

// ListDataLogsToReprocessCalls gets all the calls that were made to ListDataLogsToReprocess.
// Check the length with:
//
//	len(mockedRepository.ListDataLogsToReprocessCalls())
func (mock *RepositoryMock) ListDataLogsToReprocessCalls() []struct {
	Ctx           context.Context
	WorkspaceID   string
	LastID        string
	LastIDEventAt time.Time
	Limit         int
} {
	var calls []struct {
		Ctx           context.Context
		WorkspaceID   string
		LastID        string
		LastIDEventAt time.Time
		Limit         int
	}
	mock.lockListDataLogsToReprocess.RLock()
	calls = mock.calls.ListDataLogsToReprocess
	mock.lockListDataLogsToReprocess.RUnlock()
	return calls
}

// ListDataLogsToRespawn calls ListDataLogsToRespawnFunc.
func (mock *RepositoryMock) ListDataLogsToRespawn(ctx context.Context, workspaceID string, origin int, originID string, checkpoint int, limit int, withNextToken *string) ([]*dto.DataLogToRespawn, error) {
	if mock.ListDataLogsToRespawnFunc == nil {
		panic("RepositoryMock.ListDataLogsToRespawnFunc: method is nil but Repository.ListDataLogsToRespawn was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		WorkspaceID   string
		Origin        int
		OriginID      string
		Checkpoint    int
		Limit         int
		WithNextToken *string
	}{
		Ctx:           ctx,
		WorkspaceID:   workspaceID,
		Origin:        origin,
		OriginID:      originID,
		Checkpoint:    checkpoint,
		Limit:         limit,
		WithNextToken: withNextToken,
	}
	mock.lockListDataLogsToRespawn.Lock()
	mock.calls.ListDataLogsToRespawn = append(mock.calls.ListDataLogsToRespawn, callInfo)
	mock.lockListDataLogsToRespawn.Unlock()
	return mock.ListDataLogsToRespawnFunc(ctx, workspaceID, origin, originID, checkpoint, limit, withNextToken)
}

// ListDataLogsToRespawnCalls gets all the calls that were made to ListDataLogsToRespawn.
// Check the length with:
//
//	len(mockedRepository.ListDataLogsToRespawnCalls())
func (mock *RepositoryMock) ListDataLogsToRespawnCalls() []struct {
	Ctx           context.Context
	WorkspaceID   string
	Origin        int
	OriginID      string
	Checkpoint    int
	Limit         int
	WithNextToken *string
} {
	var calls []struct {
		Ctx           context.Context
		WorkspaceID   string
		Origin        int
		OriginID      string
		Checkpoint    int
		Limit         int
		WithNextToken *string
	}
	mock.lockListDataLogsToRespawn.RLock()
	calls = mock.calls.ListDataLogsToRespawn
	mock.lockListDataLogsToRespawn.RUnlock()
	return calls
}

// ListDevicesForUser calls ListDevicesForUserFunc.
func (mock *RepositoryMock) ListDevicesForUser(ctx context.Context, workspace *entity.Workspace, userID string, orderBy string, tx *sql.Tx) ([]*entity.Device, error) {
	if mock.ListDevicesForUserFunc == nil {
		panic("RepositoryMock.ListDevicesForUserFunc: method is nil but Repository.ListDevicesForUser was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Workspace *entity.Workspace
		UserID    string
		OrderBy   string
		Tx        *sql.Tx
	}{
		Ctx:       ctx,
		Workspace: workspace,
		UserID:    userID,
		OrderBy:   orderBy,
		Tx:        tx,
	}
	mock.lockListDevicesForUser.Lock()
	mock.calls.ListDevicesForUser = append(mock.calls.ListDevicesForUser, callInfo)
	mock.lockListDevicesForUser.Unlock()
	return mock.ListDevicesForUserFunc(ctx, workspace, userID, orderBy, tx)
}

// ListDevicesForUserCalls gets all the calls that were made to ListDevicesForUser.
// Check the length with:
//
//	len(mockedRepository.ListDevicesForUserCalls())
func (mock *RepositoryMock) ListDevicesForUserCalls() []struct {
	Ctx       context.Context
	Workspace *entity.Workspace
	UserID    string
	OrderBy   string
	Tx        *sql.Tx
} {
	var calls []struct {
		Ctx       context.Context
		Workspace *entity.Workspace
		UserID    string
		OrderBy   string
		Tx        *sql.Tx
	}
	mock.lockListDevicesForUser.RLock()
	calls = mock.calls.ListDevicesForUser
	mock.lockListDevicesForUser.RUnlock()
	return calls
}

// ListInvitationsForOrganization calls ListInvitationsForOrganizationFunc.
func (mock *RepositoryMock) ListInvitationsForOrganization(ctx context.Context, organizationID string) ([]*entity.OrganizationInvitation, error) {
	if mock.ListInvitationsForOrganizationFunc == nil {
		panic("RepositoryMock.ListInvitationsForOrganizationFunc: method is nil but Repository.ListInvitationsForOrganization was just called")
	}
	callInfo := struct {
		Ctx            context.Context
		OrganizationID string
	}{
		Ctx:            ctx,
		OrganizationID: organizationID,
	}
	mock.lockListInvitationsForOrganization.Lock()
	mock.calls.ListInvitationsForOrganization = append(mock.calls.ListInvitationsForOrganization, callInfo)
	mock.lockListInvitationsForOrganization.Unlock()
	return mock.ListInvitationsForOrganizationFunc(ctx, organizationID)
}

// ListInvitationsForOrganizationCalls gets all the calls that were made to ListInvitationsForOrganization.
// Check the length with:
//
//	len(mockedRepository.ListInvitationsForOrganizationCalls())
func (mock *RepositoryMock) ListInvitationsForOrganizationCalls() []struct {
	Ctx            context.Context
	OrganizationID string
} {
	var calls []struct {
		Ctx            context.Context
		OrganizationID string
	}
	mock.lockListInvitationsForOrganization.RLock()
	calls = mock.calls.ListInvitationsForOrganization
	mock.lockListInvitationsForOrganization.RUnlock()
	return calls
}

// ListMessageTemplates calls ListMessageTemplatesFunc.
func (mock *RepositoryMock) ListMessageTemplates(ctx context.Context, workspaceID string, params *dto.MessageTemplateListParams) ([]*entity.MessageTemplate, error) {
	if mock.ListMessageTemplatesFunc == nil {
		panic("RepositoryMock.ListMessageTemplatesFunc: method is nil but Repository.ListMessageTemplates was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		WorkspaceID string
		Params      *dto.MessageTemplateListParams
	}{
		Ctx:         ctx,
		WorkspaceID: workspaceID,
		Params:      params,
	}
	mock.lockListMessageTemplates.Lock()
	mock.calls.ListMessageTemplates = append(mock.calls.ListMessageTemplates, callInfo)
	mock.lockListMessageTemplates.Unlock()
	return mock.ListMessageTemplatesFunc(ctx, workspaceID, params)
}

// ListMessageTemplatesCalls gets all the calls that were made to ListMessageTemplates.
// Check the length with:
//
//	len(mockedRepository.ListMessageTemplatesCalls())
func (mock *RepositoryMock) ListMessageTemplatesCalls() []struct {
	Ctx         context.Context
	WorkspaceID string
	Params      *dto.MessageTemplateListParams
} {
	var calls []struct {
		Ctx         context.Context
		WorkspaceID string
		Params      *dto.MessageTemplateListParams
	}
	mock.lockListMessageTemplates.RLock()
	calls = mock.calls.ListMessageTemplates
	mock.lockListMessageTemplates.RUnlock()
	return calls
}

// ListOrdersForUser calls ListOrdersForUserFunc.
func (mock *RepositoryMock) ListOrdersForUser(ctx context.Context, workspace *entity.Workspace, userID string, orderBy string, tx *sql.Tx) ([]*entity.Order, error) {
	if mock.ListOrdersForUserFunc == nil {
		panic("RepositoryMock.ListOrdersForUserFunc: method is nil but Repository.ListOrdersForUser was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Workspace *entity.Workspace
		UserID    string
		OrderBy   string
		Tx        *sql.Tx
	}{
		Ctx:       ctx,
		Workspace: workspace,
		UserID:    userID,
		OrderBy:   orderBy,
		Tx:        tx,
	}
	mock.lockListOrdersForUser.Lock()
	mock.calls.ListOrdersForUser = append(mock.calls.ListOrdersForUser, callInfo)
	mock.lockListOrdersForUser.Unlock()
	return mock.ListOrdersForUserFunc(ctx, workspace, userID, orderBy, tx)
}

// ListOrdersForUserCalls gets all the calls that were made to ListOrdersForUser.
// Check the length with:
//
//	len(mockedRepository.ListOrdersForUserCalls())
func (mock *RepositoryMock) ListOrdersForUserCalls() []struct {
	Ctx       context.Context
	Workspace *entity.Workspace
	UserID    string
	OrderBy   string
	Tx        *sql.Tx
} {
	var calls []struct {
		Ctx       context.Context
		Workspace *entity.Workspace
		UserID    string
		OrderBy   string
		Tx        *sql.Tx
	}
	mock.lockListOrdersForUser.RLock()
	calls = mock.calls.ListOrdersForUser
	mock.lockListOrdersForUser.RUnlock()
	return calls
}

// ListOrganizationsForAccount calls ListOrganizationsForAccountFunc.
func (mock *RepositoryMock) ListOrganizationsForAccount(ctx context.Context, accountID string) ([]*entity.Organization, error) {
	if mock.ListOrganizationsForAccountFunc == nil {
		panic("RepositoryMock.ListOrganizationsForAccountFunc: method is nil but Repository.ListOrganizationsForAccount was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		AccountID string
	}{
		Ctx:       ctx,
		AccountID: accountID,
	}
	mock.lockListOrganizationsForAccount.Lock()
	mock.calls.ListOrganizationsForAccount = append(mock.calls.ListOrganizationsForAccount, callInfo)
	mock.lockListOrganizationsForAccount.Unlock()
	return mock.ListOrganizationsForAccountFunc(ctx, accountID)
}

// ListOrganizationsForAccountCalls gets all the calls that were made to ListOrganizationsForAccount.
// Check the length with:
//
//	len(mockedRepository.ListOrganizationsForAccountCalls())
func (mock *RepositoryMock) ListOrganizationsForAccountCalls() []struct {
	Ctx       context.Context
	AccountID string
} {
	var calls []struct {
		Ctx       context.Context
		AccountID string
	}
	mock.lockListOrganizationsForAccount.RLock()
	calls = mock.calls.ListOrganizationsForAccount
	mock.lockListOrganizationsForAccount.RUnlock()
	return calls
}

// ListPostviewsForUser calls ListPostviewsForUserFunc.
func (mock *RepositoryMock) ListPostviewsForUser(ctx context.Context, workspace *entity.Workspace, userID string, orderBy string, tx *sql.Tx) ([]*entity.Postview, error) {
	if mock.ListPostviewsForUserFunc == nil {
		panic("RepositoryMock.ListPostviewsForUserFunc: method is nil but Repository.ListPostviewsForUser was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Workspace *entity.Workspace
		UserID    string
		OrderBy   string
		Tx        *sql.Tx
	}{
		Ctx:       ctx,
		Workspace: workspace,
		UserID:    userID,
		OrderBy:   orderBy,
		Tx:        tx,
	}
	mock.lockListPostviewsForUser.Lock()
	mock.calls.ListPostviewsForUser = append(mock.calls.ListPostviewsForUser, callInfo)
	mock.lockListPostviewsForUser.Unlock()
	return mock.ListPostviewsForUserFunc(ctx, workspace, userID, orderBy, tx)
}

// ListPostviewsForUserCalls gets all the calls that were made to ListPostviewsForUser.
// Check the length with:
//
//	len(mockedRepository.ListPostviewsForUserCalls())
func (mock *RepositoryMock) ListPostviewsForUserCalls() []struct {
	Ctx       context.Context
	Workspace *entity.Workspace
	UserID    string
	OrderBy   string
	Tx        *sql.Tx
} {
	var calls []struct {
		Ctx       context.Context
		Workspace *entity.Workspace
		UserID    string
		OrderBy   string
		Tx        *sql.Tx
	}
	mock.lockListPostviewsForUser.RLock()
	calls = mock.calls.ListPostviewsForUser
	mock.lockListPostviewsForUser.RUnlock()
	return calls
}

// ListSegments calls ListSegmentsFunc.
func (mock *RepositoryMock) ListSegments(ctx context.Context, workspaceID string, withUsersCount bool) ([]*entity.Segment, error) {
	if mock.ListSegmentsFunc == nil {
		panic("RepositoryMock.ListSegmentsFunc: method is nil but Repository.ListSegments was just called")
	}
	callInfo := struct {
		Ctx            context.Context
		WorkspaceID    string
		WithUsersCount bool
	}{
		Ctx:            ctx,
		WorkspaceID:    workspaceID,
		WithUsersCount: withUsersCount,
	}
	mock.lockListSegments.Lock()
	mock.calls.ListSegments = append(mock.calls.ListSegments, callInfo)
	mock.lockListSegments.Unlock()
	return mock.ListSegmentsFunc(ctx, workspaceID, withUsersCount)
}

// ListSegmentsCalls gets all the calls that were made to ListSegments.
// Check the length with:
//
//	len(mockedRepository.ListSegmentsCalls())
func (mock *RepositoryMock) ListSegmentsCalls() []struct {
	Ctx            context.Context
	WorkspaceID    string
	WithUsersCount bool
} {
	var calls []struct {
		Ctx            context.Context
		WorkspaceID    string
		WithUsersCount bool
	}
	mock.lockListSegments.RLock()
	calls = mock.calls.ListSegments
	mock.lockListSegments.RUnlock()
	return calls
}

// ListSessionsForUser calls ListSessionsForUserFunc.
func (mock *RepositoryMock) ListSessionsForUser(ctx context.Context, workspace *entity.Workspace, userID string, orderBy string, tx *sql.Tx) ([]*entity.Session, error) {
	if mock.ListSessionsForUserFunc == nil {
		panic("RepositoryMock.ListSessionsForUserFunc: method is nil but Repository.ListSessionsForUser was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Workspace *entity.Workspace
		UserID    string
		OrderBy   string
		Tx        *sql.Tx
	}{
		Ctx:       ctx,
		Workspace: workspace,
		UserID:    userID,
		OrderBy:   orderBy,
		Tx:        tx,
	}
	mock.lockListSessionsForUser.Lock()
	mock.calls.ListSessionsForUser = append(mock.calls.ListSessionsForUser, callInfo)
	mock.lockListSessionsForUser.Unlock()
	return mock.ListSessionsForUserFunc(ctx, workspace, userID, orderBy, tx)
}

// ListSessionsForUserCalls gets all the calls that were made to ListSessionsForUser.
// Check the length with:
//
//	len(mockedRepository.ListSessionsForUserCalls())
func (mock *RepositoryMock) ListSessionsForUserCalls() []struct {
	Ctx       context.Context
	Workspace *entity.Workspace
	UserID    string
	OrderBy   string
	Tx        *sql.Tx
} {
	var calls []struct {
		Ctx       context.Context
		Workspace *entity.Workspace
		UserID    string
		OrderBy   string
		Tx        *sql.Tx
	}
	mock.lockListSessionsForUser.RLock()
	calls = mock.calls.ListSessionsForUser
	mock.lockListSessionsForUser.RUnlock()
	return calls
}

// ListSubscriptionListUsers calls ListSubscriptionListUsersFunc.
func (mock *RepositoryMock) ListSubscriptionListUsers(ctx context.Context, workspaceID string, userIDs []string) ([]*entity.SubscriptionListUser, error) {
	if mock.ListSubscriptionListUsersFunc == nil {
		panic("RepositoryMock.ListSubscriptionListUsersFunc: method is nil but Repository.ListSubscriptionListUsers was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		WorkspaceID string
		UserIDs     []string
	}{
		Ctx:         ctx,
		WorkspaceID: workspaceID,
		UserIDs:     userIDs,
	}
	mock.lockListSubscriptionListUsers.Lock()
	mock.calls.ListSubscriptionListUsers = append(mock.calls.ListSubscriptionListUsers, callInfo)
	mock.lockListSubscriptionListUsers.Unlock()
	return mock.ListSubscriptionListUsersFunc(ctx, workspaceID, userIDs)
}

// ListSubscriptionListUsersCalls gets all the calls that were made to ListSubscriptionListUsers.
// Check the length with:
//
//	len(mockedRepository.ListSubscriptionListUsersCalls())
func (mock *RepositoryMock) ListSubscriptionListUsersCalls() []struct {
	Ctx         context.Context
	WorkspaceID string
	UserIDs     []string
} {
	var calls []struct {
		Ctx         context.Context
		WorkspaceID string
		UserIDs     []string
	}
	mock.lockListSubscriptionListUsers.RLock()
	calls = mock.calls.ListSubscriptionListUsers
	mock.lockListSubscriptionListUsers.RUnlock()
	return calls
}

// ListSubscriptionLists calls ListSubscriptionListsFunc.
func (mock *RepositoryMock) ListSubscriptionLists(ctx context.Context, workspaceID string, withUsersCount bool) ([]*entity.SubscriptionList, error) {
	if mock.ListSubscriptionListsFunc == nil {
		panic("RepositoryMock.ListSubscriptionListsFunc: method is nil but Repository.ListSubscriptionLists was just called")
	}
	callInfo := struct {
		Ctx            context.Context
		WorkspaceID    string
		WithUsersCount bool
	}{
		Ctx:            ctx,
		WorkspaceID:    workspaceID,
		WithUsersCount: withUsersCount,
	}
	mock.lockListSubscriptionLists.Lock()
	mock.calls.ListSubscriptionLists = append(mock.calls.ListSubscriptionLists, callInfo)
	mock.lockListSubscriptionLists.Unlock()
	return mock.ListSubscriptionListsFunc(ctx, workspaceID, withUsersCount)
}

// ListSubscriptionListsCalls gets all the calls that were made to ListSubscriptionLists.
// Check the length with:
//
//	len(mockedRepository.ListSubscriptionListsCalls())
func (mock *RepositoryMock) ListSubscriptionListsCalls() []struct {
	Ctx            context.Context
	WorkspaceID    string
	WithUsersCount bool
} {
	var calls []struct {
		Ctx            context.Context
		WorkspaceID    string
		WithUsersCount bool
	}
	mock.lockListSubscriptionLists.RLock()
	calls = mock.calls.ListSubscriptionLists
	mock.lockListSubscriptionLists.RUnlock()
	return calls
}

// ListTaskExecs calls ListTaskExecsFunc.
func (mock *RepositoryMock) ListTaskExecs(ctx context.Context, workspaceID string, params *dto.TaskExecListParams) ([]*entity.TaskExec, string, string, int, error) {
	if mock.ListTaskExecsFunc == nil {
		panic("RepositoryMock.ListTaskExecsFunc: method is nil but Repository.ListTaskExecs was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		WorkspaceID string
		Params      *dto.TaskExecListParams
	}{
		Ctx:         ctx,
		WorkspaceID: workspaceID,
		Params:      params,
	}
	mock.lockListTaskExecs.Lock()
	mock.calls.ListTaskExecs = append(mock.calls.ListTaskExecs, callInfo)
	mock.lockListTaskExecs.Unlock()
	return mock.ListTaskExecsFunc(ctx, workspaceID, params)
}

// ListTaskExecsCalls gets all the calls that were made to ListTaskExecs.
// Check the length with:
//
//	len(mockedRepository.ListTaskExecsCalls())
func (mock *RepositoryMock) ListTaskExecsCalls() []struct {
	Ctx         context.Context
	WorkspaceID string
	Params      *dto.TaskExecListParams
} {
	var calls []struct {
		Ctx         context.Context
		WorkspaceID string
		Params      *dto.TaskExecListParams
	}
	mock.lockListTaskExecs.RLock()
	calls = mock.calls.ListTaskExecs
	mock.lockListTaskExecs.RUnlock()
	return calls
}

// ListTasks calls ListTasksFunc.
func (mock *RepositoryMock) ListTasks(ctx context.Context, workspaceID string) ([]*entity.Task, error) {
	if mock.ListTasksFunc == nil {
		panic("RepositoryMock.ListTasksFunc: method is nil but Repository.ListTasks was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		WorkspaceID string
	}{
		Ctx:         ctx,
		WorkspaceID: workspaceID,
	}
	mock.lockListTasks.Lock()
	mock.calls.ListTasks = append(mock.calls.ListTasks, callInfo)
	mock.lockListTasks.Unlock()
	return mock.ListTasksFunc(ctx, workspaceID)
}

// ListTasksCalls gets all the calls that were made to ListTasks.
// Check the length with:
//
//	len(mockedRepository.ListTasksCalls())
func (mock *RepositoryMock) ListTasksCalls() []struct {
	Ctx         context.Context
	WorkspaceID string
} {
	var calls []struct {
		Ctx         context.Context
		WorkspaceID string
	}
	mock.lockListTasks.RLock()
	calls = mock.calls.ListTasks
	mock.lockListTasks.RUnlock()
	return calls
}

// ListTasksToWakeUp calls ListTasksToWakeUpFunc.
func (mock *RepositoryMock) ListTasksToWakeUp(ctx context.Context) ([]*entity.Task, error) {
	if mock.ListTasksToWakeUpFunc == nil {
		panic("RepositoryMock.ListTasksToWakeUpFunc: method is nil but Repository.ListTasksToWakeUp was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockListTasksToWakeUp.Lock()
	mock.calls.ListTasksToWakeUp = append(mock.calls.ListTasksToWakeUp, callInfo)
	mock.lockListTasksToWakeUp.Unlock()
	return mock.ListTasksToWakeUpFunc(ctx)
}

// ListTasksToWakeUpCalls gets all the calls that were made to ListTasksToWakeUp.
// Check the length with:
//
//	len(mockedRepository.ListTasksToWakeUpCalls())
func (mock *RepositoryMock) ListTasksToWakeUpCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockListTasksToWakeUp.RLock()
	calls = mock.calls.ListTasksToWakeUp
	mock.lockListTasksToWakeUp.RUnlock()
	return calls
}

// ListUserSegments calls ListUserSegmentsFunc.
func (mock *RepositoryMock) ListUserSegments(ctx context.Context, workspaceID string, userIDs []string, tx *sql.Tx) ([]*entity.UserSegment, error) {
	if mock.ListUserSegmentsFunc == nil {
		panic("RepositoryMock.ListUserSegmentsFunc: method is nil but Repository.ListUserSegments was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		WorkspaceID string
		UserIDs     []string
		Tx          *sql.Tx
	}{
		Ctx:         ctx,
		WorkspaceID: workspaceID,
		UserIDs:     userIDs,
		Tx:          tx,
	}
	mock.lockListUserSegments.Lock()
	mock.calls.ListUserSegments = append(mock.calls.ListUserSegments, callInfo)
	mock.lockListUserSegments.Unlock()
	return mock.ListUserSegmentsFunc(ctx, workspaceID, userIDs, tx)
}

// ListUserSegmentsCalls gets all the calls that were made to ListUserSegments.
// Check the length with:
//
//	len(mockedRepository.ListUserSegmentsCalls())
func (mock *RepositoryMock) ListUserSegmentsCalls() []struct {
	Ctx         context.Context
	WorkspaceID string
	UserIDs     []string
	Tx          *sql.Tx
} {
	var calls []struct {
		Ctx         context.Context
		WorkspaceID string
		UserIDs     []string
		Tx          *sql.Tx
	}
	mock.lockListUserSegments.RLock()
	calls = mock.calls.ListUserSegments
	mock.lockListUserSegments.RUnlock()
	return calls
}

// ListUsers calls ListUsersFunc.
func (mock *RepositoryMock) ListUsers(ctx context.Context, workspace *entity.Workspace, params *dto.UserListParams) ([]*entity.User, string, string, error) {
	if mock.ListUsersFunc == nil {
		panic("RepositoryMock.ListUsersFunc: method is nil but Repository.ListUsers was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Workspace *entity.Workspace
		Params    *dto.UserListParams
	}{
		Ctx:       ctx,
		Workspace: workspace,
		Params:    params,
	}
	mock.lockListUsers.Lock()
	mock.calls.ListUsers = append(mock.calls.ListUsers, callInfo)
	mock.lockListUsers.Unlock()
	return mock.ListUsersFunc(ctx, workspace, params)
}

// ListUsersCalls gets all the calls that were made to ListUsers.
// Check the length with:
//
//	len(mockedRepository.ListUsersCalls())
func (mock *RepositoryMock) ListUsersCalls() []struct {
	Ctx       context.Context
	Workspace *entity.Workspace
	Params    *dto.UserListParams
} {
	var calls []struct {
		Ctx       context.Context
		Workspace *entity.Workspace
		Params    *dto.UserListParams
	}
	mock.lockListUsers.RLock()
	calls = mock.calls.ListUsers
	mock.lockListUsers.RUnlock()
	return calls
}

// ListWorkspaces calls ListWorkspacesFunc.
func (mock *RepositoryMock) ListWorkspaces(ctx context.Context, organizationID *string) ([]*entity.Workspace, error) {
	if mock.ListWorkspacesFunc == nil {
		panic("RepositoryMock.ListWorkspacesFunc: method is nil but Repository.ListWorkspaces was just called")
	}
	callInfo := struct {
		Ctx            context.Context
		OrganizationID *string
	}{
		Ctx:            ctx,
		OrganizationID: organizationID,
	}
	mock.lockListWorkspaces.Lock()
	mock.calls.ListWorkspaces = append(mock.calls.ListWorkspaces, callInfo)
	mock.lockListWorkspaces.Unlock()
	return mock.ListWorkspacesFunc(ctx, organizationID)
}

// ListWorkspacesCalls gets all the calls that were made to ListWorkspaces.
// Check the length with:
//
//	len(mockedRepository.ListWorkspacesCalls())
func (mock *RepositoryMock) ListWorkspacesCalls() []struct {
	Ctx            context.Context
	OrganizationID *string
} {
	var calls []struct {
		Ctx            context.Context
		OrganizationID *string
	}
	mock.lockListWorkspaces.RLock()
	calls = mock.calls.ListWorkspaces
	mock.lockListWorkspaces.RUnlock()
	return calls
}

// MatchSegmentUsers calls MatchSegmentUsersFunc.
func (mock *RepositoryMock) MatchSegmentUsers(ctx context.Context, workspaceID string, segment *entity.Segment, userIDs []string) ([]*string, error) {
	if mock.MatchSegmentUsersFunc == nil {
		panic("RepositoryMock.MatchSegmentUsersFunc: method is nil but Repository.MatchSegmentUsers was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		WorkspaceID string
		Segment     *entity.Segment
		UserIDs     []string
	}{
		Ctx:         ctx,
		WorkspaceID: workspaceID,
		Segment:     segment,
		UserIDs:     userIDs,
	}
	mock.lockMatchSegmentUsers.Lock()
	mock.calls.MatchSegmentUsers = append(mock.calls.MatchSegmentUsers, callInfo)
	mock.lockMatchSegmentUsers.Unlock()
	return mock.MatchSegmentUsersFunc(ctx, workspaceID, segment, userIDs)
}

// MatchSegmentUsersCalls gets all the calls that were made to MatchSegmentUsers.
// Check the length with:
//
//	len(mockedRepository.MatchSegmentUsersCalls())
func (mock *RepositoryMock) MatchSegmentUsersCalls() []struct {
	Ctx         context.Context
	WorkspaceID string
	Segment     *entity.Segment
	UserIDs     []string
} {
	var calls []struct {
		Ctx         context.Context
		WorkspaceID string
		Segment     *entity.Segment
		UserIDs     []string
	}
	mock.lockMatchSegmentUsers.RLock()
	calls = mock.calls.MatchSegmentUsers
	mock.lockMatchSegmentUsers.RUnlock()
	return calls
}

// MergeUserCartItems calls MergeUserCartItemsFunc.
func (mock *RepositoryMock) MergeUserCartItems(ctx context.Context, workspace *entity.Workspace, fromUserID string, toUserID string, tx *sql.Tx) error {
	if mock.MergeUserCartItemsFunc == nil {
		panic("RepositoryMock.MergeUserCartItemsFunc: method is nil but Repository.MergeUserCartItems was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Workspace  *entity.Workspace
		FromUserID string
		ToUserID   string
		Tx         *sql.Tx
	}{
		Ctx:        ctx,
		Workspace:  workspace,
		FromUserID: fromUserID,
		ToUserID:   toUserID,
		Tx:         tx,
	}
	mock.lockMergeUserCartItems.Lock()
	mock.calls.MergeUserCartItems = append(mock.calls.MergeUserCartItems, callInfo)
	mock.lockMergeUserCartItems.Unlock()
	return mock.MergeUserCartItemsFunc(ctx, workspace, fromUserID, toUserID, tx)
}

// MergeUserCartItemsCalls gets all the calls that were made to MergeUserCartItems.
// Check the length with:
//
//	len(mockedRepository.MergeUserCartItemsCalls())
func (mock *RepositoryMock) MergeUserCartItemsCalls() []struct {
	Ctx        context.Context
	Workspace  *entity.Workspace
	FromUserID string
	ToUserID   string
	Tx         *sql.Tx
} {
	var calls []struct {
		Ctx        context.Context
		Workspace  *entity.Workspace
		FromUserID string
		ToUserID   string
		Tx         *sql.Tx
	}
	mock.lockMergeUserCartItems.RLock()
	calls = mock.calls.MergeUserCartItems
	mock.lockMergeUserCartItems.RUnlock()
	return calls
}

// MergeUserCarts calls MergeUserCartsFunc.
func (mock *RepositoryMock) MergeUserCarts(ctx context.Context, workspace *entity.Workspace, fromUserID string, toUserID string, tx *sql.Tx) error {
	if mock.MergeUserCartsFunc == nil {
		panic("RepositoryMock.MergeUserCartsFunc: method is nil but Repository.MergeUserCarts was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Workspace  *entity.Workspace
		FromUserID string
		ToUserID   string
		Tx         *sql.Tx
	}{
		Ctx:        ctx,
		Workspace:  workspace,
		FromUserID: fromUserID,
		ToUserID:   toUserID,
		Tx:         tx,
	}
	mock.lockMergeUserCarts.Lock()
	mock.calls.MergeUserCarts = append(mock.calls.MergeUserCarts, callInfo)
	mock.lockMergeUserCarts.Unlock()
	return mock.MergeUserCartsFunc(ctx, workspace, fromUserID, toUserID, tx)
}

// MergeUserCartsCalls gets all the calls that were made to MergeUserCarts.
// Check the length with:
//
//	len(mockedRepository.MergeUserCartsCalls())
func (mock *RepositoryMock) MergeUserCartsCalls() []struct {
	Ctx        context.Context
	Workspace  *entity.Workspace
	FromUserID string
	ToUserID   string
	Tx         *sql.Tx
} {
	var calls []struct {
		Ctx        context.Context
		Workspace  *entity.Workspace
		FromUserID string
		ToUserID   string
		Tx         *sql.Tx
	}
	mock.lockMergeUserCarts.RLock()
	calls = mock.calls.MergeUserCarts
	mock.lockMergeUserCarts.RUnlock()
	return calls
}

// MergeUserCustomEvents calls MergeUserCustomEventsFunc.
func (mock *RepositoryMock) MergeUserCustomEvents(ctx context.Context, workspace *entity.Workspace, fromUserID string, toUserID string, tx *sql.Tx) error {
	if mock.MergeUserCustomEventsFunc == nil {
		panic("RepositoryMock.MergeUserCustomEventsFunc: method is nil but Repository.MergeUserCustomEvents was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Workspace  *entity.Workspace
		FromUserID string
		ToUserID   string
		Tx         *sql.Tx
	}{
		Ctx:        ctx,
		Workspace:  workspace,
		FromUserID: fromUserID,
		ToUserID:   toUserID,
		Tx:         tx,
	}
	mock.lockMergeUserCustomEvents.Lock()
	mock.calls.MergeUserCustomEvents = append(mock.calls.MergeUserCustomEvents, callInfo)
	mock.lockMergeUserCustomEvents.Unlock()
	return mock.MergeUserCustomEventsFunc(ctx, workspace, fromUserID, toUserID, tx)
}

// MergeUserCustomEventsCalls gets all the calls that were made to MergeUserCustomEvents.
// Check the length with:
//
//	len(mockedRepository.MergeUserCustomEventsCalls())
func (mock *RepositoryMock) MergeUserCustomEventsCalls() []struct {
	Ctx        context.Context
	Workspace  *entity.Workspace
	FromUserID string
	ToUserID   string
	Tx         *sql.Tx
} {
	var calls []struct {
		Ctx        context.Context
		Workspace  *entity.Workspace
		FromUserID string
		ToUserID   string
		Tx         *sql.Tx
	}
	mock.lockMergeUserCustomEvents.RLock()
	calls = mock.calls.MergeUserCustomEvents
	mock.lockMergeUserCustomEvents.RUnlock()
	return calls
}

// MergeUserDataLogs calls MergeUserDataLogsFunc.
func (mock *RepositoryMock) MergeUserDataLogs(ctx context.Context, workspace *entity.Workspace, fromUserID string, fromUserExternalID string, toUserID string, tx *sql.Tx) error {
	if mock.MergeUserDataLogsFunc == nil {
		panic("RepositoryMock.MergeUserDataLogsFunc: method is nil but Repository.MergeUserDataLogs was just called")
	}
	callInfo := struct {
		Ctx                context.Context
		Workspace          *entity.Workspace
		FromUserID         string
		FromUserExternalID string
		ToUserID           string
		Tx                 *sql.Tx
	}{
		Ctx:                ctx,
		Workspace:          workspace,
		FromUserID:         fromUserID,
		FromUserExternalID: fromUserExternalID,
		ToUserID:           toUserID,
		Tx:                 tx,
	}
	mock.lockMergeUserDataLogs.Lock()
	mock.calls.MergeUserDataLogs = append(mock.calls.MergeUserDataLogs, callInfo)
	mock.lockMergeUserDataLogs.Unlock()
	return mock.MergeUserDataLogsFunc(ctx, workspace, fromUserID, fromUserExternalID, toUserID, tx)
}

// MergeUserDataLogsCalls gets all the calls that were made to MergeUserDataLogs.
// Check the length with:
//
//	len(mockedRepository.MergeUserDataLogsCalls())
func (mock *RepositoryMock) MergeUserDataLogsCalls() []struct {
	Ctx                context.Context
	Workspace          *entity.Workspace
	FromUserID         string
	FromUserExternalID string
	ToUserID           string
	Tx                 *sql.Tx
} {
	var calls []struct {
		Ctx                context.Context
		Workspace          *entity.Workspace
		FromUserID         string
		FromUserExternalID string
		ToUserID           string
		Tx                 *sql.Tx
	}
	mock.lockMergeUserDataLogs.RLock()
	calls = mock.calls.MergeUserDataLogs
	mock.lockMergeUserDataLogs.RUnlock()
	return calls
}

// MergeUserDevices calls MergeUserDevicesFunc.
func (mock *RepositoryMock) MergeUserDevices(ctx context.Context, workspace *entity.Workspace, fromUserID string, toUserID string, tx *sql.Tx) error {
	if mock.MergeUserDevicesFunc == nil {
		panic("RepositoryMock.MergeUserDevicesFunc: method is nil but Repository.MergeUserDevices was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Workspace  *entity.Workspace
		FromUserID string
		ToUserID   string
		Tx         *sql.Tx
	}{
		Ctx:        ctx,
		Workspace:  workspace,
		FromUserID: fromUserID,
		ToUserID:   toUserID,
		Tx:         tx,
	}
	mock.lockMergeUserDevices.Lock()
	mock.calls.MergeUserDevices = append(mock.calls.MergeUserDevices, callInfo)
	mock.lockMergeUserDevices.Unlock()
	return mock.MergeUserDevicesFunc(ctx, workspace, fromUserID, toUserID, tx)
}

// MergeUserDevicesCalls gets all the calls that were made to MergeUserDevices.
// Check the length with:
//
//	len(mockedRepository.MergeUserDevicesCalls())
func (mock *RepositoryMock) MergeUserDevicesCalls() []struct {
	Ctx        context.Context
	Workspace  *entity.Workspace
	FromUserID string
	ToUserID   string
	Tx         *sql.Tx
} {
	var calls []struct {
		Ctx        context.Context
		Workspace  *entity.Workspace
		FromUserID string
		ToUserID   string
		Tx         *sql.Tx
	}
	mock.lockMergeUserDevices.RLock()
	calls = mock.calls.MergeUserDevices
	mock.lockMergeUserDevices.RUnlock()
	return calls
}

// MergeUserOrderItems calls MergeUserOrderItemsFunc.
func (mock *RepositoryMock) MergeUserOrderItems(ctx context.Context, workspace *entity.Workspace, fromUserID string, toUserID string, tx *sql.Tx) error {
	if mock.MergeUserOrderItemsFunc == nil {
		panic("RepositoryMock.MergeUserOrderItemsFunc: method is nil but Repository.MergeUserOrderItems was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Workspace  *entity.Workspace
		FromUserID string
		ToUserID   string
		Tx         *sql.Tx
	}{
		Ctx:        ctx,
		Workspace:  workspace,
		FromUserID: fromUserID,
		ToUserID:   toUserID,
		Tx:         tx,
	}
	mock.lockMergeUserOrderItems.Lock()
	mock.calls.MergeUserOrderItems = append(mock.calls.MergeUserOrderItems, callInfo)
	mock.lockMergeUserOrderItems.Unlock()
	return mock.MergeUserOrderItemsFunc(ctx, workspace, fromUserID, toUserID, tx)
}

// MergeUserOrderItemsCalls gets all the calls that were made to MergeUserOrderItems.
// Check the length with:
//
//	len(mockedRepository.MergeUserOrderItemsCalls())
func (mock *RepositoryMock) MergeUserOrderItemsCalls() []struct {
	Ctx        context.Context
	Workspace  *entity.Workspace
	FromUserID string
	ToUserID   string
	Tx         *sql.Tx
} {
	var calls []struct {
		Ctx        context.Context
		Workspace  *entity.Workspace
		FromUserID string
		ToUserID   string
		Tx         *sql.Tx
	}
	mock.lockMergeUserOrderItems.RLock()
	calls = mock.calls.MergeUserOrderItems
	mock.lockMergeUserOrderItems.RUnlock()
	return calls
}

// MergeUserOrders calls MergeUserOrdersFunc.
func (mock *RepositoryMock) MergeUserOrders(ctx context.Context, workspace *entity.Workspace, fromUserID string, toUserID string, tx *sql.Tx) error {
	if mock.MergeUserOrdersFunc == nil {
		panic("RepositoryMock.MergeUserOrdersFunc: method is nil but Repository.MergeUserOrders was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Workspace  *entity.Workspace
		FromUserID string
		ToUserID   string
		Tx         *sql.Tx
	}{
		Ctx:        ctx,
		Workspace:  workspace,
		FromUserID: fromUserID,
		ToUserID:   toUserID,
		Tx:         tx,
	}
	mock.lockMergeUserOrders.Lock()
	mock.calls.MergeUserOrders = append(mock.calls.MergeUserOrders, callInfo)
	mock.lockMergeUserOrders.Unlock()
	return mock.MergeUserOrdersFunc(ctx, workspace, fromUserID, toUserID, tx)
}

// MergeUserOrdersCalls gets all the calls that were made to MergeUserOrders.
// Check the length with:
//
//	len(mockedRepository.MergeUserOrdersCalls())
func (mock *RepositoryMock) MergeUserOrdersCalls() []struct {
	Ctx        context.Context
	Workspace  *entity.Workspace
	FromUserID string
	ToUserID   string
	Tx         *sql.Tx
} {
	var calls []struct {
		Ctx        context.Context
		Workspace  *entity.Workspace
		FromUserID string
		ToUserID   string
		Tx         *sql.Tx
	}
	mock.lockMergeUserOrders.RLock()
	calls = mock.calls.MergeUserOrders
	mock.lockMergeUserOrders.RUnlock()
	return calls
}

// MergeUserPageviews calls MergeUserPageviewsFunc.
func (mock *RepositoryMock) MergeUserPageviews(ctx context.Context, workspace *entity.Workspace, fromUserID string, toUserID string, tx *sql.Tx) error {
	if mock.MergeUserPageviewsFunc == nil {
		panic("RepositoryMock.MergeUserPageviewsFunc: method is nil but Repository.MergeUserPageviews was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Workspace  *entity.Workspace
		FromUserID string
		ToUserID   string
		Tx         *sql.Tx
	}{
		Ctx:        ctx,
		Workspace:  workspace,
		FromUserID: fromUserID,
		ToUserID:   toUserID,
		Tx:         tx,
	}
	mock.lockMergeUserPageviews.Lock()
	mock.calls.MergeUserPageviews = append(mock.calls.MergeUserPageviews, callInfo)
	mock.lockMergeUserPageviews.Unlock()
	return mock.MergeUserPageviewsFunc(ctx, workspace, fromUserID, toUserID, tx)
}

// MergeUserPageviewsCalls gets all the calls that were made to MergeUserPageviews.
// Check the length with:
//
//	len(mockedRepository.MergeUserPageviewsCalls())
func (mock *RepositoryMock) MergeUserPageviewsCalls() []struct {
	Ctx        context.Context
	Workspace  *entity.Workspace
	FromUserID string
	ToUserID   string
	Tx         *sql.Tx
} {
	var calls []struct {
		Ctx        context.Context
		Workspace  *entity.Workspace
		FromUserID string
		ToUserID   string
		Tx         *sql.Tx
	}
	mock.lockMergeUserPageviews.RLock()
	calls = mock.calls.MergeUserPageviews
	mock.lockMergeUserPageviews.RUnlock()
	return calls
}

// MergeUserPostviews calls MergeUserPostviewsFunc.
func (mock *RepositoryMock) MergeUserPostviews(ctx context.Context, workspace *entity.Workspace, fromUserID string, toUserID string, tx *sql.Tx) error {
	if mock.MergeUserPostviewsFunc == nil {
		panic("RepositoryMock.MergeUserPostviewsFunc: method is nil but Repository.MergeUserPostviews was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Workspace  *entity.Workspace
		FromUserID string
		ToUserID   string
		Tx         *sql.Tx
	}{
		Ctx:        ctx,
		Workspace:  workspace,
		FromUserID: fromUserID,
		ToUserID:   toUserID,
		Tx:         tx,
	}
	mock.lockMergeUserPostviews.Lock()
	mock.calls.MergeUserPostviews = append(mock.calls.MergeUserPostviews, callInfo)
	mock.lockMergeUserPostviews.Unlock()
	return mock.MergeUserPostviewsFunc(ctx, workspace, fromUserID, toUserID, tx)
}

// MergeUserPostviewsCalls gets all the calls that were made to MergeUserPostviews.
// Check the length with:
//
//	len(mockedRepository.MergeUserPostviewsCalls())
func (mock *RepositoryMock) MergeUserPostviewsCalls() []struct {
	Ctx        context.Context
	Workspace  *entity.Workspace
	FromUserID string
	ToUserID   string
	Tx         *sql.Tx
} {
	var calls []struct {
		Ctx        context.Context
		Workspace  *entity.Workspace
		FromUserID string
		ToUserID   string
		Tx         *sql.Tx
	}
	mock.lockMergeUserPostviews.RLock()
	calls = mock.calls.MergeUserPostviews
	mock.lockMergeUserPostviews.RUnlock()
	return calls
}

// MergeUserSessions calls MergeUserSessionsFunc.
func (mock *RepositoryMock) MergeUserSessions(ctx context.Context, workspace *entity.Workspace, fromUserID string, toUserID string, tx *sql.Tx) error {
	if mock.MergeUserSessionsFunc == nil {
		panic("RepositoryMock.MergeUserSessionsFunc: method is nil but Repository.MergeUserSessions was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Workspace  *entity.Workspace
		FromUserID string
		ToUserID   string
		Tx         *sql.Tx
	}{
		Ctx:        ctx,
		Workspace:  workspace,
		FromUserID: fromUserID,
		ToUserID:   toUserID,
		Tx:         tx,
	}
	mock.lockMergeUserSessions.Lock()
	mock.calls.MergeUserSessions = append(mock.calls.MergeUserSessions, callInfo)
	mock.lockMergeUserSessions.Unlock()
	return mock.MergeUserSessionsFunc(ctx, workspace, fromUserID, toUserID, tx)
}

// MergeUserSessionsCalls gets all the calls that were made to MergeUserSessions.
// Check the length with:
//
//	len(mockedRepository.MergeUserSessionsCalls())
func (mock *RepositoryMock) MergeUserSessionsCalls() []struct {
	Ctx        context.Context
	Workspace  *entity.Workspace
	FromUserID string
	ToUserID   string
	Tx         *sql.Tx
} {
	var calls []struct {
		Ctx        context.Context
		Workspace  *entity.Workspace
		FromUserID string
		ToUserID   string
		Tx         *sql.Tx
	}
	mock.lockMergeUserSessions.RLock()
	calls = mock.calls.MergeUserSessions
	mock.lockMergeUserSessions.RUnlock()
	return calls
}

// PreviewSegment calls PreviewSegmentFunc.
func (mock *RepositoryMock) PreviewSegment(ctx context.Context, workspaceID string, parentSegmentID *string, filter *entity.SegmentTreeNode, timezone string) (int64, string, []interface{}, error) {
	if mock.PreviewSegmentFunc == nil {
		panic("RepositoryMock.PreviewSegmentFunc: method is nil but Repository.PreviewSegment was just called")
	}
	callInfo := struct {
		Ctx             context.Context
		WorkspaceID     string
		ParentSegmentID *string
		Filter          *entity.SegmentTreeNode
		Timezone        string
	}{
		Ctx:             ctx,
		WorkspaceID:     workspaceID,
		ParentSegmentID: parentSegmentID,
		Filter:          filter,
		Timezone:        timezone,
	}
	mock.lockPreviewSegment.Lock()
	mock.calls.PreviewSegment = append(mock.calls.PreviewSegment, callInfo)
	mock.lockPreviewSegment.Unlock()
	return mock.PreviewSegmentFunc(ctx, workspaceID, parentSegmentID, filter, timezone)
}

// PreviewSegmentCalls gets all the calls that were made to PreviewSegment.
// Check the length with:
//
//	len(mockedRepository.PreviewSegmentCalls())
func (mock *RepositoryMock) PreviewSegmentCalls() []struct {
	Ctx             context.Context
	WorkspaceID     string
	ParentSegmentID *string
	Filter          *entity.SegmentTreeNode
	Timezone        string
} {
	var calls []struct {
		Ctx             context.Context
		WorkspaceID     string
		ParentSegmentID *string
		Filter          *entity.SegmentTreeNode
		Timezone        string
	}
	mock.lockPreviewSegment.RLock()
	calls = mock.calls.PreviewSegment
	mock.lockPreviewSegment.RUnlock()
	return calls
}

// ReleaseUsersLock calls ReleaseUsersLockFunc.
func (mock *RepositoryMock) ReleaseUsersLock(workspaceID string, lock *entity.UsersLock) error {
	if mock.ReleaseUsersLockFunc == nil {
		panic("RepositoryMock.ReleaseUsersLockFunc: method is nil but Repository.ReleaseUsersLock was just called")
	}
	callInfo := struct {
		WorkspaceID string
		Lock        *entity.UsersLock
	}{
		WorkspaceID: workspaceID,
		Lock:        lock,
	}
	mock.lockReleaseUsersLock.Lock()
	mock.calls.ReleaseUsersLock = append(mock.calls.ReleaseUsersLock, callInfo)
	mock.lockReleaseUsersLock.Unlock()
	return mock.ReleaseUsersLockFunc(workspaceID, lock)
}

// ReleaseUsersLockCalls gets all the calls that were made to ReleaseUsersLock.
// Check the length with:
//
//	len(mockedRepository.ReleaseUsersLockCalls())
func (mock *RepositoryMock) ReleaseUsersLockCalls() []struct {
	WorkspaceID string
	Lock        *entity.UsersLock
} {
	var calls []struct {
		WorkspaceID string
		Lock        *entity.UsersLock
	}
	mock.lockReleaseUsersLock.RLock()
	calls = mock.calls.ReleaseUsersLock
	mock.lockReleaseUsersLock.RUnlock()
	return calls
}

// ResetAccountPassword calls ResetAccountPasswordFunc.
func (mock *RepositoryMock) ResetAccountPassword(ctx context.Context, accountID string, newPassword string) error {
	if mock.ResetAccountPasswordFunc == nil {
		panic("RepositoryMock.ResetAccountPasswordFunc: method is nil but Repository.ResetAccountPassword was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		AccountID   string
		NewPassword string
	}{
		Ctx:         ctx,
		AccountID:   accountID,
		NewPassword: newPassword,
	}
	mock.lockResetAccountPassword.Lock()
	mock.calls.ResetAccountPassword = append(mock.calls.ResetAccountPassword, callInfo)
	mock.lockResetAccountPassword.Unlock()
	return mock.ResetAccountPasswordFunc(ctx, accountID, newPassword)
}

// ResetAccountPasswordCalls gets all the calls that were made to ResetAccountPassword.
// Check the length with:
//
//	len(mockedRepository.ResetAccountPasswordCalls())
func (mock *RepositoryMock) ResetAccountPasswordCalls() []struct {
	Ctx         context.Context
	AccountID   string
	NewPassword string
} {
	var calls []struct {
		Ctx         context.Context
		AccountID   string
		NewPassword string
	}
	mock.lockResetAccountPassword.RLock()
	calls = mock.calls.ResetAccountPassword
	mock.lockResetAccountPassword.RUnlock()
	return calls
}

// ResetPostviewsAttributedForConversion calls ResetPostviewsAttributedForConversionFunc.
func (mock *RepositoryMock) ResetPostviewsAttributedForConversion(ctx context.Context, userID string, conversionID string, tx *sql.Tx) error {
	if mock.ResetPostviewsAttributedForConversionFunc == nil {
		panic("RepositoryMock.ResetPostviewsAttributedForConversionFunc: method is nil but Repository.ResetPostviewsAttributedForConversion was just called")
	}
	callInfo := struct {
		Ctx          context.Context
		UserID       string
		ConversionID string
		Tx           *sql.Tx
	}{
		Ctx:          ctx,
		UserID:       userID,
		ConversionID: conversionID,
		Tx:           tx,
	}
	mock.lockResetPostviewsAttributedForConversion.Lock()
	mock.calls.ResetPostviewsAttributedForConversion = append(mock.calls.ResetPostviewsAttributedForConversion, callInfo)
	mock.lockResetPostviewsAttributedForConversion.Unlock()
	return mock.ResetPostviewsAttributedForConversionFunc(ctx, userID, conversionID, tx)
}

// ResetPostviewsAttributedForConversionCalls gets all the calls that were made to ResetPostviewsAttributedForConversion.
// Check the length with:
//
//	len(mockedRepository.ResetPostviewsAttributedForConversionCalls())
func (mock *RepositoryMock) ResetPostviewsAttributedForConversionCalls() []struct {
	Ctx          context.Context
	UserID       string
	ConversionID string
	Tx           *sql.Tx
} {
	var calls []struct {
		Ctx          context.Context
		UserID       string
		ConversionID string
		Tx           *sql.Tx
	}
	mock.lockResetPostviewsAttributedForConversion.RLock()
	calls = mock.calls.ResetPostviewsAttributedForConversion
	mock.lockResetPostviewsAttributedForConversion.RUnlock()
	return calls
}

// ResetSessionsAttributedForConversion calls ResetSessionsAttributedForConversionFunc.
func (mock *RepositoryMock) ResetSessionsAttributedForConversion(ctx context.Context, userID string, conversionID string, tx *sql.Tx) error {
	if mock.ResetSessionsAttributedForConversionFunc == nil {
		panic("RepositoryMock.ResetSessionsAttributedForConversionFunc: method is nil but Repository.ResetSessionsAttributedForConversion was just called")
	}
	callInfo := struct {
		Ctx          context.Context
		UserID       string
		ConversionID string
		Tx           *sql.Tx
	}{
		Ctx:          ctx,
		UserID:       userID,
		ConversionID: conversionID,
		Tx:           tx,
	}
	mock.lockResetSessionsAttributedForConversion.Lock()
	mock.calls.ResetSessionsAttributedForConversion = append(mock.calls.ResetSessionsAttributedForConversion, callInfo)
	mock.lockResetSessionsAttributedForConversion.Unlock()
	return mock.ResetSessionsAttributedForConversionFunc(ctx, userID, conversionID, tx)
}

// ResetSessionsAttributedForConversionCalls gets all the calls that were made to ResetSessionsAttributedForConversion.
// Check the length with:
//
//	len(mockedRepository.ResetSessionsAttributedForConversionCalls())
func (mock *RepositoryMock) ResetSessionsAttributedForConversionCalls() []struct {
	Ctx          context.Context
	UserID       string
	ConversionID string
	Tx           *sql.Tx
} {
	var calls []struct {
		Ctx          context.Context
		UserID       string
		ConversionID string
		Tx           *sql.Tx
	}
	mock.lockResetSessionsAttributedForConversion.RLock()
	calls = mock.calls.ResetSessionsAttributedForConversion
	mock.lockResetSessionsAttributedForConversion.RUnlock()
	return calls
}

// RunInTransactionForSystem calls RunInTransactionForSystemFunc.
func (mock *RepositoryMock) RunInTransactionForSystem(ctx context.Context, f func(context.Context, *sql.Tx) (int, error)) (int, error) {
	if mock.RunInTransactionForSystemFunc == nil {
		panic("RepositoryMock.RunInTransactionForSystemFunc: method is nil but Repository.RunInTransactionForSystem was just called")
	}
	callInfo := struct {
		Ctx context.Context
		F   func(context.Context, *sql.Tx) (int, error)
	}{
		Ctx: ctx,
		F:   f,
	}
	mock.lockRunInTransactionForSystem.Lock()
	mock.calls.RunInTransactionForSystem = append(mock.calls.RunInTransactionForSystem, callInfo)
	mock.lockRunInTransactionForSystem.Unlock()
	return mock.RunInTransactionForSystemFunc(ctx, f)
}

// RunInTransactionForSystemCalls gets all the calls that were made to RunInTransactionForSystem.
// Check the length with:
//
//	len(mockedRepository.RunInTransactionForSystemCalls())
func (mock *RepositoryMock) RunInTransactionForSystemCalls() []struct {
	Ctx context.Context
	F   func(context.Context, *sql.Tx) (int, error)
} {
	var calls []struct {
		Ctx context.Context
		F   func(context.Context, *sql.Tx) (int, error)
	}
	mock.lockRunInTransactionForSystem.RLock()
	calls = mock.calls.RunInTransactionForSystem
	mock.lockRunInTransactionForSystem.RUnlock()
	return calls
}

// RunInTransactionForWorkspace calls RunInTransactionForWorkspaceFunc.
func (mock *RepositoryMock) RunInTransactionForWorkspace(ctx context.Context, workspaceID string, f func(context.Context, *sql.Tx) (int, error)) (int, error) {
	if mock.RunInTransactionForWorkspaceFunc == nil {
		panic("RepositoryMock.RunInTransactionForWorkspaceFunc: method is nil but Repository.RunInTransactionForWorkspace was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		WorkspaceID string
		F           func(context.Context, *sql.Tx) (int, error)
	}{
		Ctx:         ctx,
		WorkspaceID: workspaceID,
		F:           f,
	}
	mock.lockRunInTransactionForWorkspace.Lock()
	mock.calls.RunInTransactionForWorkspace = append(mock.calls.RunInTransactionForWorkspace, callInfo)
	mock.lockRunInTransactionForWorkspace.Unlock()
	return mock.RunInTransactionForWorkspaceFunc(ctx, workspaceID, f)
}

// RunInTransactionForWorkspaceCalls gets all the calls that were made to RunInTransactionForWorkspace.
// Check the length with:
//
//	len(mockedRepository.RunInTransactionForWorkspaceCalls())
func (mock *RepositoryMock) RunInTransactionForWorkspaceCalls() []struct {
	Ctx         context.Context
	WorkspaceID string
	F           func(context.Context, *sql.Tx) (int, error)
} {
	var calls []struct {
		Ctx         context.Context
		WorkspaceID string
		F           func(context.Context, *sql.Tx) (int, error)
	}
	mock.lockRunInTransactionForWorkspace.RLock()
	calls = mock.calls.RunInTransactionForWorkspace
	mock.lockRunInTransactionForWorkspace.RUnlock()
	return calls
}

// SetTaskExecError calls SetTaskExecErrorFunc.
func (mock *RepositoryMock) SetTaskExecError(ctx context.Context, workspaceID string, taskExecID string, workerID int, status int, message string) error {
	if mock.SetTaskExecErrorFunc == nil {
		panic("RepositoryMock.SetTaskExecErrorFunc: method is nil but Repository.SetTaskExecError was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		WorkspaceID string
		TaskExecID  string
		WorkerID    int
		Status      int
		Message     string
	}{
		Ctx:         ctx,
		WorkspaceID: workspaceID,
		TaskExecID:  taskExecID,
		WorkerID:    workerID,
		Status:      status,
		Message:     message,
	}
	mock.lockSetTaskExecError.Lock()
	mock.calls.SetTaskExecError = append(mock.calls.SetTaskExecError, callInfo)
	mock.lockSetTaskExecError.Unlock()
	return mock.SetTaskExecErrorFunc(ctx, workspaceID, taskExecID, workerID, status, message)
}

// SetTaskExecErrorCalls gets all the calls that were made to SetTaskExecError.
// Check the length with:
//
//	len(mockedRepository.SetTaskExecErrorCalls())
func (mock *RepositoryMock) SetTaskExecErrorCalls() []struct {
	Ctx         context.Context
	WorkspaceID string
	TaskExecID  string
	WorkerID    int
	Status      int
	Message     string
} {
	var calls []struct {
		Ctx         context.Context
		WorkspaceID string
		TaskExecID  string
		WorkerID    int
		Status      int
		Message     string
	}
	mock.lockSetTaskExecError.RLock()
	calls = mock.calls.SetTaskExecError
	mock.lockSetTaskExecError.RUnlock()
	return calls
}

// ShowTables calls ShowTablesFunc.
func (mock *RepositoryMock) ShowTables(ctx context.Context, workspaceID string) ([]*entity.TableInformationSchema, error) {
	if mock.ShowTablesFunc == nil {
		panic("RepositoryMock.ShowTablesFunc: method is nil but Repository.ShowTables was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		WorkspaceID string
	}{
		Ctx:         ctx,
		WorkspaceID: workspaceID,
	}
	mock.lockShowTables.Lock()
	mock.calls.ShowTables = append(mock.calls.ShowTables, callInfo)
	mock.lockShowTables.Unlock()
	return mock.ShowTablesFunc(ctx, workspaceID)
}

// ShowTablesCalls gets all the calls that were made to ShowTables.
// Check the length with:
//
//	len(mockedRepository.ShowTablesCalls())
func (mock *RepositoryMock) ShowTablesCalls() []struct {
	Ctx         context.Context
	WorkspaceID string
} {
	var calls []struct {
		Ctx         context.Context
		WorkspaceID string
	}
	mock.lockShowTables.RLock()
	calls = mock.calls.ShowTables
	mock.lockShowTables.RUnlock()
	return calls
}

// StopAppTasks calls StopAppTasksFunc.
func (mock *RepositoryMock) StopAppTasks(ctx context.Context, workspaceID string, appID string, tx *sql.Tx) error {
	if mock.StopAppTasksFunc == nil {
		panic("RepositoryMock.StopAppTasksFunc: method is nil but Repository.StopAppTasks was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		WorkspaceID string
		AppID       string
		Tx          *sql.Tx
	}{
		Ctx:         ctx,
		WorkspaceID: workspaceID,
		AppID:       appID,
		Tx:          tx,
	}
	mock.lockStopAppTasks.Lock()
	mock.calls.StopAppTasks = append(mock.calls.StopAppTasks, callInfo)
	mock.lockStopAppTasks.Unlock()
	return mock.StopAppTasksFunc(ctx, workspaceID, appID, tx)
}

// StopAppTasksCalls gets all the calls that were made to StopAppTasks.
// Check the length with:
//
//	len(mockedRepository.StopAppTasksCalls())
func (mock *RepositoryMock) StopAppTasksCalls() []struct {
	Ctx         context.Context
	WorkspaceID string
	AppID       string
	Tx          *sql.Tx
} {
	var calls []struct {
		Ctx         context.Context
		WorkspaceID string
		AppID       string
		Tx          *sql.Tx
	}
	mock.lockStopAppTasks.RLock()
	calls = mock.calls.StopAppTasks
	mock.lockStopAppTasks.RUnlock()
	return calls
}

// StopTaskExecsForApp calls StopTaskExecsForAppFunc.
func (mock *RepositoryMock) StopTaskExecsForApp(ctx context.Context, appID string, tx *sql.Tx) error {
	if mock.StopTaskExecsForAppFunc == nil {
		panic("RepositoryMock.StopTaskExecsForAppFunc: method is nil but Repository.StopTaskExecsForApp was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		AppID string
		Tx    *sql.Tx
	}{
		Ctx:   ctx,
		AppID: appID,
		Tx:    tx,
	}
	mock.lockStopTaskExecsForApp.Lock()
	mock.calls.StopTaskExecsForApp = append(mock.calls.StopTaskExecsForApp, callInfo)
	mock.lockStopTaskExecsForApp.Unlock()
	return mock.StopTaskExecsForAppFunc(ctx, appID, tx)
}

// StopTaskExecsForAppCalls gets all the calls that were made to StopTaskExecsForApp.
// Check the length with:
//
//	len(mockedRepository.StopTaskExecsForAppCalls())
func (mock *RepositoryMock) StopTaskExecsForAppCalls() []struct {
	Ctx   context.Context
	AppID string
	Tx    *sql.Tx
} {
	var calls []struct {
		Ctx   context.Context
		AppID string
		Tx    *sql.Tx
	}
	mock.lockStopTaskExecsForApp.RLock()
	calls = mock.calls.StopTaskExecsForApp
	mock.lockStopTaskExecsForApp.RUnlock()
	return calls
}

// TransferOrganizationOwnsership calls TransferOrganizationOwnsershipFunc.
func (mock *RepositoryMock) TransferOrganizationOwnsership(ctx context.Context, accountID string, toAccountID string, organizationID string) error {
	if mock.TransferOrganizationOwnsershipFunc == nil {
		panic("RepositoryMock.TransferOrganizationOwnsershipFunc: method is nil but Repository.TransferOrganizationOwnsership was just called")
	}
	callInfo := struct {
		Ctx            context.Context
		AccountID      string
		ToAccountID    string
		OrganizationID string
	}{
		Ctx:            ctx,
		AccountID:      accountID,
		ToAccountID:    toAccountID,
		OrganizationID: organizationID,
	}
	mock.lockTransferOrganizationOwnsership.Lock()
	mock.calls.TransferOrganizationOwnsership = append(mock.calls.TransferOrganizationOwnsership, callInfo)
	mock.lockTransferOrganizationOwnsership.Unlock()
	return mock.TransferOrganizationOwnsershipFunc(ctx, accountID, toAccountID, organizationID)
}

// TransferOrganizationOwnsershipCalls gets all the calls that were made to TransferOrganizationOwnsership.
// Check the length with:
//
//	len(mockedRepository.TransferOrganizationOwnsershipCalls())
func (mock *RepositoryMock) TransferOrganizationOwnsershipCalls() []struct {
	Ctx            context.Context
	AccountID      string
	ToAccountID    string
	OrganizationID string
} {
	var calls []struct {
		Ctx            context.Context
		AccountID      string
		ToAccountID    string
		OrganizationID string
	}
	mock.lockTransferOrganizationOwnsership.RLock()
	calls = mock.calls.TransferOrganizationOwnsership
	mock.lockTransferOrganizationOwnsership.RUnlock()
	return calls
}

// UpdateAccountProfile calls UpdateAccountProfileFunc.
func (mock *RepositoryMock) UpdateAccountProfile(ctx context.Context, account *entity.Account) error {
	if mock.UpdateAccountProfileFunc == nil {
		panic("RepositoryMock.UpdateAccountProfileFunc: method is nil but Repository.UpdateAccountProfile was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Account *entity.Account
	}{
		Ctx:     ctx,
		Account: account,
	}
	mock.lockUpdateAccountProfile.Lock()
	mock.calls.UpdateAccountProfile = append(mock.calls.UpdateAccountProfile, callInfo)
	mock.lockUpdateAccountProfile.Unlock()
	return mock.UpdateAccountProfileFunc(ctx, account)
}

// UpdateAccountProfileCalls gets all the calls that were made to UpdateAccountProfile.
// Check the length with:
//
//	len(mockedRepository.UpdateAccountProfileCalls())
func (mock *RepositoryMock) UpdateAccountProfileCalls() []struct {
	Ctx     context.Context
	Account *entity.Account
} {
	var calls []struct {
		Ctx     context.Context
		Account *entity.Account
	}
	mock.lockUpdateAccountProfile.RLock()
	calls = mock.calls.UpdateAccountProfile
	mock.lockUpdateAccountProfile.RUnlock()
	return calls
}

// UpdateAccountSessionLastAccess calls UpdateAccountSessionLastAccessFunc.
func (mock *RepositoryMock) UpdateAccountSessionLastAccess(ctx context.Context, accountID string, accountSessionID string, now time.Time) error {
	if mock.UpdateAccountSessionLastAccessFunc == nil {
		panic("RepositoryMock.UpdateAccountSessionLastAccessFunc: method is nil but Repository.UpdateAccountSessionLastAccess was just called")
	}
	callInfo := struct {
		Ctx              context.Context
		AccountID        string
		AccountSessionID string
		Now              time.Time
	}{
		Ctx:              ctx,
		AccountID:        accountID,
		AccountSessionID: accountSessionID,
		Now:              now,
	}
	mock.lockUpdateAccountSessionLastAccess.Lock()
	mock.calls.UpdateAccountSessionLastAccess = append(mock.calls.UpdateAccountSessionLastAccess, callInfo)
	mock.lockUpdateAccountSessionLastAccess.Unlock()
	return mock.UpdateAccountSessionLastAccessFunc(ctx, accountID, accountSessionID, now)
}

// UpdateAccountSessionLastAccessCalls gets all the calls that were made to UpdateAccountSessionLastAccess.
// Check the length with:
//
//	len(mockedRepository.UpdateAccountSessionLastAccessCalls())
func (mock *RepositoryMock) UpdateAccountSessionLastAccessCalls() []struct {
	Ctx              context.Context
	AccountID        string
	AccountSessionID string
	Now              time.Time
} {
	var calls []struct {
		Ctx              context.Context
		AccountID        string
		AccountSessionID string
		Now              time.Time
	}
	mock.lockUpdateAccountSessionLastAccess.RLock()
	calls = mock.calls.UpdateAccountSessionLastAccess
	mock.lockUpdateAccountSessionLastAccess.RUnlock()
	return calls
}

// UpdateApp calls UpdateAppFunc.
func (mock *RepositoryMock) UpdateApp(ctx context.Context, app *entity.App, tx *sql.Tx) error {
	if mock.UpdateAppFunc == nil {
		panic("RepositoryMock.UpdateAppFunc: method is nil but Repository.UpdateApp was just called")
	}
	callInfo := struct {
		Ctx context.Context
		App *entity.App
		Tx  *sql.Tx
	}{
		Ctx: ctx,
		App: app,
		Tx:  tx,
	}
	mock.lockUpdateApp.Lock()
	mock.calls.UpdateApp = append(mock.calls.UpdateApp, callInfo)
	mock.lockUpdateApp.Unlock()
	return mock.UpdateAppFunc(ctx, app, tx)
}

// UpdateAppCalls gets all the calls that were made to UpdateApp.
// Check the length with:
//
//	len(mockedRepository.UpdateAppCalls())
func (mock *RepositoryMock) UpdateAppCalls() []struct {
	Ctx context.Context
	App *entity.App
	Tx  *sql.Tx
} {
	var calls []struct {
		Ctx context.Context
		App *entity.App
		Tx  *sql.Tx
	}
	mock.lockUpdateApp.RLock()
	calls = mock.calls.UpdateApp
	mock.lockUpdateApp.RUnlock()
	return calls
}

// UpdateAppItem calls UpdateAppItemFunc.
func (mock *RepositoryMock) UpdateAppItem(ctx context.Context, kind string, upsertedAppItem *entity.AppItem, tx *sql.Tx) error {
	if mock.UpdateAppItemFunc == nil {
		panic("RepositoryMock.UpdateAppItemFunc: method is nil but Repository.UpdateAppItem was just called")
	}
	callInfo := struct {
		Ctx             context.Context
		Kind            string
		UpsertedAppItem *entity.AppItem
		Tx              *sql.Tx
	}{
		Ctx:             ctx,
		Kind:            kind,
		UpsertedAppItem: upsertedAppItem,
		Tx:              tx,
	}
	mock.lockUpdateAppItem.Lock()
	mock.calls.UpdateAppItem = append(mock.calls.UpdateAppItem, callInfo)
	mock.lockUpdateAppItem.Unlock()
	return mock.UpdateAppItemFunc(ctx, kind, upsertedAppItem, tx)
}

// UpdateAppItemCalls gets all the calls that were made to UpdateAppItem.
// Check the length with:
//
//	len(mockedRepository.UpdateAppItemCalls())
func (mock *RepositoryMock) UpdateAppItemCalls() []struct {
	Ctx             context.Context
	Kind            string
	UpsertedAppItem *entity.AppItem
	Tx              *sql.Tx
} {
	var calls []struct {
		Ctx             context.Context
		Kind            string
		UpsertedAppItem *entity.AppItem
		Tx              *sql.Tx
	}
	mock.lockUpdateAppItem.RLock()
	calls = mock.calls.UpdateAppItem
	mock.lockUpdateAppItem.RUnlock()
	return calls
}

// UpdateBroadcastCampaign calls UpdateBroadcastCampaignFunc.
func (mock *RepositoryMock) UpdateBroadcastCampaign(ctx context.Context, workspaceID string, campaign *entity.BroadcastCampaign, tx *sql.Tx) error {
	if mock.UpdateBroadcastCampaignFunc == nil {
		panic("RepositoryMock.UpdateBroadcastCampaignFunc: method is nil but Repository.UpdateBroadcastCampaign was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		WorkspaceID string
		Campaign    *entity.BroadcastCampaign
		Tx          *sql.Tx
	}{
		Ctx:         ctx,
		WorkspaceID: workspaceID,
		Campaign:    campaign,
		Tx:          tx,
	}
	mock.lockUpdateBroadcastCampaign.Lock()
	mock.calls.UpdateBroadcastCampaign = append(mock.calls.UpdateBroadcastCampaign, callInfo)
	mock.lockUpdateBroadcastCampaign.Unlock()
	return mock.UpdateBroadcastCampaignFunc(ctx, workspaceID, campaign, tx)
}

// UpdateBroadcastCampaignCalls gets all the calls that were made to UpdateBroadcastCampaign.
// Check the length with:
//
//	len(mockedRepository.UpdateBroadcastCampaignCalls())
func (mock *RepositoryMock) UpdateBroadcastCampaignCalls() []struct {
	Ctx         context.Context
	WorkspaceID string
	Campaign    *entity.BroadcastCampaign
	Tx          *sql.Tx
} {
	var calls []struct {
		Ctx         context.Context
		WorkspaceID string
		Campaign    *entity.BroadcastCampaign
		Tx          *sql.Tx
	}
	mock.lockUpdateBroadcastCampaign.RLock()
	calls = mock.calls.UpdateBroadcastCampaign
	mock.lockUpdateBroadcastCampaign.RUnlock()
	return calls
}

// UpdateCart calls UpdateCartFunc.
func (mock *RepositoryMock) UpdateCart(ctx context.Context, cart *entity.Cart, tx *sql.Tx) error {
	if mock.UpdateCartFunc == nil {
		panic("RepositoryMock.UpdateCartFunc: method is nil but Repository.UpdateCart was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Cart *entity.Cart
		Tx   *sql.Tx
	}{
		Ctx:  ctx,
		Cart: cart,
		Tx:   tx,
	}
	mock.lockUpdateCart.Lock()
	mock.calls.UpdateCart = append(mock.calls.UpdateCart, callInfo)
	mock.lockUpdateCart.Unlock()
	return mock.UpdateCartFunc(ctx, cart, tx)
}

// UpdateCartCalls gets all the calls that were made to UpdateCart.
// Check the length with:
//
//	len(mockedRepository.UpdateCartCalls())
func (mock *RepositoryMock) UpdateCartCalls() []struct {
	Ctx  context.Context
	Cart *entity.Cart
	Tx   *sql.Tx
} {
	var calls []struct {
		Ctx  context.Context
		Cart *entity.Cart
		Tx   *sql.Tx
	}
	mock.lockUpdateCart.RLock()
	calls = mock.calls.UpdateCart
	mock.lockUpdateCart.RUnlock()
	return calls
}

// UpdateCartItem calls UpdateCartItemFunc.
func (mock *RepositoryMock) UpdateCartItem(ctx context.Context, cartItem *entity.CartItem, tx *sql.Tx) error {
	if mock.UpdateCartItemFunc == nil {
		panic("RepositoryMock.UpdateCartItemFunc: method is nil but Repository.UpdateCartItem was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		CartItem *entity.CartItem
		Tx       *sql.Tx
	}{
		Ctx:      ctx,
		CartItem: cartItem,
		Tx:       tx,
	}
	mock.lockUpdateCartItem.Lock()
	mock.calls.UpdateCartItem = append(mock.calls.UpdateCartItem, callInfo)
	mock.lockUpdateCartItem.Unlock()
	return mock.UpdateCartItemFunc(ctx, cartItem, tx)
}

// UpdateCartItemCalls gets all the calls that were made to UpdateCartItem.
// Check the length with:
//
//	len(mockedRepository.UpdateCartItemCalls())
func (mock *RepositoryMock) UpdateCartItemCalls() []struct {
	Ctx      context.Context
	CartItem *entity.CartItem
	Tx       *sql.Tx
} {
	var calls []struct {
		Ctx      context.Context
		CartItem *entity.CartItem
		Tx       *sql.Tx
	}
	mock.lockUpdateCartItem.RLock()
	calls = mock.calls.UpdateCartItem
	mock.lockUpdateCartItem.RUnlock()
	return calls
}

// UpdateChannel calls UpdateChannelFunc.
func (mock *RepositoryMock) UpdateChannel(ctx context.Context, workspace *entity.Workspace, updatedChannel *entity.Channel) error {
	if mock.UpdateChannelFunc == nil {
		panic("RepositoryMock.UpdateChannelFunc: method is nil but Repository.UpdateChannel was just called")
	}
	callInfo := struct {
		Ctx            context.Context
		Workspace      *entity.Workspace
		UpdatedChannel *entity.Channel
	}{
		Ctx:            ctx,
		Workspace:      workspace,
		UpdatedChannel: updatedChannel,
	}
	mock.lockUpdateChannel.Lock()
	mock.calls.UpdateChannel = append(mock.calls.UpdateChannel, callInfo)
	mock.lockUpdateChannel.Unlock()
	return mock.UpdateChannelFunc(ctx, workspace, updatedChannel)
}

// UpdateChannelCalls gets all the calls that were made to UpdateChannel.
// Check the length with:
//
//	len(mockedRepository.UpdateChannelCalls())
func (mock *RepositoryMock) UpdateChannelCalls() []struct {
	Ctx            context.Context
	Workspace      *entity.Workspace
	UpdatedChannel *entity.Channel
} {
	var calls []struct {
		Ctx            context.Context
		Workspace      *entity.Workspace
		UpdatedChannel *entity.Channel
	}
	mock.lockUpdateChannel.RLock()
	calls = mock.calls.UpdateChannel
	mock.lockUpdateChannel.RUnlock()
	return calls
}

// UpdateCustomEvent calls UpdateCustomEventFunc.
func (mock *RepositoryMock) UpdateCustomEvent(ctx context.Context, event *entity.CustomEvent, tx *sql.Tx) error {
	if mock.UpdateCustomEventFunc == nil {
		panic("RepositoryMock.UpdateCustomEventFunc: method is nil but Repository.UpdateCustomEvent was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Event *entity.CustomEvent
		Tx    *sql.Tx
	}{
		Ctx:   ctx,
		Event: event,
		Tx:    tx,
	}
	mock.lockUpdateCustomEvent.Lock()
	mock.calls.UpdateCustomEvent = append(mock.calls.UpdateCustomEvent, callInfo)
	mock.lockUpdateCustomEvent.Unlock()
	return mock.UpdateCustomEventFunc(ctx, event, tx)
}

// UpdateCustomEventCalls gets all the calls that were made to UpdateCustomEvent.
// Check the length with:
//
//	len(mockedRepository.UpdateCustomEventCalls())
func (mock *RepositoryMock) UpdateCustomEventCalls() []struct {
	Ctx   context.Context
	Event *entity.CustomEvent
	Tx    *sql.Tx
} {
	var calls []struct {
		Ctx   context.Context
		Event *entity.CustomEvent
		Tx    *sql.Tx
	}
	mock.lockUpdateCustomEvent.RLock()
	calls = mock.calls.UpdateCustomEvent
	mock.lockUpdateCustomEvent.RUnlock()
	return calls
}

// UpdateDataLog calls UpdateDataLogFunc.
func (mock *RepositoryMock) UpdateDataLog(ctx context.Context, workspaceID string, dataLog *entity.DataLog) error {
	if mock.UpdateDataLogFunc == nil {
		panic("RepositoryMock.UpdateDataLogFunc: method is nil but Repository.UpdateDataLog was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		WorkspaceID string
		DataLog     *entity.DataLog
	}{
		Ctx:         ctx,
		WorkspaceID: workspaceID,
		DataLog:     dataLog,
	}
	mock.lockUpdateDataLog.Lock()
	mock.calls.UpdateDataLog = append(mock.calls.UpdateDataLog, callInfo)
	mock.lockUpdateDataLog.Unlock()
	return mock.UpdateDataLogFunc(ctx, workspaceID, dataLog)
}

// UpdateDataLogCalls gets all the calls that were made to UpdateDataLog.
// Check the length with:
//
//	len(mockedRepository.UpdateDataLogCalls())
func (mock *RepositoryMock) UpdateDataLogCalls() []struct {
	Ctx         context.Context
	WorkspaceID string
	DataLog     *entity.DataLog
} {
	var calls []struct {
		Ctx         context.Context
		WorkspaceID string
		DataLog     *entity.DataLog
	}
	mock.lockUpdateDataLog.RLock()
	calls = mock.calls.UpdateDataLog
	mock.lockUpdateDataLog.RUnlock()
	return calls
}

// UpdateDevice calls UpdateDeviceFunc.
func (mock *RepositoryMock) UpdateDevice(ctx context.Context, device *entity.Device, tx *sql.Tx) error {
	if mock.UpdateDeviceFunc == nil {
		panic("RepositoryMock.UpdateDeviceFunc: method is nil but Repository.UpdateDevice was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Device *entity.Device
		Tx     *sql.Tx
	}{
		Ctx:    ctx,
		Device: device,
		Tx:     tx,
	}
	mock.lockUpdateDevice.Lock()
	mock.calls.UpdateDevice = append(mock.calls.UpdateDevice, callInfo)
	mock.lockUpdateDevice.Unlock()
	return mock.UpdateDeviceFunc(ctx, device, tx)
}

// UpdateDeviceCalls gets all the calls that were made to UpdateDevice.
// Check the length with:
//
//	len(mockedRepository.UpdateDeviceCalls())
func (mock *RepositoryMock) UpdateDeviceCalls() []struct {
	Ctx    context.Context
	Device *entity.Device
	Tx     *sql.Tx
} {
	var calls []struct {
		Ctx    context.Context
		Device *entity.Device
		Tx     *sql.Tx
	}
	mock.lockUpdateDevice.RLock()
	calls = mock.calls.UpdateDevice
	mock.lockUpdateDevice.RUnlock()
	return calls
}

// UpdateMessage calls UpdateMessageFunc.
func (mock *RepositoryMock) UpdateMessage(ctx context.Context, message *entity.Message, tx *sql.Tx) error {
	if mock.UpdateMessageFunc == nil {
		panic("RepositoryMock.UpdateMessageFunc: method is nil but Repository.UpdateMessage was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Message *entity.Message
		Tx      *sql.Tx
	}{
		Ctx:     ctx,
		Message: message,
		Tx:      tx,
	}
	mock.lockUpdateMessage.Lock()
	mock.calls.UpdateMessage = append(mock.calls.UpdateMessage, callInfo)
	mock.lockUpdateMessage.Unlock()
	return mock.UpdateMessageFunc(ctx, message, tx)
}

// UpdateMessageCalls gets all the calls that were made to UpdateMessage.
// Check the length with:
//
//	len(mockedRepository.UpdateMessageCalls())
func (mock *RepositoryMock) UpdateMessageCalls() []struct {
	Ctx     context.Context
	Message *entity.Message
	Tx      *sql.Tx
} {
	var calls []struct {
		Ctx     context.Context
		Message *entity.Message
		Tx      *sql.Tx
	}
	mock.lockUpdateMessage.RLock()
	calls = mock.calls.UpdateMessage
	mock.lockUpdateMessage.RUnlock()
	return calls
}

// UpdateOrder calls UpdateOrderFunc.
func (mock *RepositoryMock) UpdateOrder(ctx context.Context, order *entity.Order, tx *sql.Tx) error {
	if mock.UpdateOrderFunc == nil {
		panic("RepositoryMock.UpdateOrderFunc: method is nil but Repository.UpdateOrder was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Order *entity.Order
		Tx    *sql.Tx
	}{
		Ctx:   ctx,
		Order: order,
		Tx:    tx,
	}
	mock.lockUpdateOrder.Lock()
	mock.calls.UpdateOrder = append(mock.calls.UpdateOrder, callInfo)
	mock.lockUpdateOrder.Unlock()
	return mock.UpdateOrderFunc(ctx, order, tx)
}

// UpdateOrderCalls gets all the calls that were made to UpdateOrder.
// Check the length with:
//
//	len(mockedRepository.UpdateOrderCalls())
func (mock *RepositoryMock) UpdateOrderCalls() []struct {
	Ctx   context.Context
	Order *entity.Order
	Tx    *sql.Tx
} {
	var calls []struct {
		Ctx   context.Context
		Order *entity.Order
		Tx    *sql.Tx
	}
	mock.lockUpdateOrder.RLock()
	calls = mock.calls.UpdateOrder
	mock.lockUpdateOrder.RUnlock()
	return calls
}

// UpdateOrderAttribution calls UpdateOrderAttributionFunc.
func (mock *RepositoryMock) UpdateOrderAttribution(ctx context.Context, order *entity.Order, tx *sql.Tx) error {
	if mock.UpdateOrderAttributionFunc == nil {
		panic("RepositoryMock.UpdateOrderAttributionFunc: method is nil but Repository.UpdateOrderAttribution was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Order *entity.Order
		Tx    *sql.Tx
	}{
		Ctx:   ctx,
		Order: order,
		Tx:    tx,
	}
	mock.lockUpdateOrderAttribution.Lock()
	mock.calls.UpdateOrderAttribution = append(mock.calls.UpdateOrderAttribution, callInfo)
	mock.lockUpdateOrderAttribution.Unlock()
	return mock.UpdateOrderAttributionFunc(ctx, order, tx)
}

// UpdateOrderAttributionCalls gets all the calls that were made to UpdateOrderAttribution.
// Check the length with:
//
//	len(mockedRepository.UpdateOrderAttributionCalls())
func (mock *RepositoryMock) UpdateOrderAttributionCalls() []struct {
	Ctx   context.Context
	Order *entity.Order
	Tx    *sql.Tx
} {
	var calls []struct {
		Ctx   context.Context
		Order *entity.Order
		Tx    *sql.Tx
	}
	mock.lockUpdateOrderAttribution.RLock()
	calls = mock.calls.UpdateOrderAttribution
	mock.lockUpdateOrderAttribution.RUnlock()
	return calls
}

// UpdateOrderItem calls UpdateOrderItemFunc.
func (mock *RepositoryMock) UpdateOrderItem(ctx context.Context, orderItem *entity.OrderItem, tx *sql.Tx) error {
	if mock.UpdateOrderItemFunc == nil {
		panic("RepositoryMock.UpdateOrderItemFunc: method is nil but Repository.UpdateOrderItem was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		OrderItem *entity.OrderItem
		Tx        *sql.Tx
	}{
		Ctx:       ctx,
		OrderItem: orderItem,
		Tx:        tx,
	}
	mock.lockUpdateOrderItem.Lock()
	mock.calls.UpdateOrderItem = append(mock.calls.UpdateOrderItem, callInfo)
	mock.lockUpdateOrderItem.Unlock()
	return mock.UpdateOrderItemFunc(ctx, orderItem, tx)
}

// UpdateOrderItemCalls gets all the calls that were made to UpdateOrderItem.
// Check the length with:
//
//	len(mockedRepository.UpdateOrderItemCalls())
func (mock *RepositoryMock) UpdateOrderItemCalls() []struct {
	Ctx       context.Context
	OrderItem *entity.OrderItem
	Tx        *sql.Tx
} {
	var calls []struct {
		Ctx       context.Context
		OrderItem *entity.OrderItem
		Tx        *sql.Tx
	}
	mock.lockUpdateOrderItem.RLock()
	calls = mock.calls.UpdateOrderItem
	mock.lockUpdateOrderItem.RUnlock()
	return calls
}

// UpdateOrganizationProfile calls UpdateOrganizationProfileFunc.
func (mock *RepositoryMock) UpdateOrganizationProfile(ctx context.Context, organization *entity.Organization) error {
	if mock.UpdateOrganizationProfileFunc == nil {
		panic("RepositoryMock.UpdateOrganizationProfileFunc: method is nil but Repository.UpdateOrganizationProfile was just called")
	}
	callInfo := struct {
		Ctx          context.Context
		Organization *entity.Organization
	}{
		Ctx:          ctx,
		Organization: organization,
	}
	mock.lockUpdateOrganizationProfile.Lock()
	mock.calls.UpdateOrganizationProfile = append(mock.calls.UpdateOrganizationProfile, callInfo)
	mock.lockUpdateOrganizationProfile.Unlock()
	return mock.UpdateOrganizationProfileFunc(ctx, organization)
}

// UpdateOrganizationProfileCalls gets all the calls that were made to UpdateOrganizationProfile.
// Check the length with:
//
//	len(mockedRepository.UpdateOrganizationProfileCalls())
func (mock *RepositoryMock) UpdateOrganizationProfileCalls() []struct {
	Ctx          context.Context
	Organization *entity.Organization
} {
	var calls []struct {
		Ctx          context.Context
		Organization *entity.Organization
	}
	mock.lockUpdateOrganizationProfile.RLock()
	calls = mock.calls.UpdateOrganizationProfile
	mock.lockUpdateOrganizationProfile.RUnlock()
	return calls
}

// UpdatePageview calls UpdatePageviewFunc.
func (mock *RepositoryMock) UpdatePageview(ctx context.Context, pageview *entity.Pageview, tx *sql.Tx) error {
	if mock.UpdatePageviewFunc == nil {
		panic("RepositoryMock.UpdatePageviewFunc: method is nil but Repository.UpdatePageview was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Pageview *entity.Pageview
		Tx       *sql.Tx
	}{
		Ctx:      ctx,
		Pageview: pageview,
		Tx:       tx,
	}
	mock.lockUpdatePageview.Lock()
	mock.calls.UpdatePageview = append(mock.calls.UpdatePageview, callInfo)
	mock.lockUpdatePageview.Unlock()
	return mock.UpdatePageviewFunc(ctx, pageview, tx)
}

// UpdatePageviewCalls gets all the calls that were made to UpdatePageview.
// Check the length with:
//
//	len(mockedRepository.UpdatePageviewCalls())
func (mock *RepositoryMock) UpdatePageviewCalls() []struct {
	Ctx      context.Context
	Pageview *entity.Pageview
	Tx       *sql.Tx
} {
	var calls []struct {
		Ctx      context.Context
		Pageview *entity.Pageview
		Tx       *sql.Tx
	}
	mock.lockUpdatePageview.RLock()
	calls = mock.calls.UpdatePageview
	mock.lockUpdatePageview.RUnlock()
	return calls
}

// UpdatePostview calls UpdatePostviewFunc.
func (mock *RepositoryMock) UpdatePostview(ctx context.Context, postview *entity.Postview, tx *sql.Tx) error {
	if mock.UpdatePostviewFunc == nil {
		panic("RepositoryMock.UpdatePostviewFunc: method is nil but Repository.UpdatePostview was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Postview *entity.Postview
		Tx       *sql.Tx
	}{
		Ctx:      ctx,
		Postview: postview,
		Tx:       tx,
	}
	mock.lockUpdatePostview.Lock()
	mock.calls.UpdatePostview = append(mock.calls.UpdatePostview, callInfo)
	mock.lockUpdatePostview.Unlock()
	return mock.UpdatePostviewFunc(ctx, postview, tx)
}

// UpdatePostviewCalls gets all the calls that were made to UpdatePostview.
// Check the length with:
//
//	len(mockedRepository.UpdatePostviewCalls())
func (mock *RepositoryMock) UpdatePostviewCalls() []struct {
	Ctx      context.Context
	Postview *entity.Postview
	Tx       *sql.Tx
} {
	var calls []struct {
		Ctx      context.Context
		Postview *entity.Postview
		Tx       *sql.Tx
	}
	mock.lockUpdatePostview.RLock()
	calls = mock.calls.UpdatePostview
	mock.lockUpdatePostview.RUnlock()
	return calls
}

// UpdateSegment calls UpdateSegmentFunc.
func (mock *RepositoryMock) UpdateSegment(ctx context.Context, segment *entity.Segment, tx *sql.Tx) error {
	if mock.UpdateSegmentFunc == nil {
		panic("RepositoryMock.UpdateSegmentFunc: method is nil but Repository.UpdateSegment was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Segment *entity.Segment
		Tx      *sql.Tx
	}{
		Ctx:     ctx,
		Segment: segment,
		Tx:      tx,
	}
	mock.lockUpdateSegment.Lock()
	mock.calls.UpdateSegment = append(mock.calls.UpdateSegment, callInfo)
	mock.lockUpdateSegment.Unlock()
	return mock.UpdateSegmentFunc(ctx, segment, tx)
}

// UpdateSegmentCalls gets all the calls that were made to UpdateSegment.
// Check the length with:
//
//	len(mockedRepository.UpdateSegmentCalls())
func (mock *RepositoryMock) UpdateSegmentCalls() []struct {
	Ctx     context.Context
	Segment *entity.Segment
	Tx      *sql.Tx
} {
	var calls []struct {
		Ctx     context.Context
		Segment *entity.Segment
		Tx      *sql.Tx
	}
	mock.lockUpdateSegment.RLock()
	calls = mock.calls.UpdateSegment
	mock.lockUpdateSegment.RUnlock()
	return calls
}

// UpdateSession calls UpdateSessionFunc.
func (mock *RepositoryMock) UpdateSession(ctx context.Context, session *entity.Session, tx *sql.Tx) error {
	if mock.UpdateSessionFunc == nil {
		panic("RepositoryMock.UpdateSessionFunc: method is nil but Repository.UpdateSession was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Session *entity.Session
		Tx      *sql.Tx
	}{
		Ctx:     ctx,
		Session: session,
		Tx:      tx,
	}
	mock.lockUpdateSession.Lock()
	mock.calls.UpdateSession = append(mock.calls.UpdateSession, callInfo)
	mock.lockUpdateSession.Unlock()
	return mock.UpdateSessionFunc(ctx, session, tx)
}

// UpdateSessionCalls gets all the calls that were made to UpdateSession.
// Check the length with:
//
//	len(mockedRepository.UpdateSessionCalls())
func (mock *RepositoryMock) UpdateSessionCalls() []struct {
	Ctx     context.Context
	Session *entity.Session
	Tx      *sql.Tx
} {
	var calls []struct {
		Ctx     context.Context
		Session *entity.Session
		Tx      *sql.Tx
	}
	mock.lockUpdateSession.RLock()
	calls = mock.calls.UpdateSession
	mock.lockUpdateSession.RUnlock()
	return calls
}

// UpdateSubscriptionListUser calls UpdateSubscriptionListUserFunc.
func (mock *RepositoryMock) UpdateSubscriptionListUser(ctx context.Context, subscription *entity.SubscriptionListUser, tx *sql.Tx) error {
	if mock.UpdateSubscriptionListUserFunc == nil {
		panic("RepositoryMock.UpdateSubscriptionListUserFunc: method is nil but Repository.UpdateSubscriptionListUser was just called")
	}
	callInfo := struct {
		Ctx          context.Context
		Subscription *entity.SubscriptionListUser
		Tx           *sql.Tx
	}{
		Ctx:          ctx,
		Subscription: subscription,
		Tx:           tx,
	}
	mock.lockUpdateSubscriptionListUser.Lock()
	mock.calls.UpdateSubscriptionListUser = append(mock.calls.UpdateSubscriptionListUser, callInfo)
	mock.lockUpdateSubscriptionListUser.Unlock()
	return mock.UpdateSubscriptionListUserFunc(ctx, subscription, tx)
}

// UpdateSubscriptionListUserCalls gets all the calls that were made to UpdateSubscriptionListUser.
// Check the length with:
//
//	len(mockedRepository.UpdateSubscriptionListUserCalls())
func (mock *RepositoryMock) UpdateSubscriptionListUserCalls() []struct {
	Ctx          context.Context
	Subscription *entity.SubscriptionListUser
	Tx           *sql.Tx
} {
	var calls []struct {
		Ctx          context.Context
		Subscription *entity.SubscriptionListUser
		Tx           *sql.Tx
	}
	mock.lockUpdateSubscriptionListUser.RLock()
	calls = mock.calls.UpdateSubscriptionListUser
	mock.lockUpdateSubscriptionListUser.RUnlock()
	return calls
}

// UpdateTask calls UpdateTaskFunc.
func (mock *RepositoryMock) UpdateTask(ctx context.Context, task *entity.Task, tx *sql.Tx) error {
	if mock.UpdateTaskFunc == nil {
		panic("RepositoryMock.UpdateTaskFunc: method is nil but Repository.UpdateTask was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Task *entity.Task
		Tx   *sql.Tx
	}{
		Ctx:  ctx,
		Task: task,
		Tx:   tx,
	}
	mock.lockUpdateTask.Lock()
	mock.calls.UpdateTask = append(mock.calls.UpdateTask, callInfo)
	mock.lockUpdateTask.Unlock()
	return mock.UpdateTaskFunc(ctx, task, tx)
}

// UpdateTaskCalls gets all the calls that were made to UpdateTask.
// Check the length with:
//
//	len(mockedRepository.UpdateTaskCalls())
func (mock *RepositoryMock) UpdateTaskCalls() []struct {
	Ctx  context.Context
	Task *entity.Task
	Tx   *sql.Tx
} {
	var calls []struct {
		Ctx  context.Context
		Task *entity.Task
		Tx   *sql.Tx
	}
	mock.lockUpdateTask.RLock()
	calls = mock.calls.UpdateTask
	mock.lockUpdateTask.RUnlock()
	return calls
}

// UpdateTaskExecFromResult calls UpdateTaskExecFromResultFunc.
func (mock *RepositoryMock) UpdateTaskExecFromResult(ctx context.Context, taskExecRequestPayload *dto.TaskExecRequestPayload, taskExecResult *entity.TaskExecResult, tx *sql.Tx) error {
	if mock.UpdateTaskExecFromResultFunc == nil {
		panic("RepositoryMock.UpdateTaskExecFromResultFunc: method is nil but Repository.UpdateTaskExecFromResult was just called")
	}
	callInfo := struct {
		Ctx                    context.Context
		TaskExecRequestPayload *dto.TaskExecRequestPayload
		TaskExecResult         *entity.TaskExecResult
		Tx                     *sql.Tx
	}{
		Ctx:                    ctx,
		TaskExecRequestPayload: taskExecRequestPayload,
		TaskExecResult:         taskExecResult,
		Tx:                     tx,
	}
	mock.lockUpdateTaskExecFromResult.Lock()
	mock.calls.UpdateTaskExecFromResult = append(mock.calls.UpdateTaskExecFromResult, callInfo)
	mock.lockUpdateTaskExecFromResult.Unlock()
	return mock.UpdateTaskExecFromResultFunc(ctx, taskExecRequestPayload, taskExecResult, tx)
}

// UpdateTaskExecFromResultCalls gets all the calls that were made to UpdateTaskExecFromResult.
// Check the length with:
//
//	len(mockedRepository.UpdateTaskExecFromResultCalls())
func (mock *RepositoryMock) UpdateTaskExecFromResultCalls() []struct {
	Ctx                    context.Context
	TaskExecRequestPayload *dto.TaskExecRequestPayload
	TaskExecResult         *entity.TaskExecResult
	Tx                     *sql.Tx
} {
	var calls []struct {
		Ctx                    context.Context
		TaskExecRequestPayload *dto.TaskExecRequestPayload
		TaskExecResult         *entity.TaskExecResult
		Tx                     *sql.Tx
	}
	mock.lockUpdateTaskExecFromResult.RLock()
	calls = mock.calls.UpdateTaskExecFromResult
	mock.lockUpdateTaskExecFromResult.RUnlock()
	return calls
}

// UpdateUser calls UpdateUserFunc.
func (mock *RepositoryMock) UpdateUser(ctx context.Context, user *entity.User, tx *sql.Tx) error {
	if mock.UpdateUserFunc == nil {
		panic("RepositoryMock.UpdateUserFunc: method is nil but Repository.UpdateUser was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		User *entity.User
		Tx   *sql.Tx
	}{
		Ctx:  ctx,
		User: user,
		Tx:   tx,
	}
	mock.lockUpdateUser.Lock()
	mock.calls.UpdateUser = append(mock.calls.UpdateUser, callInfo)
	mock.lockUpdateUser.Unlock()
	return mock.UpdateUserFunc(ctx, user, tx)
}

// UpdateUserCalls gets all the calls that were made to UpdateUser.
// Check the length with:
//
//	len(mockedRepository.UpdateUserCalls())
func (mock *RepositoryMock) UpdateUserCalls() []struct {
	Ctx  context.Context
	User *entity.User
	Tx   *sql.Tx
} {
	var calls []struct {
		Ctx  context.Context
		User *entity.User
		Tx   *sql.Tx
	}
	mock.lockUpdateUser.RLock()
	calls = mock.calls.UpdateUser
	mock.lockUpdateUser.RUnlock()
	return calls
}

// UpdateWorkspace calls UpdateWorkspaceFunc.
func (mock *RepositoryMock) UpdateWorkspace(ctx context.Context, workspace *entity.Workspace, tx *sql.Tx) error {
	if mock.UpdateWorkspaceFunc == nil {
		panic("RepositoryMock.UpdateWorkspaceFunc: method is nil but Repository.UpdateWorkspace was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Workspace *entity.Workspace
		Tx        *sql.Tx
	}{
		Ctx:       ctx,
		Workspace: workspace,
		Tx:        tx,
	}
	mock.lockUpdateWorkspace.Lock()
	mock.calls.UpdateWorkspace = append(mock.calls.UpdateWorkspace, callInfo)
	mock.lockUpdateWorkspace.Unlock()
	return mock.UpdateWorkspaceFunc(ctx, workspace, tx)
}

// UpdateWorkspaceCalls gets all the calls that were made to UpdateWorkspace.
// Check the length with:
//
//	len(mockedRepository.UpdateWorkspaceCalls())
func (mock *RepositoryMock) UpdateWorkspaceCalls() []struct {
	Ctx       context.Context
	Workspace *entity.Workspace
	Tx        *sql.Tx
} {
	var calls []struct {
		Ctx       context.Context
		Workspace *entity.Workspace
		Tx        *sql.Tx
	}
	mock.lockUpdateWorkspace.RLock()
	calls = mock.calls.UpdateWorkspace
	mock.lockUpdateWorkspace.RUnlock()
	return calls
}

// UpsertOrganizationInvitation calls UpsertOrganizationInvitationFunc.
func (mock *RepositoryMock) UpsertOrganizationInvitation(ctx context.Context, accountInvitation *entity.OrganizationInvitation) error {
	if mock.UpsertOrganizationInvitationFunc == nil {
		panic("RepositoryMock.UpsertOrganizationInvitationFunc: method is nil but Repository.UpsertOrganizationInvitation was just called")
	}
	callInfo := struct {
		Ctx               context.Context
		AccountInvitation *entity.OrganizationInvitation
	}{
		Ctx:               ctx,
		AccountInvitation: accountInvitation,
	}
	mock.lockUpsertOrganizationInvitation.Lock()
	mock.calls.UpsertOrganizationInvitation = append(mock.calls.UpsertOrganizationInvitation, callInfo)
	mock.lockUpsertOrganizationInvitation.Unlock()
	return mock.UpsertOrganizationInvitationFunc(ctx, accountInvitation)
}

// UpsertOrganizationInvitationCalls gets all the calls that were made to UpsertOrganizationInvitation.
// Check the length with:
//
//	len(mockedRepository.UpsertOrganizationInvitationCalls())
func (mock *RepositoryMock) UpsertOrganizationInvitationCalls() []struct {
	Ctx               context.Context
	AccountInvitation *entity.OrganizationInvitation
} {
	var calls []struct {
		Ctx               context.Context
		AccountInvitation *entity.OrganizationInvitation
	}
	mock.lockUpsertOrganizationInvitation.RLock()
	calls = mock.calls.UpsertOrganizationInvitation
	mock.lockUpsertOrganizationInvitation.RUnlock()
	return calls
}

// UseWorkspaceDBWithTx calls UseWorkspaceDBWithTxFunc.
func (mock *RepositoryMock) UseWorkspaceDBWithTx(ctx context.Context, workspaceID string, tx *sql.Tx) error {
	if mock.UseWorkspaceDBWithTxFunc == nil {
		panic("RepositoryMock.UseWorkspaceDBWithTxFunc: method is nil but Repository.UseWorkspaceDBWithTx was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		WorkspaceID string
		Tx          *sql.Tx
	}{
		Ctx:         ctx,
		WorkspaceID: workspaceID,
		Tx:          tx,
	}
	mock.lockUseWorkspaceDBWithTx.Lock()
	mock.calls.UseWorkspaceDBWithTx = append(mock.calls.UseWorkspaceDBWithTx, callInfo)
	mock.lockUseWorkspaceDBWithTx.Unlock()
	return mock.UseWorkspaceDBWithTxFunc(ctx, workspaceID, tx)
}

// UseWorkspaceDBWithTxCalls gets all the calls that were made to UseWorkspaceDBWithTx.
// Check the length with:
//
//	len(mockedRepository.UseWorkspaceDBWithTxCalls())
func (mock *RepositoryMock) UseWorkspaceDBWithTxCalls() []struct {
	Ctx         context.Context
	WorkspaceID string
	Tx          *sql.Tx
} {
	var calls []struct {
		Ctx         context.Context
		WorkspaceID string
		Tx          *sql.Tx
	}
	mock.lockUseWorkspaceDBWithTx.RLock()
	calls = mock.calls.UseWorkspaceDBWithTx
	mock.lockUseWorkspaceDBWithTx.RUnlock()
	return calls
}
