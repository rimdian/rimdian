// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package service

import (
	"context"
	"database/sql"
	"github.com/rimdian/rimdian/internal/api/entity"
	"github.com/rimdian/rimdian/internal/api/repository"
	common "github.com/rimdian/rimdian/internal/common/dto"
	"github.com/rimdian/rimdian/internal/common/httpClient"
	"sync"
	"time"
)

// Ensure, that IDataLogPipelineMock does implement IDataLogPipeline.
// If this is not the case, regenerate this file with moq.
var _ IDataLogPipeline = &IDataLogPipelineMock{}

// IDataLogPipelineMock is a mock implementation of IDataLogPipeline.
//
//	func TestSomethingThatUsesIDataLogPipeline(t *testing.T) {
//
//		// make and configure a mocked IDataLogPipeline
//		mockedIDataLogPipeline := &IDataLogPipelineMock{
//			AddDataLogGeneratedFunc: func(dataLog *entity.DataLog)  {
//				panic("mock out the AddDataLogGenerated method")
//			},
//			AttributeOrderFunc: func(ctx context.Context, order *entity.Order, orderSessions []*entity.Session, orderPostviews []*entity.Postview, previousOrders []*entity.Order, devices []*entity.Device, tx *sql.Tx)  {
//				panic("mock out the AttributeOrder method")
//			},
//			CfgFunc: func() *entity.Config {
//				panic("mock out the Cfg method")
//			},
//			ComputeSegmentsForGivenUsersFunc: func(ctx context.Context)  {
//				panic("mock out the ComputeSegmentsForGivenUsers method")
//			},
//			CreateDataLogFromQueueFunc: func(ctx context.Context)  {
//				panic("mock out the CreateDataLogFromQueue method")
//			},
//			DataLogEnqueueFunc: func(ctx context.Context, replayID *string, origin int, originID string, workspaceID string, jsonItems []string, isSync bool)  {
//				panic("mock out the DataLogEnqueue method")
//			},
//			EnsureUsersLockFunc: func(ctx context.Context) error {
//				panic("mock out the EnsureUsersLock method")
//			},
//			ExecuteFunc: func(ctx context.Context)  {
//				panic("mock out the Execute method")
//			},
//			ExtractAndValidateItemFunc: func()  {
//				panic("mock out the ExtractAndValidateItem method")
//			},
//			ExtractAppItemFromDataLogItemFunc: func()  {
//				panic("mock out the ExtractAppItemFromDataLogItem method")
//			},
//			ExtractCartFromDataLogItemFunc: func()  {
//				panic("mock out the ExtractCartFromDataLogItem method")
//			},
//			ExtractCustomEventFromDataLogItemFunc: func()  {
//				panic("mock out the ExtractCustomEventFromDataLogItem method")
//			},
//			ExtractDeviceFromDataLogItemFunc: func(userID string)  {
//				panic("mock out the ExtractDeviceFromDataLogItem method")
//			},
//			ExtractExtraColumnsFromItemFunc: func(kind string)  {
//				panic("mock out the ExtractExtraColumnsFromItem method")
//			},
//			ExtractOrderFromDataLogItemFunc: func()  {
//				panic("mock out the ExtractOrderFromDataLogItem method")
//			},
//			ExtractPageviewFromDataLogItemFunc: func()  {
//				panic("mock out the ExtractPageviewFromDataLogItem method")
//			},
//			ExtractPostviewFromDataLogItemFunc: func()  {
//				panic("mock out the ExtractPostviewFromDataLogItem method")
//			},
//			ExtractSessionFromDataLogItemFunc: func(isMandatory bool)  {
//				panic("mock out the ExtractSessionFromDataLogItem method")
//			},
//			ExtractUserAliasFromDataLogItemFunc: func()  {
//				panic("mock out the ExtractUserAliasFromDataLogItem method")
//			},
//			ExtractUserFromDataLogItemFunc: func()  {
//				panic("mock out the ExtractUserFromDataLogItem method")
//			},
//			GetDataLogFunc: func() *entity.DataLog {
//				panic("mock out the GetDataLog method")
//			},
//			GetDataLogsGeneratedFunc: func() []*entity.DataLog {
//				panic("mock out the GetDataLogsGenerated method")
//			},
//			GetQueueResultFunc: func() *common.DataLogInQueueResult {
//				panic("mock out the GetQueueResult method")
//			},
//			GetUserIDsFunc: func() []string {
//				panic("mock out the GetUserIDs method")
//			},
//			GetWorkspaceFunc: func() *entity.Workspace {
//				panic("mock out the GetWorkspace method")
//			},
//			HasErrorFunc: func() bool {
//				panic("mock out the HasError method")
//			},
//			InitDataLogFunc: func(ctx context.Context)  {
//				panic("mock out the InitDataLog method")
//			},
//			InsertChildDataLogFunc: func(ctx context.Context, kind string, action string, userID string, itemID string, itemExternalID string, updatedFields entity.UpdatedFields, eventAt time.Time, tx *sql.Tx) error {
//				panic("mock out the InsertChildDataLog method")
//			},
//			LoadFxRatesFunc: func(ctx context.Context) error {
//				panic("mock out the LoadFxRates method")
//			},
//			NetFunc: func() httpClient.HTTPClient {
//				panic("mock out the Net method")
//			},
//			ParseUserAgentFunc: func(userAgent string) (*entity.UserAgentResult, error) {
//				panic("mock out the ParseUserAgent method")
//			},
//			ProcessNextStepFunc: func(ctx context.Context)  {
//				panic("mock out the ProcessNextStep method")
//			},
//			ReattributeUsersOrdersFunc: func(ctx context.Context)  {
//				panic("mock out the ReattributeUsersOrders method")
//			},
//			ReleaseUsersLockFunc: func() error {
//				panic("mock out the ReleaseUsersLock method")
//			},
//			ReplayFunc: func(ctx context.Context)  {
//				panic("mock out the Replay method")
//			},
//			RepoFunc: func() repository.Repository {
//				panic("mock out the Repo method")
//			},
//			SetErrorFunc: func(key string, err string, retryable bool)  {
//				panic("mock out the SetError method")
//			},
//			StepAttributionFunc: func(ctx context.Context)  {
//				panic("mock out the StepAttribution method")
//			},
//			StepHookFinalizeFunc: func(ctx context.Context)  {
//				panic("mock out the StepHookFinalize method")
//			},
//			StepPendingFunc: func(ctx context.Context)  {
//				panic("mock out the StepPending method")
//			},
//			StepPersistDatalogFunc: func(ctx context.Context)  {
//				panic("mock out the StepPersistDatalog method")
//			},
//			StepSegmentationFunc: func(ctx context.Context)  {
//				panic("mock out the StepSegmentation method")
//			},
//			StepUpsertItemFunc: func(ctx context.Context)  {
//				panic("mock out the StepUpsertItem method")
//			},
//			StepWorkflowsFunc: func(ctx context.Context)  {
//				panic("mock out the StepWorkflows method")
//			},
//			UpsertAppItemFunc: func(ctx context.Context, isChild bool, tx *sql.Tx) error {
//				panic("mock out the UpsertAppItem method")
//			},
//			UpsertCartFunc: func(ctx context.Context, isChild bool, tx *sql.Tx) error {
//				panic("mock out the UpsertCart method")
//			},
//			UpsertCustomEventFunc: func(ctx context.Context, isChild bool, tx *sql.Tx) error {
//				panic("mock out the UpsertCustomEvent method")
//			},
//			UpsertDeviceFunc: func(ctx context.Context, isChild bool, tx *sql.Tx) error {
//				panic("mock out the UpsertDevice method")
//			},
//			UpsertOrderFunc: func(ctx context.Context, isChild bool, tx *sql.Tx) error {
//				panic("mock out the UpsertOrder method")
//			},
//			UpsertPageviewFunc: func(ctx context.Context, isChild bool, tx *sql.Tx) error {
//				panic("mock out the UpsertPageview method")
//			},
//			UpsertPostviewFunc: func(ctx context.Context, isChild bool, tx *sql.Tx) error {
//				panic("mock out the UpsertPostview method")
//			},
//			UpsertSessionFunc: func(ctx context.Context, isChild bool, tx *sql.Tx) error {
//				panic("mock out the UpsertSession method")
//			},
//			UpsertUserFunc: func(ctx context.Context, isChild bool, tx *sql.Tx) error {
//				panic("mock out the UpsertUser method")
//			},
//			UpsertUserAliasFunc: func(ctx context.Context, isChild bool, tx *sql.Tx) error {
//				panic("mock out the UpsertUserAlias method")
//			},
//		}
//
//		// use mockedIDataLogPipeline in code that requires IDataLogPipeline
//		// and then make assertions.
//
//	}
type IDataLogPipelineMock struct {
	// AddDataLogGeneratedFunc mocks the AddDataLogGenerated method.
	AddDataLogGeneratedFunc func(dataLog *entity.DataLog)

	// AttributeOrderFunc mocks the AttributeOrder method.
	AttributeOrderFunc func(ctx context.Context, order *entity.Order, orderSessions []*entity.Session, orderPostviews []*entity.Postview, previousOrders []*entity.Order, devices []*entity.Device, tx *sql.Tx)

	// CfgFunc mocks the Cfg method.
	CfgFunc func() *entity.Config

	// ComputeSegmentsForGivenUsersFunc mocks the ComputeSegmentsForGivenUsers method.
	ComputeSegmentsForGivenUsersFunc func(ctx context.Context)

	// CreateDataLogFromQueueFunc mocks the CreateDataLogFromQueue method.
	CreateDataLogFromQueueFunc func(ctx context.Context)

	// DataLogEnqueueFunc mocks the DataLogEnqueue method.
	DataLogEnqueueFunc func(ctx context.Context, replayID *string, origin int, originID string, workspaceID string, jsonItems []string, isSync bool)

	// EnsureUsersLockFunc mocks the EnsureUsersLock method.
	EnsureUsersLockFunc func(ctx context.Context) error

	// ExecuteFunc mocks the Execute method.
	ExecuteFunc func(ctx context.Context)

	// ExtractAndValidateItemFunc mocks the ExtractAndValidateItem method.
	ExtractAndValidateItemFunc func()

	// ExtractAppItemFromDataLogItemFunc mocks the ExtractAppItemFromDataLogItem method.
	ExtractAppItemFromDataLogItemFunc func()

	// ExtractCartFromDataLogItemFunc mocks the ExtractCartFromDataLogItem method.
	ExtractCartFromDataLogItemFunc func()

	// ExtractCustomEventFromDataLogItemFunc mocks the ExtractCustomEventFromDataLogItem method.
	ExtractCustomEventFromDataLogItemFunc func()

	// ExtractDeviceFromDataLogItemFunc mocks the ExtractDeviceFromDataLogItem method.
	ExtractDeviceFromDataLogItemFunc func(userID string)

	// ExtractExtraColumnsFromItemFunc mocks the ExtractExtraColumnsFromItem method.
	ExtractExtraColumnsFromItemFunc func(kind string)

	// ExtractOrderFromDataLogItemFunc mocks the ExtractOrderFromDataLogItem method.
	ExtractOrderFromDataLogItemFunc func()

	// ExtractPageviewFromDataLogItemFunc mocks the ExtractPageviewFromDataLogItem method.
	ExtractPageviewFromDataLogItemFunc func()

	// ExtractPostviewFromDataLogItemFunc mocks the ExtractPostviewFromDataLogItem method.
	ExtractPostviewFromDataLogItemFunc func()

	// ExtractSessionFromDataLogItemFunc mocks the ExtractSessionFromDataLogItem method.
	ExtractSessionFromDataLogItemFunc func(isMandatory bool)

	// ExtractUserAliasFromDataLogItemFunc mocks the ExtractUserAliasFromDataLogItem method.
	ExtractUserAliasFromDataLogItemFunc func()

	// ExtractUserFromDataLogItemFunc mocks the ExtractUserFromDataLogItem method.
	ExtractUserFromDataLogItemFunc func()

	// GetDataLogFunc mocks the GetDataLog method.
	GetDataLogFunc func() *entity.DataLog

	// GetDataLogsGeneratedFunc mocks the GetDataLogsGenerated method.
	GetDataLogsGeneratedFunc func() []*entity.DataLog

	// GetQueueResultFunc mocks the GetQueueResult method.
	GetQueueResultFunc func() *common.DataLogInQueueResult

	// GetUserIDsFunc mocks the GetUserIDs method.
	GetUserIDsFunc func() []string

	// GetWorkspaceFunc mocks the GetWorkspace method.
	GetWorkspaceFunc func() *entity.Workspace

	// HasErrorFunc mocks the HasError method.
	HasErrorFunc func() bool

	// InitDataLogFunc mocks the InitDataLog method.
	InitDataLogFunc func(ctx context.Context)

	// InsertChildDataLogFunc mocks the InsertChildDataLog method.
	InsertChildDataLogFunc func(ctx context.Context, kind string, action string, userID string, itemID string, itemExternalID string, updatedFields entity.UpdatedFields, eventAt time.Time, tx *sql.Tx) error

	// LoadFxRatesFunc mocks the LoadFxRates method.
	LoadFxRatesFunc func(ctx context.Context) error

	// NetFunc mocks the Net method.
	NetFunc func() httpClient.HTTPClient

	// ParseUserAgentFunc mocks the ParseUserAgent method.
	ParseUserAgentFunc func(userAgent string) (*entity.UserAgentResult, error)

	// ProcessNextStepFunc mocks the ProcessNextStep method.
	ProcessNextStepFunc func(ctx context.Context)

	// ReattributeUsersOrdersFunc mocks the ReattributeUsersOrders method.
	ReattributeUsersOrdersFunc func(ctx context.Context)

	// ReleaseUsersLockFunc mocks the ReleaseUsersLock method.
	ReleaseUsersLockFunc func() error

	// ReplayFunc mocks the Replay method.
	ReplayFunc func(ctx context.Context)

	// RepoFunc mocks the Repo method.
	RepoFunc func() repository.Repository

	// SetErrorFunc mocks the SetError method.
	SetErrorFunc func(key string, err string, retryable bool)

	// StepAttributionFunc mocks the StepAttribution method.
	StepAttributionFunc func(ctx context.Context)

	// StepHookFinalizeFunc mocks the StepHookFinalize method.
	StepHookFinalizeFunc func(ctx context.Context)

	// StepPendingFunc mocks the StepPending method.
	StepPendingFunc func(ctx context.Context)

	// StepPersistDatalogFunc mocks the StepPersistDatalog method.
	StepPersistDatalogFunc func(ctx context.Context)

	// StepSegmentationFunc mocks the StepSegmentation method.
	StepSegmentationFunc func(ctx context.Context)

	// StepUpsertItemFunc mocks the StepUpsertItem method.
	StepUpsertItemFunc func(ctx context.Context)

	// StepWorkflowsFunc mocks the StepWorkflows method.
	StepWorkflowsFunc func(ctx context.Context)

	// UpsertAppItemFunc mocks the UpsertAppItem method.
	UpsertAppItemFunc func(ctx context.Context, isChild bool, tx *sql.Tx) error

	// UpsertCartFunc mocks the UpsertCart method.
	UpsertCartFunc func(ctx context.Context, isChild bool, tx *sql.Tx) error

	// UpsertCustomEventFunc mocks the UpsertCustomEvent method.
	UpsertCustomEventFunc func(ctx context.Context, isChild bool, tx *sql.Tx) error

	// UpsertDeviceFunc mocks the UpsertDevice method.
	UpsertDeviceFunc func(ctx context.Context, isChild bool, tx *sql.Tx) error

	// UpsertOrderFunc mocks the UpsertOrder method.
	UpsertOrderFunc func(ctx context.Context, isChild bool, tx *sql.Tx) error

	// UpsertPageviewFunc mocks the UpsertPageview method.
	UpsertPageviewFunc func(ctx context.Context, isChild bool, tx *sql.Tx) error

	// UpsertPostviewFunc mocks the UpsertPostview method.
	UpsertPostviewFunc func(ctx context.Context, isChild bool, tx *sql.Tx) error

	// UpsertSessionFunc mocks the UpsertSession method.
	UpsertSessionFunc func(ctx context.Context, isChild bool, tx *sql.Tx) error

	// UpsertUserFunc mocks the UpsertUser method.
	UpsertUserFunc func(ctx context.Context, isChild bool, tx *sql.Tx) error

	// UpsertUserAliasFunc mocks the UpsertUserAlias method.
	UpsertUserAliasFunc func(ctx context.Context, isChild bool, tx *sql.Tx) error

	// calls tracks calls to the methods.
	calls struct {
		// AddDataLogGenerated holds details about calls to the AddDataLogGenerated method.
		AddDataLogGenerated []struct {
			// DataLog is the dataLog argument value.
			DataLog *entity.DataLog
		}
		// AttributeOrder holds details about calls to the AttributeOrder method.
		AttributeOrder []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Order is the order argument value.
			Order *entity.Order
			// OrderSessions is the orderSessions argument value.
			OrderSessions []*entity.Session
			// OrderPostviews is the orderPostviews argument value.
			OrderPostviews []*entity.Postview
			// PreviousOrders is the previousOrders argument value.
			PreviousOrders []*entity.Order
			// Devices is the devices argument value.
			Devices []*entity.Device
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// Cfg holds details about calls to the Cfg method.
		Cfg []struct {
		}
		// ComputeSegmentsForGivenUsers holds details about calls to the ComputeSegmentsForGivenUsers method.
		ComputeSegmentsForGivenUsers []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// CreateDataLogFromQueue holds details about calls to the CreateDataLogFromQueue method.
		CreateDataLogFromQueue []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// DataLogEnqueue holds details about calls to the DataLogEnqueue method.
		DataLogEnqueue []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ReplayID is the replayID argument value.
			ReplayID *string
			// Origin is the origin argument value.
			Origin int
			// OriginID is the originID argument value.
			OriginID string
			// WorkspaceID is the workspaceID argument value.
			WorkspaceID string
			// JsonItems is the jsonItems argument value.
			JsonItems []string
			// IsSync is the isSync argument value.
			IsSync bool
		}
		// EnsureUsersLock holds details about calls to the EnsureUsersLock method.
		EnsureUsersLock []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// Execute holds details about calls to the Execute method.
		Execute []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ExtractAndValidateItem holds details about calls to the ExtractAndValidateItem method.
		ExtractAndValidateItem []struct {
		}
		// ExtractAppItemFromDataLogItem holds details about calls to the ExtractAppItemFromDataLogItem method.
		ExtractAppItemFromDataLogItem []struct {
		}
		// ExtractCartFromDataLogItem holds details about calls to the ExtractCartFromDataLogItem method.
		ExtractCartFromDataLogItem []struct {
		}
		// ExtractCustomEventFromDataLogItem holds details about calls to the ExtractCustomEventFromDataLogItem method.
		ExtractCustomEventFromDataLogItem []struct {
		}
		// ExtractDeviceFromDataLogItem holds details about calls to the ExtractDeviceFromDataLogItem method.
		ExtractDeviceFromDataLogItem []struct {
			// UserID is the userID argument value.
			UserID string
		}
		// ExtractExtraColumnsFromItem holds details about calls to the ExtractExtraColumnsFromItem method.
		ExtractExtraColumnsFromItem []struct {
			// Kind is the kind argument value.
			Kind string
		}
		// ExtractOrderFromDataLogItem holds details about calls to the ExtractOrderFromDataLogItem method.
		ExtractOrderFromDataLogItem []struct {
		}
		// ExtractPageviewFromDataLogItem holds details about calls to the ExtractPageviewFromDataLogItem method.
		ExtractPageviewFromDataLogItem []struct {
		}
		// ExtractPostviewFromDataLogItem holds details about calls to the ExtractPostviewFromDataLogItem method.
		ExtractPostviewFromDataLogItem []struct {
		}
		// ExtractSessionFromDataLogItem holds details about calls to the ExtractSessionFromDataLogItem method.
		ExtractSessionFromDataLogItem []struct {
			// IsMandatory is the isMandatory argument value.
			IsMandatory bool
		}
		// ExtractUserAliasFromDataLogItem holds details about calls to the ExtractUserAliasFromDataLogItem method.
		ExtractUserAliasFromDataLogItem []struct {
		}
		// ExtractUserFromDataLogItem holds details about calls to the ExtractUserFromDataLogItem method.
		ExtractUserFromDataLogItem []struct {
		}
		// GetDataLog holds details about calls to the GetDataLog method.
		GetDataLog []struct {
		}
		// GetDataLogsGenerated holds details about calls to the GetDataLogsGenerated method.
		GetDataLogsGenerated []struct {
		}
		// GetQueueResult holds details about calls to the GetQueueResult method.
		GetQueueResult []struct {
		}
		// GetUserIDs holds details about calls to the GetUserIDs method.
		GetUserIDs []struct {
		}
		// GetWorkspace holds details about calls to the GetWorkspace method.
		GetWorkspace []struct {
		}
		// HasError holds details about calls to the HasError method.
		HasError []struct {
		}
		// InitDataLog holds details about calls to the InitDataLog method.
		InitDataLog []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// InsertChildDataLog holds details about calls to the InsertChildDataLog method.
		InsertChildDataLog []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Kind is the kind argument value.
			Kind string
			// Action is the action argument value.
			Action string
			// UserID is the userID argument value.
			UserID string
			// ItemID is the itemID argument value.
			ItemID string
			// ItemExternalID is the itemExternalID argument value.
			ItemExternalID string
			// UpdatedFields is the updatedFields argument value.
			UpdatedFields entity.UpdatedFields
			// EventAt is the eventAt argument value.
			EventAt time.Time
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// LoadFxRates holds details about calls to the LoadFxRates method.
		LoadFxRates []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// Net holds details about calls to the Net method.
		Net []struct {
		}
		// ParseUserAgent holds details about calls to the ParseUserAgent method.
		ParseUserAgent []struct {
			// UserAgent is the userAgent argument value.
			UserAgent string
		}
		// ProcessNextStep holds details about calls to the ProcessNextStep method.
		ProcessNextStep []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ReattributeUsersOrders holds details about calls to the ReattributeUsersOrders method.
		ReattributeUsersOrders []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ReleaseUsersLock holds details about calls to the ReleaseUsersLock method.
		ReleaseUsersLock []struct {
		}
		// Replay holds details about calls to the Replay method.
		Replay []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// Repo holds details about calls to the Repo method.
		Repo []struct {
		}
		// SetError holds details about calls to the SetError method.
		SetError []struct {
			// Key is the key argument value.
			Key string
			// Err is the err argument value.
			Err string
			// Retryable is the retryable argument value.
			Retryable bool
		}
		// StepAttribution holds details about calls to the StepAttribution method.
		StepAttribution []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// StepHookFinalize holds details about calls to the StepHookFinalize method.
		StepHookFinalize []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// StepPending holds details about calls to the StepPending method.
		StepPending []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// StepPersistDatalog holds details about calls to the StepPersistDatalog method.
		StepPersistDatalog []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// StepSegmentation holds details about calls to the StepSegmentation method.
		StepSegmentation []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// StepUpsertItem holds details about calls to the StepUpsertItem method.
		StepUpsertItem []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// StepWorkflows holds details about calls to the StepWorkflows method.
		StepWorkflows []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// UpsertAppItem holds details about calls to the UpsertAppItem method.
		UpsertAppItem []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// IsChild is the isChild argument value.
			IsChild bool
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// UpsertCart holds details about calls to the UpsertCart method.
		UpsertCart []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// IsChild is the isChild argument value.
			IsChild bool
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// UpsertCustomEvent holds details about calls to the UpsertCustomEvent method.
		UpsertCustomEvent []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// IsChild is the isChild argument value.
			IsChild bool
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// UpsertDevice holds details about calls to the UpsertDevice method.
		UpsertDevice []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// IsChild is the isChild argument value.
			IsChild bool
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// UpsertOrder holds details about calls to the UpsertOrder method.
		UpsertOrder []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// IsChild is the isChild argument value.
			IsChild bool
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// UpsertPageview holds details about calls to the UpsertPageview method.
		UpsertPageview []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// IsChild is the isChild argument value.
			IsChild bool
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// UpsertPostview holds details about calls to the UpsertPostview method.
		UpsertPostview []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// IsChild is the isChild argument value.
			IsChild bool
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// UpsertSession holds details about calls to the UpsertSession method.
		UpsertSession []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// IsChild is the isChild argument value.
			IsChild bool
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// UpsertUser holds details about calls to the UpsertUser method.
		UpsertUser []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// IsChild is the isChild argument value.
			IsChild bool
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
		// UpsertUserAlias holds details about calls to the UpsertUserAlias method.
		UpsertUserAlias []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// IsChild is the isChild argument value.
			IsChild bool
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
	}
	lockAddDataLogGenerated               sync.RWMutex
	lockAttributeOrder                    sync.RWMutex
	lockCfg                               sync.RWMutex
	lockComputeSegmentsForGivenUsers      sync.RWMutex
	lockCreateDataLogFromQueue            sync.RWMutex
	lockDataLogEnqueue                    sync.RWMutex
	lockEnsureUsersLock                   sync.RWMutex
	lockExecute                           sync.RWMutex
	lockExtractAndValidateItem            sync.RWMutex
	lockExtractAppItemFromDataLogItem     sync.RWMutex
	lockExtractCartFromDataLogItem        sync.RWMutex
	lockExtractCustomEventFromDataLogItem sync.RWMutex
	lockExtractDeviceFromDataLogItem      sync.RWMutex
	lockExtractExtraColumnsFromItem       sync.RWMutex
	lockExtractOrderFromDataLogItem       sync.RWMutex
	lockExtractPageviewFromDataLogItem    sync.RWMutex
	lockExtractPostviewFromDataLogItem    sync.RWMutex
	lockExtractSessionFromDataLogItem     sync.RWMutex
	lockExtractUserAliasFromDataLogItem   sync.RWMutex
	lockExtractUserFromDataLogItem        sync.RWMutex
	lockGetDataLog                        sync.RWMutex
	lockGetDataLogsGenerated              sync.RWMutex
	lockGetQueueResult                    sync.RWMutex
	lockGetUserIDs                        sync.RWMutex
	lockGetWorkspace                      sync.RWMutex
	lockHasError                          sync.RWMutex
	lockInitDataLog                       sync.RWMutex
	lockInsertChildDataLog                sync.RWMutex
	lockLoadFxRates                       sync.RWMutex
	lockNet                               sync.RWMutex
	lockParseUserAgent                    sync.RWMutex
	lockProcessNextStep                   sync.RWMutex
	lockReattributeUsersOrders            sync.RWMutex
	lockReleaseUsersLock                  sync.RWMutex
	lockReplay                            sync.RWMutex
	lockRepo                              sync.RWMutex
	lockSetError                          sync.RWMutex
	lockStepAttribution                   sync.RWMutex
	lockStepHookFinalize                  sync.RWMutex
	lockStepPending                       sync.RWMutex
	lockStepPersistDatalog                sync.RWMutex
	lockStepSegmentation                  sync.RWMutex
	lockStepUpsertItem                    sync.RWMutex
	lockStepWorkflows                     sync.RWMutex
	lockUpsertAppItem                     sync.RWMutex
	lockUpsertCart                        sync.RWMutex
	lockUpsertCustomEvent                 sync.RWMutex
	lockUpsertDevice                      sync.RWMutex
	lockUpsertOrder                       sync.RWMutex
	lockUpsertPageview                    sync.RWMutex
	lockUpsertPostview                    sync.RWMutex
	lockUpsertSession                     sync.RWMutex
	lockUpsertUser                        sync.RWMutex
	lockUpsertUserAlias                   sync.RWMutex
}

// AddDataLogGenerated calls AddDataLogGeneratedFunc.
func (mock *IDataLogPipelineMock) AddDataLogGenerated(dataLog *entity.DataLog) {
	if mock.AddDataLogGeneratedFunc == nil {
		panic("IDataLogPipelineMock.AddDataLogGeneratedFunc: method is nil but IDataLogPipeline.AddDataLogGenerated was just called")
	}
	callInfo := struct {
		DataLog *entity.DataLog
	}{
		DataLog: dataLog,
	}
	mock.lockAddDataLogGenerated.Lock()
	mock.calls.AddDataLogGenerated = append(mock.calls.AddDataLogGenerated, callInfo)
	mock.lockAddDataLogGenerated.Unlock()
	mock.AddDataLogGeneratedFunc(dataLog)
}

// AddDataLogGeneratedCalls gets all the calls that were made to AddDataLogGenerated.
// Check the length with:
//
//	len(mockedIDataLogPipeline.AddDataLogGeneratedCalls())
func (mock *IDataLogPipelineMock) AddDataLogGeneratedCalls() []struct {
	DataLog *entity.DataLog
} {
	var calls []struct {
		DataLog *entity.DataLog
	}
	mock.lockAddDataLogGenerated.RLock()
	calls = mock.calls.AddDataLogGenerated
	mock.lockAddDataLogGenerated.RUnlock()
	return calls
}

// AttributeOrder calls AttributeOrderFunc.
func (mock *IDataLogPipelineMock) AttributeOrder(ctx context.Context, order *entity.Order, orderSessions []*entity.Session, orderPostviews []*entity.Postview, previousOrders []*entity.Order, devices []*entity.Device, tx *sql.Tx) {
	if mock.AttributeOrderFunc == nil {
		panic("IDataLogPipelineMock.AttributeOrderFunc: method is nil but IDataLogPipeline.AttributeOrder was just called")
	}
	callInfo := struct {
		Ctx            context.Context
		Order          *entity.Order
		OrderSessions  []*entity.Session
		OrderPostviews []*entity.Postview
		PreviousOrders []*entity.Order
		Devices        []*entity.Device
		Tx             *sql.Tx
	}{
		Ctx:            ctx,
		Order:          order,
		OrderSessions:  orderSessions,
		OrderPostviews: orderPostviews,
		PreviousOrders: previousOrders,
		Devices:        devices,
		Tx:             tx,
	}
	mock.lockAttributeOrder.Lock()
	mock.calls.AttributeOrder = append(mock.calls.AttributeOrder, callInfo)
	mock.lockAttributeOrder.Unlock()
	mock.AttributeOrderFunc(ctx, order, orderSessions, orderPostviews, previousOrders, devices, tx)
}

// AttributeOrderCalls gets all the calls that were made to AttributeOrder.
// Check the length with:
//
//	len(mockedIDataLogPipeline.AttributeOrderCalls())
func (mock *IDataLogPipelineMock) AttributeOrderCalls() []struct {
	Ctx            context.Context
	Order          *entity.Order
	OrderSessions  []*entity.Session
	OrderPostviews []*entity.Postview
	PreviousOrders []*entity.Order
	Devices        []*entity.Device
	Tx             *sql.Tx
} {
	var calls []struct {
		Ctx            context.Context
		Order          *entity.Order
		OrderSessions  []*entity.Session
		OrderPostviews []*entity.Postview
		PreviousOrders []*entity.Order
		Devices        []*entity.Device
		Tx             *sql.Tx
	}
	mock.lockAttributeOrder.RLock()
	calls = mock.calls.AttributeOrder
	mock.lockAttributeOrder.RUnlock()
	return calls
}

// Cfg calls CfgFunc.
func (mock *IDataLogPipelineMock) Cfg() *entity.Config {
	if mock.CfgFunc == nil {
		panic("IDataLogPipelineMock.CfgFunc: method is nil but IDataLogPipeline.Cfg was just called")
	}
	callInfo := struct {
	}{}
	mock.lockCfg.Lock()
	mock.calls.Cfg = append(mock.calls.Cfg, callInfo)
	mock.lockCfg.Unlock()
	return mock.CfgFunc()
}

// CfgCalls gets all the calls that were made to Cfg.
// Check the length with:
//
//	len(mockedIDataLogPipeline.CfgCalls())
func (mock *IDataLogPipelineMock) CfgCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockCfg.RLock()
	calls = mock.calls.Cfg
	mock.lockCfg.RUnlock()
	return calls
}

// ComputeSegmentsForGivenUsers calls ComputeSegmentsForGivenUsersFunc.
func (mock *IDataLogPipelineMock) ComputeSegmentsForGivenUsers(ctx context.Context) {
	if mock.ComputeSegmentsForGivenUsersFunc == nil {
		panic("IDataLogPipelineMock.ComputeSegmentsForGivenUsersFunc: method is nil but IDataLogPipeline.ComputeSegmentsForGivenUsers was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockComputeSegmentsForGivenUsers.Lock()
	mock.calls.ComputeSegmentsForGivenUsers = append(mock.calls.ComputeSegmentsForGivenUsers, callInfo)
	mock.lockComputeSegmentsForGivenUsers.Unlock()
	mock.ComputeSegmentsForGivenUsersFunc(ctx)
}

// ComputeSegmentsForGivenUsersCalls gets all the calls that were made to ComputeSegmentsForGivenUsers.
// Check the length with:
//
//	len(mockedIDataLogPipeline.ComputeSegmentsForGivenUsersCalls())
func (mock *IDataLogPipelineMock) ComputeSegmentsForGivenUsersCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockComputeSegmentsForGivenUsers.RLock()
	calls = mock.calls.ComputeSegmentsForGivenUsers
	mock.lockComputeSegmentsForGivenUsers.RUnlock()
	return calls
}

// CreateDataLogFromQueue calls CreateDataLogFromQueueFunc.
func (mock *IDataLogPipelineMock) CreateDataLogFromQueue(ctx context.Context) {
	if mock.CreateDataLogFromQueueFunc == nil {
		panic("IDataLogPipelineMock.CreateDataLogFromQueueFunc: method is nil but IDataLogPipeline.CreateDataLogFromQueue was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockCreateDataLogFromQueue.Lock()
	mock.calls.CreateDataLogFromQueue = append(mock.calls.CreateDataLogFromQueue, callInfo)
	mock.lockCreateDataLogFromQueue.Unlock()
	mock.CreateDataLogFromQueueFunc(ctx)
}

// CreateDataLogFromQueueCalls gets all the calls that were made to CreateDataLogFromQueue.
// Check the length with:
//
//	len(mockedIDataLogPipeline.CreateDataLogFromQueueCalls())
func (mock *IDataLogPipelineMock) CreateDataLogFromQueueCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockCreateDataLogFromQueue.RLock()
	calls = mock.calls.CreateDataLogFromQueue
	mock.lockCreateDataLogFromQueue.RUnlock()
	return calls
}

// DataLogEnqueue calls DataLogEnqueueFunc.
func (mock *IDataLogPipelineMock) DataLogEnqueue(ctx context.Context, replayID *string, origin int, originID string, workspaceID string, jsonItems []string, isSync bool) {
	if mock.DataLogEnqueueFunc == nil {
		panic("IDataLogPipelineMock.DataLogEnqueueFunc: method is nil but IDataLogPipeline.DataLogEnqueue was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		ReplayID    *string
		Origin      int
		OriginID    string
		WorkspaceID string
		JsonItems   []string
		IsSync      bool
	}{
		Ctx:         ctx,
		ReplayID:    replayID,
		Origin:      origin,
		OriginID:    originID,
		WorkspaceID: workspaceID,
		JsonItems:   jsonItems,
		IsSync:      isSync,
	}
	mock.lockDataLogEnqueue.Lock()
	mock.calls.DataLogEnqueue = append(mock.calls.DataLogEnqueue, callInfo)
	mock.lockDataLogEnqueue.Unlock()
	mock.DataLogEnqueueFunc(ctx, replayID, origin, originID, workspaceID, jsonItems, isSync)
}

// DataLogEnqueueCalls gets all the calls that were made to DataLogEnqueue.
// Check the length with:
//
//	len(mockedIDataLogPipeline.DataLogEnqueueCalls())
func (mock *IDataLogPipelineMock) DataLogEnqueueCalls() []struct {
	Ctx         context.Context
	ReplayID    *string
	Origin      int
	OriginID    string
	WorkspaceID string
	JsonItems   []string
	IsSync      bool
} {
	var calls []struct {
		Ctx         context.Context
		ReplayID    *string
		Origin      int
		OriginID    string
		WorkspaceID string
		JsonItems   []string
		IsSync      bool
	}
	mock.lockDataLogEnqueue.RLock()
	calls = mock.calls.DataLogEnqueue
	mock.lockDataLogEnqueue.RUnlock()
	return calls
}

// EnsureUsersLock calls EnsureUsersLockFunc.
func (mock *IDataLogPipelineMock) EnsureUsersLock(ctx context.Context) error {
	if mock.EnsureUsersLockFunc == nil {
		panic("IDataLogPipelineMock.EnsureUsersLockFunc: method is nil but IDataLogPipeline.EnsureUsersLock was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockEnsureUsersLock.Lock()
	mock.calls.EnsureUsersLock = append(mock.calls.EnsureUsersLock, callInfo)
	mock.lockEnsureUsersLock.Unlock()
	return mock.EnsureUsersLockFunc(ctx)
}

// EnsureUsersLockCalls gets all the calls that were made to EnsureUsersLock.
// Check the length with:
//
//	len(mockedIDataLogPipeline.EnsureUsersLockCalls())
func (mock *IDataLogPipelineMock) EnsureUsersLockCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockEnsureUsersLock.RLock()
	calls = mock.calls.EnsureUsersLock
	mock.lockEnsureUsersLock.RUnlock()
	return calls
}

// Execute calls ExecuteFunc.
func (mock *IDataLogPipelineMock) Execute(ctx context.Context) {
	if mock.ExecuteFunc == nil {
		panic("IDataLogPipelineMock.ExecuteFunc: method is nil but IDataLogPipeline.Execute was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockExecute.Lock()
	mock.calls.Execute = append(mock.calls.Execute, callInfo)
	mock.lockExecute.Unlock()
	mock.ExecuteFunc(ctx)
}

// ExecuteCalls gets all the calls that were made to Execute.
// Check the length with:
//
//	len(mockedIDataLogPipeline.ExecuteCalls())
func (mock *IDataLogPipelineMock) ExecuteCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockExecute.RLock()
	calls = mock.calls.Execute
	mock.lockExecute.RUnlock()
	return calls
}

// ExtractAndValidateItem calls ExtractAndValidateItemFunc.
func (mock *IDataLogPipelineMock) ExtractAndValidateItem() {
	if mock.ExtractAndValidateItemFunc == nil {
		panic("IDataLogPipelineMock.ExtractAndValidateItemFunc: method is nil but IDataLogPipeline.ExtractAndValidateItem was just called")
	}
	callInfo := struct {
	}{}
	mock.lockExtractAndValidateItem.Lock()
	mock.calls.ExtractAndValidateItem = append(mock.calls.ExtractAndValidateItem, callInfo)
	mock.lockExtractAndValidateItem.Unlock()
	mock.ExtractAndValidateItemFunc()
}

// ExtractAndValidateItemCalls gets all the calls that were made to ExtractAndValidateItem.
// Check the length with:
//
//	len(mockedIDataLogPipeline.ExtractAndValidateItemCalls())
func (mock *IDataLogPipelineMock) ExtractAndValidateItemCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockExtractAndValidateItem.RLock()
	calls = mock.calls.ExtractAndValidateItem
	mock.lockExtractAndValidateItem.RUnlock()
	return calls
}

// ExtractAppItemFromDataLogItem calls ExtractAppItemFromDataLogItemFunc.
func (mock *IDataLogPipelineMock) ExtractAppItemFromDataLogItem() {
	if mock.ExtractAppItemFromDataLogItemFunc == nil {
		panic("IDataLogPipelineMock.ExtractAppItemFromDataLogItemFunc: method is nil but IDataLogPipeline.ExtractAppItemFromDataLogItem was just called")
	}
	callInfo := struct {
	}{}
	mock.lockExtractAppItemFromDataLogItem.Lock()
	mock.calls.ExtractAppItemFromDataLogItem = append(mock.calls.ExtractAppItemFromDataLogItem, callInfo)
	mock.lockExtractAppItemFromDataLogItem.Unlock()
	mock.ExtractAppItemFromDataLogItemFunc()
}

// ExtractAppItemFromDataLogItemCalls gets all the calls that were made to ExtractAppItemFromDataLogItem.
// Check the length with:
//
//	len(mockedIDataLogPipeline.ExtractAppItemFromDataLogItemCalls())
func (mock *IDataLogPipelineMock) ExtractAppItemFromDataLogItemCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockExtractAppItemFromDataLogItem.RLock()
	calls = mock.calls.ExtractAppItemFromDataLogItem
	mock.lockExtractAppItemFromDataLogItem.RUnlock()
	return calls
}

// ExtractCartFromDataLogItem calls ExtractCartFromDataLogItemFunc.
func (mock *IDataLogPipelineMock) ExtractCartFromDataLogItem() {
	if mock.ExtractCartFromDataLogItemFunc == nil {
		panic("IDataLogPipelineMock.ExtractCartFromDataLogItemFunc: method is nil but IDataLogPipeline.ExtractCartFromDataLogItem was just called")
	}
	callInfo := struct {
	}{}
	mock.lockExtractCartFromDataLogItem.Lock()
	mock.calls.ExtractCartFromDataLogItem = append(mock.calls.ExtractCartFromDataLogItem, callInfo)
	mock.lockExtractCartFromDataLogItem.Unlock()
	mock.ExtractCartFromDataLogItemFunc()
}

// ExtractCartFromDataLogItemCalls gets all the calls that were made to ExtractCartFromDataLogItem.
// Check the length with:
//
//	len(mockedIDataLogPipeline.ExtractCartFromDataLogItemCalls())
func (mock *IDataLogPipelineMock) ExtractCartFromDataLogItemCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockExtractCartFromDataLogItem.RLock()
	calls = mock.calls.ExtractCartFromDataLogItem
	mock.lockExtractCartFromDataLogItem.RUnlock()
	return calls
}

// ExtractCustomEventFromDataLogItem calls ExtractCustomEventFromDataLogItemFunc.
func (mock *IDataLogPipelineMock) ExtractCustomEventFromDataLogItem() {
	if mock.ExtractCustomEventFromDataLogItemFunc == nil {
		panic("IDataLogPipelineMock.ExtractCustomEventFromDataLogItemFunc: method is nil but IDataLogPipeline.ExtractCustomEventFromDataLogItem was just called")
	}
	callInfo := struct {
	}{}
	mock.lockExtractCustomEventFromDataLogItem.Lock()
	mock.calls.ExtractCustomEventFromDataLogItem = append(mock.calls.ExtractCustomEventFromDataLogItem, callInfo)
	mock.lockExtractCustomEventFromDataLogItem.Unlock()
	mock.ExtractCustomEventFromDataLogItemFunc()
}

// ExtractCustomEventFromDataLogItemCalls gets all the calls that were made to ExtractCustomEventFromDataLogItem.
// Check the length with:
//
//	len(mockedIDataLogPipeline.ExtractCustomEventFromDataLogItemCalls())
func (mock *IDataLogPipelineMock) ExtractCustomEventFromDataLogItemCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockExtractCustomEventFromDataLogItem.RLock()
	calls = mock.calls.ExtractCustomEventFromDataLogItem
	mock.lockExtractCustomEventFromDataLogItem.RUnlock()
	return calls
}

// ExtractDeviceFromDataLogItem calls ExtractDeviceFromDataLogItemFunc.
func (mock *IDataLogPipelineMock) ExtractDeviceFromDataLogItem(userID string) {
	if mock.ExtractDeviceFromDataLogItemFunc == nil {
		panic("IDataLogPipelineMock.ExtractDeviceFromDataLogItemFunc: method is nil but IDataLogPipeline.ExtractDeviceFromDataLogItem was just called")
	}
	callInfo := struct {
		UserID string
	}{
		UserID: userID,
	}
	mock.lockExtractDeviceFromDataLogItem.Lock()
	mock.calls.ExtractDeviceFromDataLogItem = append(mock.calls.ExtractDeviceFromDataLogItem, callInfo)
	mock.lockExtractDeviceFromDataLogItem.Unlock()
	mock.ExtractDeviceFromDataLogItemFunc(userID)
}

// ExtractDeviceFromDataLogItemCalls gets all the calls that were made to ExtractDeviceFromDataLogItem.
// Check the length with:
//
//	len(mockedIDataLogPipeline.ExtractDeviceFromDataLogItemCalls())
func (mock *IDataLogPipelineMock) ExtractDeviceFromDataLogItemCalls() []struct {
	UserID string
} {
	var calls []struct {
		UserID string
	}
	mock.lockExtractDeviceFromDataLogItem.RLock()
	calls = mock.calls.ExtractDeviceFromDataLogItem
	mock.lockExtractDeviceFromDataLogItem.RUnlock()
	return calls
}

// ExtractExtraColumnsFromItem calls ExtractExtraColumnsFromItemFunc.
func (mock *IDataLogPipelineMock) ExtractExtraColumnsFromItem(kind string) {
	if mock.ExtractExtraColumnsFromItemFunc == nil {
		panic("IDataLogPipelineMock.ExtractExtraColumnsFromItemFunc: method is nil but IDataLogPipeline.ExtractExtraColumnsFromItem was just called")
	}
	callInfo := struct {
		Kind string
	}{
		Kind: kind,
	}
	mock.lockExtractExtraColumnsFromItem.Lock()
	mock.calls.ExtractExtraColumnsFromItem = append(mock.calls.ExtractExtraColumnsFromItem, callInfo)
	mock.lockExtractExtraColumnsFromItem.Unlock()
	mock.ExtractExtraColumnsFromItemFunc(kind)
}

// ExtractExtraColumnsFromItemCalls gets all the calls that were made to ExtractExtraColumnsFromItem.
// Check the length with:
//
//	len(mockedIDataLogPipeline.ExtractExtraColumnsFromItemCalls())
func (mock *IDataLogPipelineMock) ExtractExtraColumnsFromItemCalls() []struct {
	Kind string
} {
	var calls []struct {
		Kind string
	}
	mock.lockExtractExtraColumnsFromItem.RLock()
	calls = mock.calls.ExtractExtraColumnsFromItem
	mock.lockExtractExtraColumnsFromItem.RUnlock()
	return calls
}

// ExtractOrderFromDataLogItem calls ExtractOrderFromDataLogItemFunc.
func (mock *IDataLogPipelineMock) ExtractOrderFromDataLogItem() {
	if mock.ExtractOrderFromDataLogItemFunc == nil {
		panic("IDataLogPipelineMock.ExtractOrderFromDataLogItemFunc: method is nil but IDataLogPipeline.ExtractOrderFromDataLogItem was just called")
	}
	callInfo := struct {
	}{}
	mock.lockExtractOrderFromDataLogItem.Lock()
	mock.calls.ExtractOrderFromDataLogItem = append(mock.calls.ExtractOrderFromDataLogItem, callInfo)
	mock.lockExtractOrderFromDataLogItem.Unlock()
	mock.ExtractOrderFromDataLogItemFunc()
}

// ExtractOrderFromDataLogItemCalls gets all the calls that were made to ExtractOrderFromDataLogItem.
// Check the length with:
//
//	len(mockedIDataLogPipeline.ExtractOrderFromDataLogItemCalls())
func (mock *IDataLogPipelineMock) ExtractOrderFromDataLogItemCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockExtractOrderFromDataLogItem.RLock()
	calls = mock.calls.ExtractOrderFromDataLogItem
	mock.lockExtractOrderFromDataLogItem.RUnlock()
	return calls
}

// ExtractPageviewFromDataLogItem calls ExtractPageviewFromDataLogItemFunc.
func (mock *IDataLogPipelineMock) ExtractPageviewFromDataLogItem() {
	if mock.ExtractPageviewFromDataLogItemFunc == nil {
		panic("IDataLogPipelineMock.ExtractPageviewFromDataLogItemFunc: method is nil but IDataLogPipeline.ExtractPageviewFromDataLogItem was just called")
	}
	callInfo := struct {
	}{}
	mock.lockExtractPageviewFromDataLogItem.Lock()
	mock.calls.ExtractPageviewFromDataLogItem = append(mock.calls.ExtractPageviewFromDataLogItem, callInfo)
	mock.lockExtractPageviewFromDataLogItem.Unlock()
	mock.ExtractPageviewFromDataLogItemFunc()
}

// ExtractPageviewFromDataLogItemCalls gets all the calls that were made to ExtractPageviewFromDataLogItem.
// Check the length with:
//
//	len(mockedIDataLogPipeline.ExtractPageviewFromDataLogItemCalls())
func (mock *IDataLogPipelineMock) ExtractPageviewFromDataLogItemCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockExtractPageviewFromDataLogItem.RLock()
	calls = mock.calls.ExtractPageviewFromDataLogItem
	mock.lockExtractPageviewFromDataLogItem.RUnlock()
	return calls
}

// ExtractPostviewFromDataLogItem calls ExtractPostviewFromDataLogItemFunc.
func (mock *IDataLogPipelineMock) ExtractPostviewFromDataLogItem() {
	if mock.ExtractPostviewFromDataLogItemFunc == nil {
		panic("IDataLogPipelineMock.ExtractPostviewFromDataLogItemFunc: method is nil but IDataLogPipeline.ExtractPostviewFromDataLogItem was just called")
	}
	callInfo := struct {
	}{}
	mock.lockExtractPostviewFromDataLogItem.Lock()
	mock.calls.ExtractPostviewFromDataLogItem = append(mock.calls.ExtractPostviewFromDataLogItem, callInfo)
	mock.lockExtractPostviewFromDataLogItem.Unlock()
	mock.ExtractPostviewFromDataLogItemFunc()
}

// ExtractPostviewFromDataLogItemCalls gets all the calls that were made to ExtractPostviewFromDataLogItem.
// Check the length with:
//
//	len(mockedIDataLogPipeline.ExtractPostviewFromDataLogItemCalls())
func (mock *IDataLogPipelineMock) ExtractPostviewFromDataLogItemCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockExtractPostviewFromDataLogItem.RLock()
	calls = mock.calls.ExtractPostviewFromDataLogItem
	mock.lockExtractPostviewFromDataLogItem.RUnlock()
	return calls
}

// ExtractSessionFromDataLogItem calls ExtractSessionFromDataLogItemFunc.
func (mock *IDataLogPipelineMock) ExtractSessionFromDataLogItem(isMandatory bool) {
	if mock.ExtractSessionFromDataLogItemFunc == nil {
		panic("IDataLogPipelineMock.ExtractSessionFromDataLogItemFunc: method is nil but IDataLogPipeline.ExtractSessionFromDataLogItem was just called")
	}
	callInfo := struct {
		IsMandatory bool
	}{
		IsMandatory: isMandatory,
	}
	mock.lockExtractSessionFromDataLogItem.Lock()
	mock.calls.ExtractSessionFromDataLogItem = append(mock.calls.ExtractSessionFromDataLogItem, callInfo)
	mock.lockExtractSessionFromDataLogItem.Unlock()
	mock.ExtractSessionFromDataLogItemFunc(isMandatory)
}

// ExtractSessionFromDataLogItemCalls gets all the calls that were made to ExtractSessionFromDataLogItem.
// Check the length with:
//
//	len(mockedIDataLogPipeline.ExtractSessionFromDataLogItemCalls())
func (mock *IDataLogPipelineMock) ExtractSessionFromDataLogItemCalls() []struct {
	IsMandatory bool
} {
	var calls []struct {
		IsMandatory bool
	}
	mock.lockExtractSessionFromDataLogItem.RLock()
	calls = mock.calls.ExtractSessionFromDataLogItem
	mock.lockExtractSessionFromDataLogItem.RUnlock()
	return calls
}

// ExtractUserAliasFromDataLogItem calls ExtractUserAliasFromDataLogItemFunc.
func (mock *IDataLogPipelineMock) ExtractUserAliasFromDataLogItem() {
	if mock.ExtractUserAliasFromDataLogItemFunc == nil {
		panic("IDataLogPipelineMock.ExtractUserAliasFromDataLogItemFunc: method is nil but IDataLogPipeline.ExtractUserAliasFromDataLogItem was just called")
	}
	callInfo := struct {
	}{}
	mock.lockExtractUserAliasFromDataLogItem.Lock()
	mock.calls.ExtractUserAliasFromDataLogItem = append(mock.calls.ExtractUserAliasFromDataLogItem, callInfo)
	mock.lockExtractUserAliasFromDataLogItem.Unlock()
	mock.ExtractUserAliasFromDataLogItemFunc()
}

// ExtractUserAliasFromDataLogItemCalls gets all the calls that were made to ExtractUserAliasFromDataLogItem.
// Check the length with:
//
//	len(mockedIDataLogPipeline.ExtractUserAliasFromDataLogItemCalls())
func (mock *IDataLogPipelineMock) ExtractUserAliasFromDataLogItemCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockExtractUserAliasFromDataLogItem.RLock()
	calls = mock.calls.ExtractUserAliasFromDataLogItem
	mock.lockExtractUserAliasFromDataLogItem.RUnlock()
	return calls
}

// ExtractUserFromDataLogItem calls ExtractUserFromDataLogItemFunc.
func (mock *IDataLogPipelineMock) ExtractUserFromDataLogItem() {
	if mock.ExtractUserFromDataLogItemFunc == nil {
		panic("IDataLogPipelineMock.ExtractUserFromDataLogItemFunc: method is nil but IDataLogPipeline.ExtractUserFromDataLogItem was just called")
	}
	callInfo := struct {
	}{}
	mock.lockExtractUserFromDataLogItem.Lock()
	mock.calls.ExtractUserFromDataLogItem = append(mock.calls.ExtractUserFromDataLogItem, callInfo)
	mock.lockExtractUserFromDataLogItem.Unlock()
	mock.ExtractUserFromDataLogItemFunc()
}

// ExtractUserFromDataLogItemCalls gets all the calls that were made to ExtractUserFromDataLogItem.
// Check the length with:
//
//	len(mockedIDataLogPipeline.ExtractUserFromDataLogItemCalls())
func (mock *IDataLogPipelineMock) ExtractUserFromDataLogItemCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockExtractUserFromDataLogItem.RLock()
	calls = mock.calls.ExtractUserFromDataLogItem
	mock.lockExtractUserFromDataLogItem.RUnlock()
	return calls
}

// GetDataLog calls GetDataLogFunc.
func (mock *IDataLogPipelineMock) GetDataLog() *entity.DataLog {
	if mock.GetDataLogFunc == nil {
		panic("IDataLogPipelineMock.GetDataLogFunc: method is nil but IDataLogPipeline.GetDataLog was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetDataLog.Lock()
	mock.calls.GetDataLog = append(mock.calls.GetDataLog, callInfo)
	mock.lockGetDataLog.Unlock()
	return mock.GetDataLogFunc()
}

// GetDataLogCalls gets all the calls that were made to GetDataLog.
// Check the length with:
//
//	len(mockedIDataLogPipeline.GetDataLogCalls())
func (mock *IDataLogPipelineMock) GetDataLogCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetDataLog.RLock()
	calls = mock.calls.GetDataLog
	mock.lockGetDataLog.RUnlock()
	return calls
}

// GetDataLogsGenerated calls GetDataLogsGeneratedFunc.
func (mock *IDataLogPipelineMock) GetDataLogsGenerated() []*entity.DataLog {
	if mock.GetDataLogsGeneratedFunc == nil {
		panic("IDataLogPipelineMock.GetDataLogsGeneratedFunc: method is nil but IDataLogPipeline.GetDataLogsGenerated was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetDataLogsGenerated.Lock()
	mock.calls.GetDataLogsGenerated = append(mock.calls.GetDataLogsGenerated, callInfo)
	mock.lockGetDataLogsGenerated.Unlock()
	return mock.GetDataLogsGeneratedFunc()
}

// GetDataLogsGeneratedCalls gets all the calls that were made to GetDataLogsGenerated.
// Check the length with:
//
//	len(mockedIDataLogPipeline.GetDataLogsGeneratedCalls())
func (mock *IDataLogPipelineMock) GetDataLogsGeneratedCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetDataLogsGenerated.RLock()
	calls = mock.calls.GetDataLogsGenerated
	mock.lockGetDataLogsGenerated.RUnlock()
	return calls
}

// GetQueueResult calls GetQueueResultFunc.
func (mock *IDataLogPipelineMock) GetQueueResult() *common.DataLogInQueueResult {
	if mock.GetQueueResultFunc == nil {
		panic("IDataLogPipelineMock.GetQueueResultFunc: method is nil but IDataLogPipeline.GetQueueResult was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetQueueResult.Lock()
	mock.calls.GetQueueResult = append(mock.calls.GetQueueResult, callInfo)
	mock.lockGetQueueResult.Unlock()
	return mock.GetQueueResultFunc()
}

// GetQueueResultCalls gets all the calls that were made to GetQueueResult.
// Check the length with:
//
//	len(mockedIDataLogPipeline.GetQueueResultCalls())
func (mock *IDataLogPipelineMock) GetQueueResultCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetQueueResult.RLock()
	calls = mock.calls.GetQueueResult
	mock.lockGetQueueResult.RUnlock()
	return calls
}

// GetUserIDs calls GetUserIDsFunc.
func (mock *IDataLogPipelineMock) GetUserIDs() []string {
	if mock.GetUserIDsFunc == nil {
		panic("IDataLogPipelineMock.GetUserIDsFunc: method is nil but IDataLogPipeline.GetUserIDs was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetUserIDs.Lock()
	mock.calls.GetUserIDs = append(mock.calls.GetUserIDs, callInfo)
	mock.lockGetUserIDs.Unlock()
	return mock.GetUserIDsFunc()
}

// GetUserIDsCalls gets all the calls that were made to GetUserIDs.
// Check the length with:
//
//	len(mockedIDataLogPipeline.GetUserIDsCalls())
func (mock *IDataLogPipelineMock) GetUserIDsCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetUserIDs.RLock()
	calls = mock.calls.GetUserIDs
	mock.lockGetUserIDs.RUnlock()
	return calls
}

// GetWorkspace calls GetWorkspaceFunc.
func (mock *IDataLogPipelineMock) GetWorkspace() *entity.Workspace {
	if mock.GetWorkspaceFunc == nil {
		panic("IDataLogPipelineMock.GetWorkspaceFunc: method is nil but IDataLogPipeline.GetWorkspace was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetWorkspace.Lock()
	mock.calls.GetWorkspace = append(mock.calls.GetWorkspace, callInfo)
	mock.lockGetWorkspace.Unlock()
	return mock.GetWorkspaceFunc()
}

// GetWorkspaceCalls gets all the calls that were made to GetWorkspace.
// Check the length with:
//
//	len(mockedIDataLogPipeline.GetWorkspaceCalls())
func (mock *IDataLogPipelineMock) GetWorkspaceCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetWorkspace.RLock()
	calls = mock.calls.GetWorkspace
	mock.lockGetWorkspace.RUnlock()
	return calls
}

// HasError calls HasErrorFunc.
func (mock *IDataLogPipelineMock) HasError() bool {
	if mock.HasErrorFunc == nil {
		panic("IDataLogPipelineMock.HasErrorFunc: method is nil but IDataLogPipeline.HasError was just called")
	}
	callInfo := struct {
	}{}
	mock.lockHasError.Lock()
	mock.calls.HasError = append(mock.calls.HasError, callInfo)
	mock.lockHasError.Unlock()
	return mock.HasErrorFunc()
}

// HasErrorCalls gets all the calls that were made to HasError.
// Check the length with:
//
//	len(mockedIDataLogPipeline.HasErrorCalls())
func (mock *IDataLogPipelineMock) HasErrorCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockHasError.RLock()
	calls = mock.calls.HasError
	mock.lockHasError.RUnlock()
	return calls
}

// InitDataLog calls InitDataLogFunc.
func (mock *IDataLogPipelineMock) InitDataLog(ctx context.Context) {
	if mock.InitDataLogFunc == nil {
		panic("IDataLogPipelineMock.InitDataLogFunc: method is nil but IDataLogPipeline.InitDataLog was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockInitDataLog.Lock()
	mock.calls.InitDataLog = append(mock.calls.InitDataLog, callInfo)
	mock.lockInitDataLog.Unlock()
	mock.InitDataLogFunc(ctx)
}

// InitDataLogCalls gets all the calls that were made to InitDataLog.
// Check the length with:
//
//	len(mockedIDataLogPipeline.InitDataLogCalls())
func (mock *IDataLogPipelineMock) InitDataLogCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockInitDataLog.RLock()
	calls = mock.calls.InitDataLog
	mock.lockInitDataLog.RUnlock()
	return calls
}

// InsertChildDataLog calls InsertChildDataLogFunc.
func (mock *IDataLogPipelineMock) InsertChildDataLog(ctx context.Context, kind string, action string, userID string, itemID string, itemExternalID string, updatedFields entity.UpdatedFields, eventAt time.Time, tx *sql.Tx) error {
	if mock.InsertChildDataLogFunc == nil {
		panic("IDataLogPipelineMock.InsertChildDataLogFunc: method is nil but IDataLogPipeline.InsertChildDataLog was just called")
	}
	callInfo := struct {
		Ctx            context.Context
		Kind           string
		Action         string
		UserID         string
		ItemID         string
		ItemExternalID string
		UpdatedFields  entity.UpdatedFields
		EventAt        time.Time
		Tx             *sql.Tx
	}{
		Ctx:            ctx,
		Kind:           kind,
		Action:         action,
		UserID:         userID,
		ItemID:         itemID,
		ItemExternalID: itemExternalID,
		UpdatedFields:  updatedFields,
		EventAt:        eventAt,
		Tx:             tx,
	}
	mock.lockInsertChildDataLog.Lock()
	mock.calls.InsertChildDataLog = append(mock.calls.InsertChildDataLog, callInfo)
	mock.lockInsertChildDataLog.Unlock()
	return mock.InsertChildDataLogFunc(ctx, kind, action, userID, itemID, itemExternalID, updatedFields, eventAt, tx)
}

// InsertChildDataLogCalls gets all the calls that were made to InsertChildDataLog.
// Check the length with:
//
//	len(mockedIDataLogPipeline.InsertChildDataLogCalls())
func (mock *IDataLogPipelineMock) InsertChildDataLogCalls() []struct {
	Ctx            context.Context
	Kind           string
	Action         string
	UserID         string
	ItemID         string
	ItemExternalID string
	UpdatedFields  entity.UpdatedFields
	EventAt        time.Time
	Tx             *sql.Tx
} {
	var calls []struct {
		Ctx            context.Context
		Kind           string
		Action         string
		UserID         string
		ItemID         string
		ItemExternalID string
		UpdatedFields  entity.UpdatedFields
		EventAt        time.Time
		Tx             *sql.Tx
	}
	mock.lockInsertChildDataLog.RLock()
	calls = mock.calls.InsertChildDataLog
	mock.lockInsertChildDataLog.RUnlock()
	return calls
}

// LoadFxRates calls LoadFxRatesFunc.
func (mock *IDataLogPipelineMock) LoadFxRates(ctx context.Context) error {
	if mock.LoadFxRatesFunc == nil {
		panic("IDataLogPipelineMock.LoadFxRatesFunc: method is nil but IDataLogPipeline.LoadFxRates was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockLoadFxRates.Lock()
	mock.calls.LoadFxRates = append(mock.calls.LoadFxRates, callInfo)
	mock.lockLoadFxRates.Unlock()
	return mock.LoadFxRatesFunc(ctx)
}

// LoadFxRatesCalls gets all the calls that were made to LoadFxRates.
// Check the length with:
//
//	len(mockedIDataLogPipeline.LoadFxRatesCalls())
func (mock *IDataLogPipelineMock) LoadFxRatesCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockLoadFxRates.RLock()
	calls = mock.calls.LoadFxRates
	mock.lockLoadFxRates.RUnlock()
	return calls
}

// Net calls NetFunc.
func (mock *IDataLogPipelineMock) Net() httpClient.HTTPClient {
	if mock.NetFunc == nil {
		panic("IDataLogPipelineMock.NetFunc: method is nil but IDataLogPipeline.Net was just called")
	}
	callInfo := struct {
	}{}
	mock.lockNet.Lock()
	mock.calls.Net = append(mock.calls.Net, callInfo)
	mock.lockNet.Unlock()
	return mock.NetFunc()
}

// NetCalls gets all the calls that were made to Net.
// Check the length with:
//
//	len(mockedIDataLogPipeline.NetCalls())
func (mock *IDataLogPipelineMock) NetCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockNet.RLock()
	calls = mock.calls.Net
	mock.lockNet.RUnlock()
	return calls
}

// ParseUserAgent calls ParseUserAgentFunc.
func (mock *IDataLogPipelineMock) ParseUserAgent(userAgent string) (*entity.UserAgentResult, error) {
	if mock.ParseUserAgentFunc == nil {
		panic("IDataLogPipelineMock.ParseUserAgentFunc: method is nil but IDataLogPipeline.ParseUserAgent was just called")
	}
	callInfo := struct {
		UserAgent string
	}{
		UserAgent: userAgent,
	}
	mock.lockParseUserAgent.Lock()
	mock.calls.ParseUserAgent = append(mock.calls.ParseUserAgent, callInfo)
	mock.lockParseUserAgent.Unlock()
	return mock.ParseUserAgentFunc(userAgent)
}

// ParseUserAgentCalls gets all the calls that were made to ParseUserAgent.
// Check the length with:
//
//	len(mockedIDataLogPipeline.ParseUserAgentCalls())
func (mock *IDataLogPipelineMock) ParseUserAgentCalls() []struct {
	UserAgent string
} {
	var calls []struct {
		UserAgent string
	}
	mock.lockParseUserAgent.RLock()
	calls = mock.calls.ParseUserAgent
	mock.lockParseUserAgent.RUnlock()
	return calls
}

// ProcessNextStep calls ProcessNextStepFunc.
func (mock *IDataLogPipelineMock) ProcessNextStep(ctx context.Context) {
	if mock.ProcessNextStepFunc == nil {
		panic("IDataLogPipelineMock.ProcessNextStepFunc: method is nil but IDataLogPipeline.ProcessNextStep was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockProcessNextStep.Lock()
	mock.calls.ProcessNextStep = append(mock.calls.ProcessNextStep, callInfo)
	mock.lockProcessNextStep.Unlock()
	mock.ProcessNextStepFunc(ctx)
}

// ProcessNextStepCalls gets all the calls that were made to ProcessNextStep.
// Check the length with:
//
//	len(mockedIDataLogPipeline.ProcessNextStepCalls())
func (mock *IDataLogPipelineMock) ProcessNextStepCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockProcessNextStep.RLock()
	calls = mock.calls.ProcessNextStep
	mock.lockProcessNextStep.RUnlock()
	return calls
}

// ReattributeUsersOrders calls ReattributeUsersOrdersFunc.
func (mock *IDataLogPipelineMock) ReattributeUsersOrders(ctx context.Context) {
	if mock.ReattributeUsersOrdersFunc == nil {
		panic("IDataLogPipelineMock.ReattributeUsersOrdersFunc: method is nil but IDataLogPipeline.ReattributeUsersOrders was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockReattributeUsersOrders.Lock()
	mock.calls.ReattributeUsersOrders = append(mock.calls.ReattributeUsersOrders, callInfo)
	mock.lockReattributeUsersOrders.Unlock()
	mock.ReattributeUsersOrdersFunc(ctx)
}

// ReattributeUsersOrdersCalls gets all the calls that were made to ReattributeUsersOrders.
// Check the length with:
//
//	len(mockedIDataLogPipeline.ReattributeUsersOrdersCalls())
func (mock *IDataLogPipelineMock) ReattributeUsersOrdersCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockReattributeUsersOrders.RLock()
	calls = mock.calls.ReattributeUsersOrders
	mock.lockReattributeUsersOrders.RUnlock()
	return calls
}

// ReleaseUsersLock calls ReleaseUsersLockFunc.
func (mock *IDataLogPipelineMock) ReleaseUsersLock() error {
	if mock.ReleaseUsersLockFunc == nil {
		panic("IDataLogPipelineMock.ReleaseUsersLockFunc: method is nil but IDataLogPipeline.ReleaseUsersLock was just called")
	}
	callInfo := struct {
	}{}
	mock.lockReleaseUsersLock.Lock()
	mock.calls.ReleaseUsersLock = append(mock.calls.ReleaseUsersLock, callInfo)
	mock.lockReleaseUsersLock.Unlock()
	return mock.ReleaseUsersLockFunc()
}

// ReleaseUsersLockCalls gets all the calls that were made to ReleaseUsersLock.
// Check the length with:
//
//	len(mockedIDataLogPipeline.ReleaseUsersLockCalls())
func (mock *IDataLogPipelineMock) ReleaseUsersLockCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockReleaseUsersLock.RLock()
	calls = mock.calls.ReleaseUsersLock
	mock.lockReleaseUsersLock.RUnlock()
	return calls
}

// Replay calls ReplayFunc.
func (mock *IDataLogPipelineMock) Replay(ctx context.Context) {
	if mock.ReplayFunc == nil {
		panic("IDataLogPipelineMock.ReplayFunc: method is nil but IDataLogPipeline.Replay was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockReplay.Lock()
	mock.calls.Replay = append(mock.calls.Replay, callInfo)
	mock.lockReplay.Unlock()
	mock.ReplayFunc(ctx)
}

// ReplayCalls gets all the calls that were made to Replay.
// Check the length with:
//
//	len(mockedIDataLogPipeline.ReplayCalls())
func (mock *IDataLogPipelineMock) ReplayCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockReplay.RLock()
	calls = mock.calls.Replay
	mock.lockReplay.RUnlock()
	return calls
}

// Repo calls RepoFunc.
func (mock *IDataLogPipelineMock) Repo() repository.Repository {
	if mock.RepoFunc == nil {
		panic("IDataLogPipelineMock.RepoFunc: method is nil but IDataLogPipeline.Repo was just called")
	}
	callInfo := struct {
	}{}
	mock.lockRepo.Lock()
	mock.calls.Repo = append(mock.calls.Repo, callInfo)
	mock.lockRepo.Unlock()
	return mock.RepoFunc()
}

// RepoCalls gets all the calls that were made to Repo.
// Check the length with:
//
//	len(mockedIDataLogPipeline.RepoCalls())
func (mock *IDataLogPipelineMock) RepoCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockRepo.RLock()
	calls = mock.calls.Repo
	mock.lockRepo.RUnlock()
	return calls
}

// SetError calls SetErrorFunc.
func (mock *IDataLogPipelineMock) SetError(key string, err string, retryable bool) {
	if mock.SetErrorFunc == nil {
		panic("IDataLogPipelineMock.SetErrorFunc: method is nil but IDataLogPipeline.SetError was just called")
	}
	callInfo := struct {
		Key       string
		Err       string
		Retryable bool
	}{
		Key:       key,
		Err:       err,
		Retryable: retryable,
	}
	mock.lockSetError.Lock()
	mock.calls.SetError = append(mock.calls.SetError, callInfo)
	mock.lockSetError.Unlock()
	mock.SetErrorFunc(key, err, retryable)
}

// SetErrorCalls gets all the calls that were made to SetError.
// Check the length with:
//
//	len(mockedIDataLogPipeline.SetErrorCalls())
func (mock *IDataLogPipelineMock) SetErrorCalls() []struct {
	Key       string
	Err       string
	Retryable bool
} {
	var calls []struct {
		Key       string
		Err       string
		Retryable bool
	}
	mock.lockSetError.RLock()
	calls = mock.calls.SetError
	mock.lockSetError.RUnlock()
	return calls
}

// StepAttribution calls StepAttributionFunc.
func (mock *IDataLogPipelineMock) StepAttribution(ctx context.Context) {
	if mock.StepAttributionFunc == nil {
		panic("IDataLogPipelineMock.StepAttributionFunc: method is nil but IDataLogPipeline.StepAttribution was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockStepAttribution.Lock()
	mock.calls.StepAttribution = append(mock.calls.StepAttribution, callInfo)
	mock.lockStepAttribution.Unlock()
	mock.StepAttributionFunc(ctx)
}

// StepAttributionCalls gets all the calls that were made to StepAttribution.
// Check the length with:
//
//	len(mockedIDataLogPipeline.StepAttributionCalls())
func (mock *IDataLogPipelineMock) StepAttributionCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockStepAttribution.RLock()
	calls = mock.calls.StepAttribution
	mock.lockStepAttribution.RUnlock()
	return calls
}

// StepHookFinalize calls StepHookFinalizeFunc.
func (mock *IDataLogPipelineMock) StepHookFinalize(ctx context.Context) {
	if mock.StepHookFinalizeFunc == nil {
		panic("IDataLogPipelineMock.StepHookFinalizeFunc: method is nil but IDataLogPipeline.StepHookFinalize was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockStepHookFinalize.Lock()
	mock.calls.StepHookFinalize = append(mock.calls.StepHookFinalize, callInfo)
	mock.lockStepHookFinalize.Unlock()
	mock.StepHookFinalizeFunc(ctx)
}

// StepHookFinalizeCalls gets all the calls that were made to StepHookFinalize.
// Check the length with:
//
//	len(mockedIDataLogPipeline.StepHookFinalizeCalls())
func (mock *IDataLogPipelineMock) StepHookFinalizeCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockStepHookFinalize.RLock()
	calls = mock.calls.StepHookFinalize
	mock.lockStepHookFinalize.RUnlock()
	return calls
}

// StepPending calls StepPendingFunc.
func (mock *IDataLogPipelineMock) StepPending(ctx context.Context) {
	if mock.StepPendingFunc == nil {
		panic("IDataLogPipelineMock.StepPendingFunc: method is nil but IDataLogPipeline.StepPending was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockStepPending.Lock()
	mock.calls.StepPending = append(mock.calls.StepPending, callInfo)
	mock.lockStepPending.Unlock()
	mock.StepPendingFunc(ctx)
}

// StepPendingCalls gets all the calls that were made to StepPending.
// Check the length with:
//
//	len(mockedIDataLogPipeline.StepPendingCalls())
func (mock *IDataLogPipelineMock) StepPendingCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockStepPending.RLock()
	calls = mock.calls.StepPending
	mock.lockStepPending.RUnlock()
	return calls
}

// StepPersistDatalog calls StepPersistDatalogFunc.
func (mock *IDataLogPipelineMock) StepPersistDatalog(ctx context.Context) {
	if mock.StepPersistDatalogFunc == nil {
		panic("IDataLogPipelineMock.StepPersistDatalogFunc: method is nil but IDataLogPipeline.StepPersistDatalog was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockStepPersistDatalog.Lock()
	mock.calls.StepPersistDatalog = append(mock.calls.StepPersistDatalog, callInfo)
	mock.lockStepPersistDatalog.Unlock()
	mock.StepPersistDatalogFunc(ctx)
}

// StepPersistDatalogCalls gets all the calls that were made to StepPersistDatalog.
// Check the length with:
//
//	len(mockedIDataLogPipeline.StepPersistDatalogCalls())
func (mock *IDataLogPipelineMock) StepPersistDatalogCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockStepPersistDatalog.RLock()
	calls = mock.calls.StepPersistDatalog
	mock.lockStepPersistDatalog.RUnlock()
	return calls
}

// StepSegmentation calls StepSegmentationFunc.
func (mock *IDataLogPipelineMock) StepSegmentation(ctx context.Context) {
	if mock.StepSegmentationFunc == nil {
		panic("IDataLogPipelineMock.StepSegmentationFunc: method is nil but IDataLogPipeline.StepSegmentation was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockStepSegmentation.Lock()
	mock.calls.StepSegmentation = append(mock.calls.StepSegmentation, callInfo)
	mock.lockStepSegmentation.Unlock()
	mock.StepSegmentationFunc(ctx)
}

// StepSegmentationCalls gets all the calls that were made to StepSegmentation.
// Check the length with:
//
//	len(mockedIDataLogPipeline.StepSegmentationCalls())
func (mock *IDataLogPipelineMock) StepSegmentationCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockStepSegmentation.RLock()
	calls = mock.calls.StepSegmentation
	mock.lockStepSegmentation.RUnlock()
	return calls
}

// StepUpsertItem calls StepUpsertItemFunc.
func (mock *IDataLogPipelineMock) StepUpsertItem(ctx context.Context) {
	if mock.StepUpsertItemFunc == nil {
		panic("IDataLogPipelineMock.StepUpsertItemFunc: method is nil but IDataLogPipeline.StepUpsertItem was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockStepUpsertItem.Lock()
	mock.calls.StepUpsertItem = append(mock.calls.StepUpsertItem, callInfo)
	mock.lockStepUpsertItem.Unlock()
	mock.StepUpsertItemFunc(ctx)
}

// StepUpsertItemCalls gets all the calls that were made to StepUpsertItem.
// Check the length with:
//
//	len(mockedIDataLogPipeline.StepUpsertItemCalls())
func (mock *IDataLogPipelineMock) StepUpsertItemCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockStepUpsertItem.RLock()
	calls = mock.calls.StepUpsertItem
	mock.lockStepUpsertItem.RUnlock()
	return calls
}

// StepWorkflows calls StepWorkflowsFunc.
func (mock *IDataLogPipelineMock) StepWorkflows(ctx context.Context) {
	if mock.StepWorkflowsFunc == nil {
		panic("IDataLogPipelineMock.StepWorkflowsFunc: method is nil but IDataLogPipeline.StepWorkflows was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockStepWorkflows.Lock()
	mock.calls.StepWorkflows = append(mock.calls.StepWorkflows, callInfo)
	mock.lockStepWorkflows.Unlock()
	mock.StepWorkflowsFunc(ctx)
}

// StepWorkflowsCalls gets all the calls that were made to StepWorkflows.
// Check the length with:
//
//	len(mockedIDataLogPipeline.StepWorkflowsCalls())
func (mock *IDataLogPipelineMock) StepWorkflowsCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockStepWorkflows.RLock()
	calls = mock.calls.StepWorkflows
	mock.lockStepWorkflows.RUnlock()
	return calls
}

// UpsertAppItem calls UpsertAppItemFunc.
func (mock *IDataLogPipelineMock) UpsertAppItem(ctx context.Context, isChild bool, tx *sql.Tx) error {
	if mock.UpsertAppItemFunc == nil {
		panic("IDataLogPipelineMock.UpsertAppItemFunc: method is nil but IDataLogPipeline.UpsertAppItem was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		IsChild bool
		Tx      *sql.Tx
	}{
		Ctx:     ctx,
		IsChild: isChild,
		Tx:      tx,
	}
	mock.lockUpsertAppItem.Lock()
	mock.calls.UpsertAppItem = append(mock.calls.UpsertAppItem, callInfo)
	mock.lockUpsertAppItem.Unlock()
	return mock.UpsertAppItemFunc(ctx, isChild, tx)
}

// UpsertAppItemCalls gets all the calls that were made to UpsertAppItem.
// Check the length with:
//
//	len(mockedIDataLogPipeline.UpsertAppItemCalls())
func (mock *IDataLogPipelineMock) UpsertAppItemCalls() []struct {
	Ctx     context.Context
	IsChild bool
	Tx      *sql.Tx
} {
	var calls []struct {
		Ctx     context.Context
		IsChild bool
		Tx      *sql.Tx
	}
	mock.lockUpsertAppItem.RLock()
	calls = mock.calls.UpsertAppItem
	mock.lockUpsertAppItem.RUnlock()
	return calls
}

// UpsertCart calls UpsertCartFunc.
func (mock *IDataLogPipelineMock) UpsertCart(ctx context.Context, isChild bool, tx *sql.Tx) error {
	if mock.UpsertCartFunc == nil {
		panic("IDataLogPipelineMock.UpsertCartFunc: method is nil but IDataLogPipeline.UpsertCart was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		IsChild bool
		Tx      *sql.Tx
	}{
		Ctx:     ctx,
		IsChild: isChild,
		Tx:      tx,
	}
	mock.lockUpsertCart.Lock()
	mock.calls.UpsertCart = append(mock.calls.UpsertCart, callInfo)
	mock.lockUpsertCart.Unlock()
	return mock.UpsertCartFunc(ctx, isChild, tx)
}

// UpsertCartCalls gets all the calls that were made to UpsertCart.
// Check the length with:
//
//	len(mockedIDataLogPipeline.UpsertCartCalls())
func (mock *IDataLogPipelineMock) UpsertCartCalls() []struct {
	Ctx     context.Context
	IsChild bool
	Tx      *sql.Tx
} {
	var calls []struct {
		Ctx     context.Context
		IsChild bool
		Tx      *sql.Tx
	}
	mock.lockUpsertCart.RLock()
	calls = mock.calls.UpsertCart
	mock.lockUpsertCart.RUnlock()
	return calls
}

// UpsertCustomEvent calls UpsertCustomEventFunc.
func (mock *IDataLogPipelineMock) UpsertCustomEvent(ctx context.Context, isChild bool, tx *sql.Tx) error {
	if mock.UpsertCustomEventFunc == nil {
		panic("IDataLogPipelineMock.UpsertCustomEventFunc: method is nil but IDataLogPipeline.UpsertCustomEvent was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		IsChild bool
		Tx      *sql.Tx
	}{
		Ctx:     ctx,
		IsChild: isChild,
		Tx:      tx,
	}
	mock.lockUpsertCustomEvent.Lock()
	mock.calls.UpsertCustomEvent = append(mock.calls.UpsertCustomEvent, callInfo)
	mock.lockUpsertCustomEvent.Unlock()
	return mock.UpsertCustomEventFunc(ctx, isChild, tx)
}

// UpsertCustomEventCalls gets all the calls that were made to UpsertCustomEvent.
// Check the length with:
//
//	len(mockedIDataLogPipeline.UpsertCustomEventCalls())
func (mock *IDataLogPipelineMock) UpsertCustomEventCalls() []struct {
	Ctx     context.Context
	IsChild bool
	Tx      *sql.Tx
} {
	var calls []struct {
		Ctx     context.Context
		IsChild bool
		Tx      *sql.Tx
	}
	mock.lockUpsertCustomEvent.RLock()
	calls = mock.calls.UpsertCustomEvent
	mock.lockUpsertCustomEvent.RUnlock()
	return calls
}

// UpsertDevice calls UpsertDeviceFunc.
func (mock *IDataLogPipelineMock) UpsertDevice(ctx context.Context, isChild bool, tx *sql.Tx) error {
	if mock.UpsertDeviceFunc == nil {
		panic("IDataLogPipelineMock.UpsertDeviceFunc: method is nil but IDataLogPipeline.UpsertDevice was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		IsChild bool
		Tx      *sql.Tx
	}{
		Ctx:     ctx,
		IsChild: isChild,
		Tx:      tx,
	}
	mock.lockUpsertDevice.Lock()
	mock.calls.UpsertDevice = append(mock.calls.UpsertDevice, callInfo)
	mock.lockUpsertDevice.Unlock()
	return mock.UpsertDeviceFunc(ctx, isChild, tx)
}

// UpsertDeviceCalls gets all the calls that were made to UpsertDevice.
// Check the length with:
//
//	len(mockedIDataLogPipeline.UpsertDeviceCalls())
func (mock *IDataLogPipelineMock) UpsertDeviceCalls() []struct {
	Ctx     context.Context
	IsChild bool
	Tx      *sql.Tx
} {
	var calls []struct {
		Ctx     context.Context
		IsChild bool
		Tx      *sql.Tx
	}
	mock.lockUpsertDevice.RLock()
	calls = mock.calls.UpsertDevice
	mock.lockUpsertDevice.RUnlock()
	return calls
}

// UpsertOrder calls UpsertOrderFunc.
func (mock *IDataLogPipelineMock) UpsertOrder(ctx context.Context, isChild bool, tx *sql.Tx) error {
	if mock.UpsertOrderFunc == nil {
		panic("IDataLogPipelineMock.UpsertOrderFunc: method is nil but IDataLogPipeline.UpsertOrder was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		IsChild bool
		Tx      *sql.Tx
	}{
		Ctx:     ctx,
		IsChild: isChild,
		Tx:      tx,
	}
	mock.lockUpsertOrder.Lock()
	mock.calls.UpsertOrder = append(mock.calls.UpsertOrder, callInfo)
	mock.lockUpsertOrder.Unlock()
	return mock.UpsertOrderFunc(ctx, isChild, tx)
}

// UpsertOrderCalls gets all the calls that were made to UpsertOrder.
// Check the length with:
//
//	len(mockedIDataLogPipeline.UpsertOrderCalls())
func (mock *IDataLogPipelineMock) UpsertOrderCalls() []struct {
	Ctx     context.Context
	IsChild bool
	Tx      *sql.Tx
} {
	var calls []struct {
		Ctx     context.Context
		IsChild bool
		Tx      *sql.Tx
	}
	mock.lockUpsertOrder.RLock()
	calls = mock.calls.UpsertOrder
	mock.lockUpsertOrder.RUnlock()
	return calls
}

// UpsertPageview calls UpsertPageviewFunc.
func (mock *IDataLogPipelineMock) UpsertPageview(ctx context.Context, isChild bool, tx *sql.Tx) error {
	if mock.UpsertPageviewFunc == nil {
		panic("IDataLogPipelineMock.UpsertPageviewFunc: method is nil but IDataLogPipeline.UpsertPageview was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		IsChild bool
		Tx      *sql.Tx
	}{
		Ctx:     ctx,
		IsChild: isChild,
		Tx:      tx,
	}
	mock.lockUpsertPageview.Lock()
	mock.calls.UpsertPageview = append(mock.calls.UpsertPageview, callInfo)
	mock.lockUpsertPageview.Unlock()
	return mock.UpsertPageviewFunc(ctx, isChild, tx)
}

// UpsertPageviewCalls gets all the calls that were made to UpsertPageview.
// Check the length with:
//
//	len(mockedIDataLogPipeline.UpsertPageviewCalls())
func (mock *IDataLogPipelineMock) UpsertPageviewCalls() []struct {
	Ctx     context.Context
	IsChild bool
	Tx      *sql.Tx
} {
	var calls []struct {
		Ctx     context.Context
		IsChild bool
		Tx      *sql.Tx
	}
	mock.lockUpsertPageview.RLock()
	calls = mock.calls.UpsertPageview
	mock.lockUpsertPageview.RUnlock()
	return calls
}

// UpsertPostview calls UpsertPostviewFunc.
func (mock *IDataLogPipelineMock) UpsertPostview(ctx context.Context, isChild bool, tx *sql.Tx) error {
	if mock.UpsertPostviewFunc == nil {
		panic("IDataLogPipelineMock.UpsertPostviewFunc: method is nil but IDataLogPipeline.UpsertPostview was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		IsChild bool
		Tx      *sql.Tx
	}{
		Ctx:     ctx,
		IsChild: isChild,
		Tx:      tx,
	}
	mock.lockUpsertPostview.Lock()
	mock.calls.UpsertPostview = append(mock.calls.UpsertPostview, callInfo)
	mock.lockUpsertPostview.Unlock()
	return mock.UpsertPostviewFunc(ctx, isChild, tx)
}

// UpsertPostviewCalls gets all the calls that were made to UpsertPostview.
// Check the length with:
//
//	len(mockedIDataLogPipeline.UpsertPostviewCalls())
func (mock *IDataLogPipelineMock) UpsertPostviewCalls() []struct {
	Ctx     context.Context
	IsChild bool
	Tx      *sql.Tx
} {
	var calls []struct {
		Ctx     context.Context
		IsChild bool
		Tx      *sql.Tx
	}
	mock.lockUpsertPostview.RLock()
	calls = mock.calls.UpsertPostview
	mock.lockUpsertPostview.RUnlock()
	return calls
}

// UpsertSession calls UpsertSessionFunc.
func (mock *IDataLogPipelineMock) UpsertSession(ctx context.Context, isChild bool, tx *sql.Tx) error {
	if mock.UpsertSessionFunc == nil {
		panic("IDataLogPipelineMock.UpsertSessionFunc: method is nil but IDataLogPipeline.UpsertSession was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		IsChild bool
		Tx      *sql.Tx
	}{
		Ctx:     ctx,
		IsChild: isChild,
		Tx:      tx,
	}
	mock.lockUpsertSession.Lock()
	mock.calls.UpsertSession = append(mock.calls.UpsertSession, callInfo)
	mock.lockUpsertSession.Unlock()
	return mock.UpsertSessionFunc(ctx, isChild, tx)
}

// UpsertSessionCalls gets all the calls that were made to UpsertSession.
// Check the length with:
//
//	len(mockedIDataLogPipeline.UpsertSessionCalls())
func (mock *IDataLogPipelineMock) UpsertSessionCalls() []struct {
	Ctx     context.Context
	IsChild bool
	Tx      *sql.Tx
} {
	var calls []struct {
		Ctx     context.Context
		IsChild bool
		Tx      *sql.Tx
	}
	mock.lockUpsertSession.RLock()
	calls = mock.calls.UpsertSession
	mock.lockUpsertSession.RUnlock()
	return calls
}

// UpsertUser calls UpsertUserFunc.
func (mock *IDataLogPipelineMock) UpsertUser(ctx context.Context, isChild bool, tx *sql.Tx) error {
	if mock.UpsertUserFunc == nil {
		panic("IDataLogPipelineMock.UpsertUserFunc: method is nil but IDataLogPipeline.UpsertUser was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		IsChild bool
		Tx      *sql.Tx
	}{
		Ctx:     ctx,
		IsChild: isChild,
		Tx:      tx,
	}
	mock.lockUpsertUser.Lock()
	mock.calls.UpsertUser = append(mock.calls.UpsertUser, callInfo)
	mock.lockUpsertUser.Unlock()
	return mock.UpsertUserFunc(ctx, isChild, tx)
}

// UpsertUserCalls gets all the calls that were made to UpsertUser.
// Check the length with:
//
//	len(mockedIDataLogPipeline.UpsertUserCalls())
func (mock *IDataLogPipelineMock) UpsertUserCalls() []struct {
	Ctx     context.Context
	IsChild bool
	Tx      *sql.Tx
} {
	var calls []struct {
		Ctx     context.Context
		IsChild bool
		Tx      *sql.Tx
	}
	mock.lockUpsertUser.RLock()
	calls = mock.calls.UpsertUser
	mock.lockUpsertUser.RUnlock()
	return calls
}

// UpsertUserAlias calls UpsertUserAliasFunc.
func (mock *IDataLogPipelineMock) UpsertUserAlias(ctx context.Context, isChild bool, tx *sql.Tx) error {
	if mock.UpsertUserAliasFunc == nil {
		panic("IDataLogPipelineMock.UpsertUserAliasFunc: method is nil but IDataLogPipeline.UpsertUserAlias was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		IsChild bool
		Tx      *sql.Tx
	}{
		Ctx:     ctx,
		IsChild: isChild,
		Tx:      tx,
	}
	mock.lockUpsertUserAlias.Lock()
	mock.calls.UpsertUserAlias = append(mock.calls.UpsertUserAlias, callInfo)
	mock.lockUpsertUserAlias.Unlock()
	return mock.UpsertUserAliasFunc(ctx, isChild, tx)
}

// UpsertUserAliasCalls gets all the calls that were made to UpsertUserAlias.
// Check the length with:
//
//	len(mockedIDataLogPipeline.UpsertUserAliasCalls())
func (mock *IDataLogPipelineMock) UpsertUserAliasCalls() []struct {
	Ctx     context.Context
	IsChild bool
	Tx      *sql.Tx
} {
	var calls []struct {
		Ctx     context.Context
		IsChild bool
		Tx      *sql.Tx
	}
	mock.lockUpsertUserAlias.RLock()
	calls = mock.calls.UpsertUserAlias
	mock.lockUpsertUserAlias.RUnlock()
	return calls
}
