// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package taskorchestrator

import (
	"context"
	"github.com/rimdian/rimdian/internal/api/dto"
	"sync"
)

// Ensure, that ClientMock does implement Client.
// If this is not the case, regenerate this file with moq.
var _ Client = &ClientMock{}

// ClientMock is a mock implementation of Client.
//
//	func TestSomethingThatUsesClient(t *testing.T) {
//
//		// make and configure a mocked Client
//		mockedClient := &ClientMock{
//			DeleteTaskFunc: func(ctx context.Context, queueLocation string, queueName string, taskID string) error {
//				panic("mock out the DeleteTask method")
//			},
//			EnsureQueueFunc: func(ctx context.Context, queueLocation string, queueName string, maxConcurrent int32) error {
//				panic("mock out the EnsureQueue method")
//			},
//			GetHistoricalQueueNameForWorkspaceFunc: func(workspaceID string) string {
//				panic("mock out the GetHistoricalQueueNameForWorkspace method")
//			},
//			GetLiveQueueNameForWorkspaceFunc: func(workspaceID string) string {
//				panic("mock out the GetLiveQueueNameForWorkspace method")
//			},
//			GetMarketingMessageQueueNameForWorkspaceFunc: func(workspaceID string) string {
//				panic("mock out the GetMarketingMessageQueueNameForWorkspace method")
//			},
//			GetTaskRunningJobFunc: func(ctx context.Context, queueLocation string, queueName string, taskID string) (*dto.TaskExecJobInfoInfo, error) {
//				panic("mock out the GetTaskRunningJob method")
//			},
//			GetTransactionalMessageQueueNameForWorkspaceFunc: func(workspaceID string) string {
//				panic("mock out the GetTransactionalMessageQueueNameForWorkspace method")
//			},
//			PostRequestFunc: func(ctx context.Context, taskRequest *TaskRequest) error {
//				panic("mock out the PostRequest method")
//			},
//		}
//
//		// use mockedClient in code that requires Client
//		// and then make assertions.
//
//	}
type ClientMock struct {
	// DeleteTaskFunc mocks the DeleteTask method.
	DeleteTaskFunc func(ctx context.Context, queueLocation string, queueName string, taskID string) error

	// EnsureQueueFunc mocks the EnsureQueue method.
	EnsureQueueFunc func(ctx context.Context, queueLocation string, queueName string, maxConcurrent int32) error

	// GetHistoricalQueueNameForWorkspaceFunc mocks the GetHistoricalQueueNameForWorkspace method.
	GetHistoricalQueueNameForWorkspaceFunc func(workspaceID string) string

	// GetLiveQueueNameForWorkspaceFunc mocks the GetLiveQueueNameForWorkspace method.
	GetLiveQueueNameForWorkspaceFunc func(workspaceID string) string

	// GetMarketingMessageQueueNameForWorkspaceFunc mocks the GetMarketingMessageQueueNameForWorkspace method.
	GetMarketingMessageQueueNameForWorkspaceFunc func(workspaceID string) string

	// GetTaskRunningJobFunc mocks the GetTaskRunningJob method.
	GetTaskRunningJobFunc func(ctx context.Context, queueLocation string, queueName string, taskID string) (*dto.TaskExecJobInfoInfo, error)

	// GetTransactionalMessageQueueNameForWorkspaceFunc mocks the GetTransactionalMessageQueueNameForWorkspace method.
	GetTransactionalMessageQueueNameForWorkspaceFunc func(workspaceID string) string

	// PostRequestFunc mocks the PostRequest method.
	PostRequestFunc func(ctx context.Context, taskRequest *TaskRequest) error

	// calls tracks calls to the methods.
	calls struct {
		// DeleteTask holds details about calls to the DeleteTask method.
		DeleteTask []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// QueueLocation is the queueLocation argument value.
			QueueLocation string
			// QueueName is the queueName argument value.
			QueueName string
			// TaskID is the taskID argument value.
			TaskID string
		}
		// EnsureQueue holds details about calls to the EnsureQueue method.
		EnsureQueue []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// QueueLocation is the queueLocation argument value.
			QueueLocation string
			// QueueName is the queueName argument value.
			QueueName string
			// MaxConcurrent is the maxConcurrent argument value.
			MaxConcurrent int32
		}
		// GetHistoricalQueueNameForWorkspace holds details about calls to the GetHistoricalQueueNameForWorkspace method.
		GetHistoricalQueueNameForWorkspace []struct {
			// WorkspaceID is the workspaceID argument value.
			WorkspaceID string
		}
		// GetLiveQueueNameForWorkspace holds details about calls to the GetLiveQueueNameForWorkspace method.
		GetLiveQueueNameForWorkspace []struct {
			// WorkspaceID is the workspaceID argument value.
			WorkspaceID string
		}
		// GetMarketingMessageQueueNameForWorkspace holds details about calls to the GetMarketingMessageQueueNameForWorkspace method.
		GetMarketingMessageQueueNameForWorkspace []struct {
			// WorkspaceID is the workspaceID argument value.
			WorkspaceID string
		}
		// GetTaskRunningJob holds details about calls to the GetTaskRunningJob method.
		GetTaskRunningJob []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// QueueLocation is the queueLocation argument value.
			QueueLocation string
			// QueueName is the queueName argument value.
			QueueName string
			// TaskID is the taskID argument value.
			TaskID string
		}
		// GetTransactionalMessageQueueNameForWorkspace holds details about calls to the GetTransactionalMessageQueueNameForWorkspace method.
		GetTransactionalMessageQueueNameForWorkspace []struct {
			// WorkspaceID is the workspaceID argument value.
			WorkspaceID string
		}
		// PostRequest holds details about calls to the PostRequest method.
		PostRequest []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TaskRequest is the taskRequest argument value.
			TaskRequest *TaskRequest
		}
	}
	lockDeleteTask                                   sync.RWMutex
	lockEnsureQueue                                  sync.RWMutex
	lockGetHistoricalQueueNameForWorkspace           sync.RWMutex
	lockGetLiveQueueNameForWorkspace                 sync.RWMutex
	lockGetMarketingMessageQueueNameForWorkspace     sync.RWMutex
	lockGetTaskRunningJob                            sync.RWMutex
	lockGetTransactionalMessageQueueNameForWorkspace sync.RWMutex
	lockPostRequest                                  sync.RWMutex
}

// DeleteTask calls DeleteTaskFunc.
func (mock *ClientMock) DeleteTask(ctx context.Context, queueLocation string, queueName string, taskID string) error {
	if mock.DeleteTaskFunc == nil {
		panic("ClientMock.DeleteTaskFunc: method is nil but Client.DeleteTask was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		QueueLocation string
		QueueName     string
		TaskID        string
	}{
		Ctx:           ctx,
		QueueLocation: queueLocation,
		QueueName:     queueName,
		TaskID:        taskID,
	}
	mock.lockDeleteTask.Lock()
	mock.calls.DeleteTask = append(mock.calls.DeleteTask, callInfo)
	mock.lockDeleteTask.Unlock()
	return mock.DeleteTaskFunc(ctx, queueLocation, queueName, taskID)
}

// DeleteTaskCalls gets all the calls that were made to DeleteTask.
// Check the length with:
//
//	len(mockedClient.DeleteTaskCalls())
func (mock *ClientMock) DeleteTaskCalls() []struct {
	Ctx           context.Context
	QueueLocation string
	QueueName     string
	TaskID        string
} {
	var calls []struct {
		Ctx           context.Context
		QueueLocation string
		QueueName     string
		TaskID        string
	}
	mock.lockDeleteTask.RLock()
	calls = mock.calls.DeleteTask
	mock.lockDeleteTask.RUnlock()
	return calls
}

// EnsureQueue calls EnsureQueueFunc.
func (mock *ClientMock) EnsureQueue(ctx context.Context, queueLocation string, queueName string, maxConcurrent int32) error {
	if mock.EnsureQueueFunc == nil {
		panic("ClientMock.EnsureQueueFunc: method is nil but Client.EnsureQueue was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		QueueLocation string
		QueueName     string
		MaxConcurrent int32
	}{
		Ctx:           ctx,
		QueueLocation: queueLocation,
		QueueName:     queueName,
		MaxConcurrent: maxConcurrent,
	}
	mock.lockEnsureQueue.Lock()
	mock.calls.EnsureQueue = append(mock.calls.EnsureQueue, callInfo)
	mock.lockEnsureQueue.Unlock()
	return mock.EnsureQueueFunc(ctx, queueLocation, queueName, maxConcurrent)
}

// EnsureQueueCalls gets all the calls that were made to EnsureQueue.
// Check the length with:
//
//	len(mockedClient.EnsureQueueCalls())
func (mock *ClientMock) EnsureQueueCalls() []struct {
	Ctx           context.Context
	QueueLocation string
	QueueName     string
	MaxConcurrent int32
} {
	var calls []struct {
		Ctx           context.Context
		QueueLocation string
		QueueName     string
		MaxConcurrent int32
	}
	mock.lockEnsureQueue.RLock()
	calls = mock.calls.EnsureQueue
	mock.lockEnsureQueue.RUnlock()
	return calls
}

// GetHistoricalQueueNameForWorkspace calls GetHistoricalQueueNameForWorkspaceFunc.
func (mock *ClientMock) GetHistoricalQueueNameForWorkspace(workspaceID string) string {
	if mock.GetHistoricalQueueNameForWorkspaceFunc == nil {
		panic("ClientMock.GetHistoricalQueueNameForWorkspaceFunc: method is nil but Client.GetHistoricalQueueNameForWorkspace was just called")
	}
	callInfo := struct {
		WorkspaceID string
	}{
		WorkspaceID: workspaceID,
	}
	mock.lockGetHistoricalQueueNameForWorkspace.Lock()
	mock.calls.GetHistoricalQueueNameForWorkspace = append(mock.calls.GetHistoricalQueueNameForWorkspace, callInfo)
	mock.lockGetHistoricalQueueNameForWorkspace.Unlock()
	return mock.GetHistoricalQueueNameForWorkspaceFunc(workspaceID)
}

// GetHistoricalQueueNameForWorkspaceCalls gets all the calls that were made to GetHistoricalQueueNameForWorkspace.
// Check the length with:
//
//	len(mockedClient.GetHistoricalQueueNameForWorkspaceCalls())
func (mock *ClientMock) GetHistoricalQueueNameForWorkspaceCalls() []struct {
	WorkspaceID string
} {
	var calls []struct {
		WorkspaceID string
	}
	mock.lockGetHistoricalQueueNameForWorkspace.RLock()
	calls = mock.calls.GetHistoricalQueueNameForWorkspace
	mock.lockGetHistoricalQueueNameForWorkspace.RUnlock()
	return calls
}

// GetLiveQueueNameForWorkspace calls GetLiveQueueNameForWorkspaceFunc.
func (mock *ClientMock) GetLiveQueueNameForWorkspace(workspaceID string) string {
	if mock.GetLiveQueueNameForWorkspaceFunc == nil {
		panic("ClientMock.GetLiveQueueNameForWorkspaceFunc: method is nil but Client.GetLiveQueueNameForWorkspace was just called")
	}
	callInfo := struct {
		WorkspaceID string
	}{
		WorkspaceID: workspaceID,
	}
	mock.lockGetLiveQueueNameForWorkspace.Lock()
	mock.calls.GetLiveQueueNameForWorkspace = append(mock.calls.GetLiveQueueNameForWorkspace, callInfo)
	mock.lockGetLiveQueueNameForWorkspace.Unlock()
	return mock.GetLiveQueueNameForWorkspaceFunc(workspaceID)
}

// GetLiveQueueNameForWorkspaceCalls gets all the calls that were made to GetLiveQueueNameForWorkspace.
// Check the length with:
//
//	len(mockedClient.GetLiveQueueNameForWorkspaceCalls())
func (mock *ClientMock) GetLiveQueueNameForWorkspaceCalls() []struct {
	WorkspaceID string
} {
	var calls []struct {
		WorkspaceID string
	}
	mock.lockGetLiveQueueNameForWorkspace.RLock()
	calls = mock.calls.GetLiveQueueNameForWorkspace
	mock.lockGetLiveQueueNameForWorkspace.RUnlock()
	return calls
}

// GetMarketingMessageQueueNameForWorkspace calls GetMarketingMessageQueueNameForWorkspaceFunc.
func (mock *ClientMock) GetMarketingMessageQueueNameForWorkspace(workspaceID string) string {
	if mock.GetMarketingMessageQueueNameForWorkspaceFunc == nil {
		panic("ClientMock.GetMarketingMessageQueueNameForWorkspaceFunc: method is nil but Client.GetMarketingMessageQueueNameForWorkspace was just called")
	}
	callInfo := struct {
		WorkspaceID string
	}{
		WorkspaceID: workspaceID,
	}
	mock.lockGetMarketingMessageQueueNameForWorkspace.Lock()
	mock.calls.GetMarketingMessageQueueNameForWorkspace = append(mock.calls.GetMarketingMessageQueueNameForWorkspace, callInfo)
	mock.lockGetMarketingMessageQueueNameForWorkspace.Unlock()
	return mock.GetMarketingMessageQueueNameForWorkspaceFunc(workspaceID)
}

// GetMarketingMessageQueueNameForWorkspaceCalls gets all the calls that were made to GetMarketingMessageQueueNameForWorkspace.
// Check the length with:
//
//	len(mockedClient.GetMarketingMessageQueueNameForWorkspaceCalls())
func (mock *ClientMock) GetMarketingMessageQueueNameForWorkspaceCalls() []struct {
	WorkspaceID string
} {
	var calls []struct {
		WorkspaceID string
	}
	mock.lockGetMarketingMessageQueueNameForWorkspace.RLock()
	calls = mock.calls.GetMarketingMessageQueueNameForWorkspace
	mock.lockGetMarketingMessageQueueNameForWorkspace.RUnlock()
	return calls
}

// GetTaskRunningJob calls GetTaskRunningJobFunc.
func (mock *ClientMock) GetTaskRunningJob(ctx context.Context, queueLocation string, queueName string, taskID string) (*dto.TaskExecJobInfoInfo, error) {
	if mock.GetTaskRunningJobFunc == nil {
		panic("ClientMock.GetTaskRunningJobFunc: method is nil but Client.GetTaskRunningJob was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		QueueLocation string
		QueueName     string
		TaskID        string
	}{
		Ctx:           ctx,
		QueueLocation: queueLocation,
		QueueName:     queueName,
		TaskID:        taskID,
	}
	mock.lockGetTaskRunningJob.Lock()
	mock.calls.GetTaskRunningJob = append(mock.calls.GetTaskRunningJob, callInfo)
	mock.lockGetTaskRunningJob.Unlock()
	return mock.GetTaskRunningJobFunc(ctx, queueLocation, queueName, taskID)
}

// GetTaskRunningJobCalls gets all the calls that were made to GetTaskRunningJob.
// Check the length with:
//
//	len(mockedClient.GetTaskRunningJobCalls())
func (mock *ClientMock) GetTaskRunningJobCalls() []struct {
	Ctx           context.Context
	QueueLocation string
	QueueName     string
	TaskID        string
} {
	var calls []struct {
		Ctx           context.Context
		QueueLocation string
		QueueName     string
		TaskID        string
	}
	mock.lockGetTaskRunningJob.RLock()
	calls = mock.calls.GetTaskRunningJob
	mock.lockGetTaskRunningJob.RUnlock()
	return calls
}

// GetTransactionalMessageQueueNameForWorkspace calls GetTransactionalMessageQueueNameForWorkspaceFunc.
func (mock *ClientMock) GetTransactionalMessageQueueNameForWorkspace(workspaceID string) string {
	if mock.GetTransactionalMessageQueueNameForWorkspaceFunc == nil {
		panic("ClientMock.GetTransactionalMessageQueueNameForWorkspaceFunc: method is nil but Client.GetTransactionalMessageQueueNameForWorkspace was just called")
	}
	callInfo := struct {
		WorkspaceID string
	}{
		WorkspaceID: workspaceID,
	}
	mock.lockGetTransactionalMessageQueueNameForWorkspace.Lock()
	mock.calls.GetTransactionalMessageQueueNameForWorkspace = append(mock.calls.GetTransactionalMessageQueueNameForWorkspace, callInfo)
	mock.lockGetTransactionalMessageQueueNameForWorkspace.Unlock()
	return mock.GetTransactionalMessageQueueNameForWorkspaceFunc(workspaceID)
}

// GetTransactionalMessageQueueNameForWorkspaceCalls gets all the calls that were made to GetTransactionalMessageQueueNameForWorkspace.
// Check the length with:
//
//	len(mockedClient.GetTransactionalMessageQueueNameForWorkspaceCalls())
func (mock *ClientMock) GetTransactionalMessageQueueNameForWorkspaceCalls() []struct {
	WorkspaceID string
} {
	var calls []struct {
		WorkspaceID string
	}
	mock.lockGetTransactionalMessageQueueNameForWorkspace.RLock()
	calls = mock.calls.GetTransactionalMessageQueueNameForWorkspace
	mock.lockGetTransactionalMessageQueueNameForWorkspace.RUnlock()
	return calls
}

// PostRequest calls PostRequestFunc.
func (mock *ClientMock) PostRequest(ctx context.Context, taskRequest *TaskRequest) error {
	if mock.PostRequestFunc == nil {
		panic("ClientMock.PostRequestFunc: method is nil but Client.PostRequest was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		TaskRequest *TaskRequest
	}{
		Ctx:         ctx,
		TaskRequest: taskRequest,
	}
	mock.lockPostRequest.Lock()
	mock.calls.PostRequest = append(mock.calls.PostRequest, callInfo)
	mock.lockPostRequest.Unlock()
	return mock.PostRequestFunc(ctx, taskRequest)
}

// PostRequestCalls gets all the calls that were made to PostRequest.
// Check the length with:
//
//	len(mockedClient.PostRequestCalls())
func (mock *ClientMock) PostRequestCalls() []struct {
	Ctx         context.Context
	TaskRequest *TaskRequest
} {
	var calls []struct {
		Ctx         context.Context
		TaskRequest *TaskRequest
	}
	mock.lockPostRequest.RLock()
	calls = mock.calls.PostRequest
	mock.lockPostRequest.RUnlock()
	return calls
}
